/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.6.37 : Database - examination
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`examination` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `examination`;

/*Table structure for table `Questions_answer` */

DROP TABLE IF EXISTS `Questions_answer`;

CREATE TABLE `Questions_answer` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `Questions_option_lable` varchar(10) NOT NULL COMMENT '正确答案选项标签',
  `uid` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1606 DEFAULT CHARSET=utf8 COMMENT='题干答案';

/*Data for the table `Questions_answer` */

insert  into `Questions_answer`(`id`,`Questions_option_lable`,`uid`) values (500,'D','57a446633a6543388814b664cc005444'),(501,'D','55037bdaaef44631936cccd2070f04ab'),(502,'A','22ef1cce8ae64e92b08dd789dfb27419'),(503,'D','3645ee7246f34091a6d3d0ef22c49c00'),(504,'a','267f4a4ba6934a39ab9e1689283ff7fb'),(505,'b','aa881d921b0544be89a86d369dc3056a'),(506,'C','4769b8c5f68f4f2eb98af9f64b01292c'),(507,'B','1c1b1268552d44828a9592f15a20627d'),(508,'B','e6aa897d8ff442a68dc5fa753bc6afed'),(509,'c','c55b2d9f4e994f94a0d9110f8abf8450'),(510,'A','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(511,'B','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(512,'B','9370fff49d4840369fb3da6af52ef496'),(513,'D','9370fff49d4840369fb3da6af52ef496'),(514,'C','92c286733e354108bc40d94fe32414e2'),(515,'C','6dd4b94cae584048a78ef2856d6f3985'),(516,'C','6fed36f8c2664e888fdbad4481f64cab'),(517,'c','5d58d18f32e14553ad1b129049bae92d'),(518,'c','89e81dca7dbe48e395cb97dff26e5b66'),(519,'A','972c3583242545488cce4cd741865238'),(520,'D','972c3583242545488cce4cd741865238'),(521,'C','9b98e4a9feef437aa187ae9285477fc7'),(522,'D','9b98e4a9feef437aa187ae9285477fc7'),(523,'B','5f960859db894c6cb7f71999401b4ddd'),(524,'D','7809e2eac65449e9a7908838242ec00c'),(525,'D','2d256d0fbedb44e281b16ece605f1038'),(526,'B','f0d0e20f35ea4b0380142dd997f77192'),(527,'C','f0d0e20f35ea4b0380142dd997f77192'),(528,'D','f0d0e20f35ea4b0380142dd997f77192'),(529,'C','cebc951416ec45a581a571570054eb91'),(530,'A','d949a72652944528ba271a4a158d1c6d'),(531,'D','d949a72652944528ba271a4a158d1c6d'),(532,'A','5e1321e3ee05405f864afcccf88e1561'),(533,'D','5e1321e3ee05405f864afcccf88e1561'),(534,'C','8e4dd2ebe2bb491e8a337134269185d7'),(535,'C','c93f3ad8c6b8437ab845966e87047389'),(536,'D','8741da9946ed44a68ed855f8382d2636'),(537,'B','3ec3f60955b748b8997cfc38ff39f2ff'),(538,'D','499734536a7d4480b8f559529f0bbf84'),(539,'D','0b6d0f7622c94306984880a7705e3f52'),(540,'A','95cd6ab3b6474300a8d1d538693a2f6d'),(541,'D','0979470ddbeb48b48cfa1e1bcf745dd8'),(542,'a','9989bc85a76d493d995b0ecca1fceed7'),(543,'b','36fb429d6a2640439157181b616a9ea7'),(544,'C','b274216832dc491894a7dde1e8efb55c'),(545,'B','93b80d394be34783b5680e434f4fac49'),(546,'B','3a37b9da03f14621b47008338bc71499'),(547,'c','62fa88ad8f174e589724bef4bbe9bbe4'),(548,'A','4145219dfc5a4401817b8d76d75f8375'),(549,'B','4145219dfc5a4401817b8d76d75f8375'),(550,'B','9c73cd4bd6a5494bab18e450b009a173'),(551,'D','9c73cd4bd6a5494bab18e450b009a173'),(552,'C','492965ba58284f66b9e060f26a86ae77'),(553,'C','863ecfd1ec414fcf99a4f0b630b6246a'),(554,'C','eed7ac52082c45698fb2a1faa9226c03'),(555,'c','0e4f199c7af84262a55896d26c16a82b'),(556,'c','bc12d383722541cdaebba3d3346c0d50'),(557,'A','3238392cfa5b4c7d937643e0f7f42bf7'),(558,'D','3238392cfa5b4c7d937643e0f7f42bf7'),(559,'C','2b81c8093fe54987a91b26fd4403e9e8'),(560,'D','2b81c8093fe54987a91b26fd4403e9e8'),(561,'B','28969610f88e44b6999619bf01f9e3b1'),(562,'D','86bb4f81334240a78457025ba9608e98'),(563,'D','a2fe8e7903b64e5f9d6ef268f9e2de8f'),(564,'B','9bcfddb168b54e75854cd978b0a70bda'),(565,'C','9bcfddb168b54e75854cd978b0a70bda'),(566,'D','9bcfddb168b54e75854cd978b0a70bda'),(567,'C','c64a03ee9ceb44349a03e8d236f047f0'),(568,'A','4f48062a0cce415d834aec73a3b8032a'),(569,'D','4f48062a0cce415d834aec73a3b8032a'),(570,'A','60232efc41d24e6b84c16e090c6d6084'),(571,'D','60232efc41d24e6b84c16e090c6d6084'),(572,'C','35809ebfca43434f9665f850c113cf89'),(573,'C','a27fb10053e749e993319b790609ceaf'),(574,'D','550b31d98e6f4c9797f18e880b8bd302'),(575,'B','8a7b8c9d1cc642e585302438d2d30493'),(576,'D','2782e588436842a5a8716f2a471d10c5'),(577,'D','3f5f216a67d64b18aae9896095d3b2c1'),(578,'A','77e73195b8784e1dad06be125fcf31fb'),(579,'D','07f2483d79f0423ebd67148b6017ae6e'),(580,'a','f97c0d5325ac4ef09a346f02edc3a103'),(581,'b','9357c6c525e94fa2a931dfc2710ffd1e'),(582,'C','341e7a5771274518b3dfc3adf2808e2f'),(583,'B','8e97bb261db94e30a0f6b6e0a0618fc6'),(584,'B','8f55f67b36b247598224fed4da7ec555'),(585,'c','98dbb42cad2844dbbeebf25cc5a832bf'),(586,'A','8311c749320742aeb43ec1bf98ec2a8b'),(587,'B','8311c749320742aeb43ec1bf98ec2a8b'),(588,'B','87de338fb2af462b892f5e05f3ffdf38'),(589,'D','87de338fb2af462b892f5e05f3ffdf38'),(590,'C','51ef8657b9ed434195789a21d09b8289'),(591,'C','8427a07b308141a39429a197a90c9feb'),(592,'C','37bb6ee2315a46b1959267772d30997b'),(593,'c','291ef4d1ff63464492b8a5e5ded212e0'),(594,'c','2040e52b11a044afa768f8611400f2f5'),(595,'A','54d4cda3c7ff4e709ffe37ae2a179585'),(596,'D','54d4cda3c7ff4e709ffe37ae2a179585'),(597,'C','4521998d5492452a937a663597e4e46e'),(598,'D','4521998d5492452a937a663597e4e46e'),(599,'B','56e4b65b31f5412a8aef245a2b659a4f'),(600,'D','ebecab2c5c6242da8864cae19ed65c9b'),(601,'D','ba7a7a03af724bd2aab7130cf1b6d98f'),(602,'B','dcce0330928c42b099dbcf44aa55d367'),(603,'C','dcce0330928c42b099dbcf44aa55d367'),(604,'D','dcce0330928c42b099dbcf44aa55d367'),(605,'C','b96fb1ebe7d04e5da20d20677e03a772'),(606,'A','9ee58f1d252b488c8d3503d3257e0489'),(607,'D','9ee58f1d252b488c8d3503d3257e0489'),(608,'A','589f85365953474c9dc4316d764006d1'),(609,'D','589f85365953474c9dc4316d764006d1'),(610,'C','8d216f38f0c44bf688d354beed1b6866'),(611,'C','5256a206377f489b9f8ec91ad00d81ff'),(612,'D','fc5d6334eb31432c9c9c3f2e30190430'),(613,'B','38266ab0c30643459203b9ec402a31f0'),(614,'A','88a68bc04d984a58a5a5fb715b10c91a'),(615,'D','8062be40f2bc44e3931f43e3f5d7e36a'),(616,'A','d8f70d3d49c34caba653791d65e03075'),(617,'C','d8f70d3d49c34caba653791d65e03075'),(618,'B','9038d6b293b141f294007c214d1d03ea'),(619,'C','bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(620,'A','e1d9217a179d4dc6a086bba7b1bad2d2'),(621,'C','b2c9595a4f9943ccac052842a490184d'),(622,'A','8777e01cda604b7f8761ae38dc4021e0'),(623,'D','f52079f7db5b4e67988d50a94de7f758'),(624,'D','447a4ff6e92e450bac70b311a7714c1f'),(625,'A','68ebb66d022649b6b02b8347f3c1328b'),(626,'A','a59cfa5cdfa141e1b31eae5d2dadca8d'),(627,'B','a59cfa5cdfa141e1b31eae5d2dadca8d'),(628,'A','5805162af038471a915a74292e25b76a'),(629,'子','ec79577e06f24aa382a13bbc9ac83f2d'),(630,'类','ec79577e06f24aa382a13bbc9ac83f2d'),(631,'一','ec79577e06f24aa382a13bbc9ac83f2d'),(632,'定','ec79577e06f24aa382a13bbc9ac83f2d'),(633,'比','ec79577e06f24aa382a13bbc9ac83f2d'),(634,'父','ec79577e06f24aa382a13bbc9ac83f2d'),(635,'类','ec79577e06f24aa382a13bbc9ac83f2d'),(636,'有','ec79577e06f24aa382a13bbc9ac83f2d'),(637,'更','ec79577e06f24aa382a13bbc9ac83f2d'),(638,'多','ec79577e06f24aa382a13bbc9ac83f2d'),(639,'的','ec79577e06f24aa382a13bbc9ac83f2d'),(640,'成','ec79577e06f24aa382a13bbc9ac83f2d'),(641,'员','ec79577e06f24aa382a13bbc9ac83f2d'),(642,'方','ec79577e06f24aa382a13bbc9ac83f2d'),(643,'法','ec79577e06f24aa382a13bbc9ac83f2d'),(644,'一','e0d56f51b8b842b1b04181553cb0cdcf'),(645,'个','e0d56f51b8b842b1b04181553cb0cdcf'),(646,'类','e0d56f51b8b842b1b04181553cb0cdcf'),(647,'可','e0d56f51b8b842b1b04181553cb0cdcf'),(648,'以','e0d56f51b8b842b1b04181553cb0cdcf'),(649,'定','e0d56f51b8b842b1b04181553cb0cdcf'),(650,'义','e0d56f51b8b842b1b04181553cb0cdcf'),(651,'多','e0d56f51b8b842b1b04181553cb0cdcf'),(652,'个','e0d56f51b8b842b1b04181553cb0cdcf'),(653,'构','e0d56f51b8b842b1b04181553cb0cdcf'),(654,'造','e0d56f51b8b842b1b04181553cb0cdcf'),(655,'函','e0d56f51b8b842b1b04181553cb0cdcf'),(656,'数','e0d56f51b8b842b1b04181553cb0cdcf'),(657,'程','bf3f7ba00d274129aea4b9aeb2300b34'),(658,'序','bf3f7ba00d274129aea4b9aeb2300b34'),(659,'数','bf3f7ba00d274129aea4b9aeb2300b34'),(660,'据','bf3f7ba00d274129aea4b9aeb2300b34'),(661,'直','bf3f7ba00d274129aea4b9aeb2300b34'),(662,'接','bf3f7ba00d274129aea4b9aeb2300b34'),(663,'保','bf3f7ba00d274129aea4b9aeb2300b34'),(664,'存','bf3f7ba00d274129aea4b9aeb2300b34'),(665,'成','bf3f7ba00d274129aea4b9aeb2300b34'),(666,'文','bf3f7ba00d274129aea4b9aeb2300b34'),(667,'本','bf3f7ba00d274129aea4b9aeb2300b34'),(668,'文','bf3f7ba00d274129aea4b9aeb2300b34'),(669,'件','bf3f7ba00d274129aea4b9aeb2300b34'),(670,'属','bf3f7ba00d274129aea4b9aeb2300b34'),(671,'于','bf3f7ba00d274129aea4b9aeb2300b34'),(672,'持','bf3f7ba00d274129aea4b9aeb2300b34'),(673,'久','bf3f7ba00d274129aea4b9aeb2300b34'),(674,'化','bf3f7ba00d274129aea4b9aeb2300b34'),(675,'D','6095a401ca8a404ca7f13e8e9725fb62'),(676,'A','6095a401ca8a404ca7f13e8e9725fb62'),(677,'O','6095a401ca8a404ca7f13e8e9725fb62'),(678,'S','76b96d4a859645088ea3117d14e10c8b'),(679,'t','76b96d4a859645088ea3117d14e10c8b'),(680,'r','76b96d4a859645088ea3117d14e10c8b'),(681,'i','76b96d4a859645088ea3117d14e10c8b'),(682,'n','76b96d4a859645088ea3117d14e10c8b'),(683,'g','76b96d4a859645088ea3117d14e10c8b'),(684,'[','76b96d4a859645088ea3117d14e10c8b'),(685,']','76b96d4a859645088ea3117d14e10c8b'),(686,' ','76b96d4a859645088ea3117d14e10c8b'),(687,'g','76b96d4a859645088ea3117d14e10c8b'),(688,'e','76b96d4a859645088ea3117d14e10c8b'),(689,'t','76b96d4a859645088ea3117d14e10c8b'),(690,'P','76b96d4a859645088ea3117d14e10c8b'),(691,'a','76b96d4a859645088ea3117d14e10c8b'),(692,'r','76b96d4a859645088ea3117d14e10c8b'),(693,'a','76b96d4a859645088ea3117d14e10c8b'),(694,'m','76b96d4a859645088ea3117d14e10c8b'),(695,'e','76b96d4a859645088ea3117d14e10c8b'),(696,'t','76b96d4a859645088ea3117d14e10c8b'),(697,'e','76b96d4a859645088ea3117d14e10c8b'),(698,'r','76b96d4a859645088ea3117d14e10c8b'),(699,'V','76b96d4a859645088ea3117d14e10c8b'),(700,'a','76b96d4a859645088ea3117d14e10c8b'),(701,'l','76b96d4a859645088ea3117d14e10c8b'),(702,'u','76b96d4a859645088ea3117d14e10c8b'),(703,'e','76b96d4a859645088ea3117d14e10c8b'),(704,'s','76b96d4a859645088ea3117d14e10c8b'),(705,'(','76b96d4a859645088ea3117d14e10c8b'),(706,'S','76b96d4a859645088ea3117d14e10c8b'),(707,'t','76b96d4a859645088ea3117d14e10c8b'),(708,'r','76b96d4a859645088ea3117d14e10c8b'),(709,'i','76b96d4a859645088ea3117d14e10c8b'),(710,'n','76b96d4a859645088ea3117d14e10c8b'),(711,'g','76b96d4a859645088ea3117d14e10c8b'),(712,' ','76b96d4a859645088ea3117d14e10c8b'),(713,'n','76b96d4a859645088ea3117d14e10c8b'),(714,'a','76b96d4a859645088ea3117d14e10c8b'),(715,'m','76b96d4a859645088ea3117d14e10c8b'),(716,'e','76b96d4a859645088ea3117d14e10c8b'),(717,')','76b96d4a859645088ea3117d14e10c8b'),(718,'a','227e55a3fc3342d9b04a3e7503290c75'),(719,'p','227e55a3fc3342d9b04a3e7503290c75'),(720,'p','227e55a3fc3342d9b04a3e7503290c75'),(721,'l','227e55a3fc3342d9b04a3e7503290c75'),(722,'i','227e55a3fc3342d9b04a3e7503290c75'),(723,'c','227e55a3fc3342d9b04a3e7503290c75'),(724,'a','227e55a3fc3342d9b04a3e7503290c75'),(725,'t','227e55a3fc3342d9b04a3e7503290c75'),(726,'i','227e55a3fc3342d9b04a3e7503290c75'),(727,'o','227e55a3fc3342d9b04a3e7503290c75'),(728,'n','227e55a3fc3342d9b04a3e7503290c75'),(729,'P','410c38fbce94425bb813bddee3c79daf'),(730,'r','410c38fbce94425bb813bddee3c79daf'),(731,'o','410c38fbce94425bb813bddee3c79daf'),(732,'x','410c38fbce94425bb813bddee3c79daf'),(733,'y','410c38fbce94425bb813bddee3c79daf'),(734,'<','1d07e5d16cd042ad926760f9b3211863'),(735,'s','1d07e5d16cd042ad926760f9b3211863'),(736,'e','1d07e5d16cd042ad926760f9b3211863'),(737,'r','1d07e5d16cd042ad926760f9b3211863'),(738,'v','1d07e5d16cd042ad926760f9b3211863'),(739,'l','1d07e5d16cd042ad926760f9b3211863'),(740,'e','1d07e5d16cd042ad926760f9b3211863'),(741,'t','1d07e5d16cd042ad926760f9b3211863'),(742,'-','1d07e5d16cd042ad926760f9b3211863'),(743,'m','1d07e5d16cd042ad926760f9b3211863'),(744,'a','1d07e5d16cd042ad926760f9b3211863'),(745,'p','1d07e5d16cd042ad926760f9b3211863'),(746,'p','1d07e5d16cd042ad926760f9b3211863'),(747,'i','1d07e5d16cd042ad926760f9b3211863'),(748,'n','1d07e5d16cd042ad926760f9b3211863'),(749,'g','1d07e5d16cd042ad926760f9b3211863'),(750,'>','1d07e5d16cd042ad926760f9b3211863'),(751,'J','3b130363445b4b32bb311b5f3c44d224'),(752,'a','3b130363445b4b32bb311b5f3c44d224'),(753,'v','3b130363445b4b32bb311b5f3c44d224'),(754,'a','3b130363445b4b32bb311b5f3c44d224'),(755,'B','3b130363445b4b32bb311b5f3c44d224'),(756,'e','3b130363445b4b32bb311b5f3c44d224'),(757,'a','3b130363445b4b32bb311b5f3c44d224'),(758,'n','3b130363445b4b32bb311b5f3c44d224'),(759,'S','126f3689546d4c8f9ecad6cf4baf0037'),(760,'e','126f3689546d4c8f9ecad6cf4baf0037'),(761,'r','126f3689546d4c8f9ecad6cf4baf0037'),(762,'v','126f3689546d4c8f9ecad6cf4baf0037'),(763,'l','126f3689546d4c8f9ecad6cf4baf0037'),(764,'e','126f3689546d4c8f9ecad6cf4baf0037'),(765,'t','126f3689546d4c8f9ecad6cf4baf0037'),(766,'t','126f3689546d4c8f9ecad6cf4baf0037'),(767,'C','126f3689546d4c8f9ecad6cf4baf0037'),(768,'o','126f3689546d4c8f9ecad6cf4baf0037'),(769,'n','126f3689546d4c8f9ecad6cf4baf0037'),(770,'t','126f3689546d4c8f9ecad6cf4baf0037'),(771,'e','126f3689546d4c8f9ecad6cf4baf0037'),(772,'x','126f3689546d4c8f9ecad6cf4baf0037'),(773,'t','126f3689546d4c8f9ecad6cf4baf0037'),(774,'、','126f3689546d4c8f9ecad6cf4baf0037'),(775,'g','126f3689546d4c8f9ecad6cf4baf0037'),(776,'e','126f3689546d4c8f9ecad6cf4baf0037'),(777,'t','126f3689546d4c8f9ecad6cf4baf0037'),(778,'P','126f3689546d4c8f9ecad6cf4baf0037'),(779,'a','126f3689546d4c8f9ecad6cf4baf0037'),(780,'t','126f3689546d4c8f9ecad6cf4baf0037'),(781,'h','126f3689546d4c8f9ecad6cf4baf0037'),(782,'I','126f3689546d4c8f9ecad6cf4baf0037'),(783,'n','126f3689546d4c8f9ecad6cf4baf0037'),(784,'f','126f3689546d4c8f9ecad6cf4baf0037'),(785,'o','126f3689546d4c8f9ecad6cf4baf0037'),(786,'(','126f3689546d4c8f9ecad6cf4baf0037'),(787,')','126f3689546d4c8f9ecad6cf4baf0037'),(788,'有','bc1040b6c26d4bc28a306a5d5e167b4f'),(789,'状','bc1040b6c26d4bc28a306a5d5e167b4f'),(790,'态','bc1040b6c26d4bc28a306a5d5e167b4f'),(791,'H','bc1040b6c26d4bc28a306a5d5e167b4f'),(792,'T','bc1040b6c26d4bc28a306a5d5e167b4f'),(793,'T','bc1040b6c26d4bc28a306a5d5e167b4f'),(794,'P','bc1040b6c26d4bc28a306a5d5e167b4f'),(795,'协','bc1040b6c26d4bc28a306a5d5e167b4f'),(796,'议','bc1040b6c26d4bc28a306a5d5e167b4f'),(797,'<','c2d82e059bef4634b439ae58349f01b3'),(798,'%','c2d82e059bef4634b439ae58349f01b3'),(799,'=','c2d82e059bef4634b439ae58349f01b3'),(800,'r','c2d82e059bef4634b439ae58349f01b3'),(801,'e','c2d82e059bef4634b439ae58349f01b3'),(802,'q','c2d82e059bef4634b439ae58349f01b3'),(803,'u','c2d82e059bef4634b439ae58349f01b3'),(804,'e','c2d82e059bef4634b439ae58349f01b3'),(805,'s','c2d82e059bef4634b439ae58349f01b3'),(806,'t','c2d82e059bef4634b439ae58349f01b3'),(807,'.','c2d82e059bef4634b439ae58349f01b3'),(808,'g','c2d82e059bef4634b439ae58349f01b3'),(809,'e','c2d82e059bef4634b439ae58349f01b3'),(810,'t','c2d82e059bef4634b439ae58349f01b3'),(811,'P','c2d82e059bef4634b439ae58349f01b3'),(812,'a','c2d82e059bef4634b439ae58349f01b3'),(813,'r','c2d82e059bef4634b439ae58349f01b3'),(814,'a','c2d82e059bef4634b439ae58349f01b3'),(815,'m','c2d82e059bef4634b439ae58349f01b3'),(816,'e','c2d82e059bef4634b439ae58349f01b3'),(817,'t','c2d82e059bef4634b439ae58349f01b3'),(818,'e','c2d82e059bef4634b439ae58349f01b3'),(819,'r','c2d82e059bef4634b439ae58349f01b3'),(820,'(','c2d82e059bef4634b439ae58349f01b3'),(821,'\"','c2d82e059bef4634b439ae58349f01b3'),(822,'l','c2d82e059bef4634b439ae58349f01b3'),(823,'o','c2d82e059bef4634b439ae58349f01b3'),(824,'c','c2d82e059bef4634b439ae58349f01b3'),(825,'a','c2d82e059bef4634b439ae58349f01b3'),(826,'t','c2d82e059bef4634b439ae58349f01b3'),(827,'i','c2d82e059bef4634b439ae58349f01b3'),(828,'o','c2d82e059bef4634b439ae58349f01b3'),(829,'n','c2d82e059bef4634b439ae58349f01b3'),(830,'\"','c2d82e059bef4634b439ae58349f01b3'),(831,')','c2d82e059bef4634b439ae58349f01b3'),(832,'%','c2d82e059bef4634b439ae58349f01b3'),(833,'>','c2d82e059bef4634b439ae58349f01b3'),(834,'S','a35a5aebdd354ae5ae0f75a6a77d4374'),(835,'M','a35a5aebdd354ae5ae0f75a6a77d4374'),(836,'T','a35a5aebdd354ae5ae0f75a6a77d4374'),(837,'P','a35a5aebdd354ae5ae0f75a6a77d4374'),(838,' ','a35a5aebdd354ae5ae0f75a6a77d4374'),(839,'P','a35a5aebdd354ae5ae0f75a6a77d4374'),(840,'O','a35a5aebdd354ae5ae0f75a6a77d4374'),(841,'P','a35a5aebdd354ae5ae0f75a6a77d4374'),(842,'3','a35a5aebdd354ae5ae0f75a6a77d4374'),(843,'不','717586535ae7442ead3dd17363782956'),(844,'会','717586535ae7442ead3dd17363782956'),(845,'输','717586535ae7442ead3dd17363782956'),(846,'出','717586535ae7442ead3dd17363782956'),(847,'，','717586535ae7442ead3dd17363782956'),(848,'因','717586535ae7442ead3dd17363782956'),(849,'为','717586535ae7442ead3dd17363782956'),(850,'表','717586535ae7442ead3dd17363782956'),(851,'达','717586535ae7442ead3dd17363782956'),(852,'式','717586535ae7442ead3dd17363782956'),(853,'是','717586535ae7442ead3dd17363782956'),(854,'错','717586535ae7442ead3dd17363782956'),(855,'误','717586535ae7442ead3dd17363782956'),(856,'的','717586535ae7442ead3dd17363782956'),(857,'s','b42e049c44b74cce9f8fa882a599cdb3'),(858,'e','b42e049c44b74cce9f8fa882a599cdb3'),(859,'t','b42e049c44b74cce9f8fa882a599cdb3'),(860,'P','b42e049c44b74cce9f8fa882a599cdb3'),(861,'r','b42e049c44b74cce9f8fa882a599cdb3'),(862,'o','b42e049c44b74cce9f8fa882a599cdb3'),(863,'p','b42e049c44b74cce9f8fa882a599cdb3'),(864,'e','b42e049c44b74cce9f8fa882a599cdb3'),(865,'r','b42e049c44b74cce9f8fa882a599cdb3'),(866,'t','b42e049c44b74cce9f8fa882a599cdb3'),(867,'y','b42e049c44b74cce9f8fa882a599cdb3'),(868,'E','0ded419a03a8402a8f0c7605c37ee303'),(869,'A','0ded419a03a8402a8f0c7605c37ee303'),(870,'R','0ded419a03a8402a8f0c7605c37ee303'),(871,'文','0ded419a03a8402a8f0c7605c37ee303'),(872,'件','0ded419a03a8402a8f0c7605c37ee303'),(873,'<','954ce958d8ea4e65ad75dd6c4c544aa8'),(874,'J','954ce958d8ea4e65ad75dd6c4c544aa8'),(875,'a','954ce958d8ea4e65ad75dd6c4c544aa8'),(876,'v','954ce958d8ea4e65ad75dd6c4c544aa8'),(877,'a','954ce958d8ea4e65ad75dd6c4c544aa8'),(878,'B','954ce958d8ea4e65ad75dd6c4c544aa8'),(879,'e','954ce958d8ea4e65ad75dd6c4c544aa8'),(880,'a','954ce958d8ea4e65ad75dd6c4c544aa8'),(881,'n','954ce958d8ea4e65ad75dd6c4c544aa8'),(882,':','954ce958d8ea4e65ad75dd6c4c544aa8'),(883,'g','954ce958d8ea4e65ad75dd6c4c544aa8'),(884,'e','954ce958d8ea4e65ad75dd6c4c544aa8'),(885,'t','954ce958d8ea4e65ad75dd6c4c544aa8'),(886,'P','954ce958d8ea4e65ad75dd6c4c544aa8'),(887,'r','954ce958d8ea4e65ad75dd6c4c544aa8'),(888,'o','954ce958d8ea4e65ad75dd6c4c544aa8'),(889,'p','954ce958d8ea4e65ad75dd6c4c544aa8'),(890,'e','954ce958d8ea4e65ad75dd6c4c544aa8'),(891,'r','954ce958d8ea4e65ad75dd6c4c544aa8'),(892,'t','954ce958d8ea4e65ad75dd6c4c544aa8'),(893,'y','954ce958d8ea4e65ad75dd6c4c544aa8'),(894,'>','954ce958d8ea4e65ad75dd6c4c544aa8'),(895,'W','8b414f97f37c4d5282693c7e4a410630'),(896,'E','8b414f97f37c4d5282693c7e4a410630'),(897,'B','8b414f97f37c4d5282693c7e4a410630'),(898,'-','8b414f97f37c4d5282693c7e4a410630'),(899,'I','8b414f97f37c4d5282693c7e4a410630'),(900,'N','8b414f97f37c4d5282693c7e4a410630'),(901,'F','8b414f97f37c4d5282693c7e4a410630'),(902,'\\','8b414f97f37c4d5282693c7e4a410630'),(903,'l','8b414f97f37c4d5282693c7e4a410630'),(904,'i','8b414f97f37c4d5282693c7e4a410630'),(905,'b','8b414f97f37c4d5282693c7e4a410630'),(906,'i','daaac5f7f17648ad9f72669c4cbc5067'),(907,'n','daaac5f7f17648ad9f72669c4cbc5067'),(908,'c','daaac5f7f17648ad9f72669c4cbc5067'),(909,'l','daaac5f7f17648ad9f72669c4cbc5067'),(910,'u','daaac5f7f17648ad9f72669c4cbc5067'),(911,'d','daaac5f7f17648ad9f72669c4cbc5067'),(912,'e','daaac5f7f17648ad9f72669c4cbc5067'),(913,'d','daaac5f7f17648ad9f72669c4cbc5067'),(914,'i','daaac5f7f17648ad9f72669c4cbc5067'),(915,'s','daaac5f7f17648ad9f72669c4cbc5067'),(916,'p','daaac5f7f17648ad9f72669c4cbc5067'),(917,'a','daaac5f7f17648ad9f72669c4cbc5067'),(918,'t','daaac5f7f17648ad9f72669c4cbc5067'),(919,'c','daaac5f7f17648ad9f72669c4cbc5067'),(920,'h','daaac5f7f17648ad9f72669c4cbc5067'),(921,'e','daaac5f7f17648ad9f72669c4cbc5067'),(922,'r','daaac5f7f17648ad9f72669c4cbc5067'),(923,'R','43da938ab13542e196dbccc649c80bd1'),(924,'e','43da938ab13542e196dbccc649c80bd1'),(925,'p','43da938ab13542e196dbccc649c80bd1'),(926,'o','43da938ab13542e196dbccc649c80bd1'),(927,'n','43da938ab13542e196dbccc649c80bd1'),(928,'s','43da938ab13542e196dbccc649c80bd1'),(929,'e','43da938ab13542e196dbccc649c80bd1'),(930,'.','43da938ab13542e196dbccc649c80bd1'),(931,'g','43da938ab13542e196dbccc649c80bd1'),(932,'e','43da938ab13542e196dbccc649c80bd1'),(933,'t','43da938ab13542e196dbccc649c80bd1'),(934,'A','43da938ab13542e196dbccc649c80bd1'),(935,'t','43da938ab13542e196dbccc649c80bd1'),(936,'t','43da938ab13542e196dbccc649c80bd1'),(937,'r','43da938ab13542e196dbccc649c80bd1'),(938,'i','43da938ab13542e196dbccc649c80bd1'),(939,'b','43da938ab13542e196dbccc649c80bd1'),(940,'u','43da938ab13542e196dbccc649c80bd1'),(941,'t','43da938ab13542e196dbccc649c80bd1'),(942,'e','43da938ab13542e196dbccc649c80bd1'),(943,'(','43da938ab13542e196dbccc649c80bd1'),(944,'“','43da938ab13542e196dbccc649c80bd1'),(945,'I','43da938ab13542e196dbccc649c80bd1'),(946,'D','43da938ab13542e196dbccc649c80bd1'),(947,'”','43da938ab13542e196dbccc649c80bd1'),(948,')','43da938ab13542e196dbccc649c80bd1'),(949,'M','678c081b2dac4f24bfe4d5168d0fd051'),(950,'I','678c081b2dac4f24bfe4d5168d0fd051'),(951,'M','678c081b2dac4f24bfe4d5168d0fd051'),(952,'E','678c081b2dac4f24bfe4d5168d0fd051'),(953,'w','68cab8ab20f441c1ab0dfe9965fe29a0'),(954,'a','68cab8ab20f441c1ab0dfe9965fe29a0'),(955,'i','68cab8ab20f441c1ab0dfe9965fe29a0'),(956,'t','68cab8ab20f441c1ab0dfe9965fe29a0'),(957,'后','68cab8ab20f441c1ab0dfe9965fe29a0'),(958,'进','68cab8ab20f441c1ab0dfe9965fe29a0'),(959,'入','68cab8ab20f441c1ab0dfe9965fe29a0'),(960,'等','68cab8ab20f441c1ab0dfe9965fe29a0'),(961,'待','68cab8ab20f441c1ab0dfe9965fe29a0'),(962,'锁','68cab8ab20f441c1ab0dfe9965fe29a0'),(963,'定','68cab8ab20f441c1ab0dfe9965fe29a0'),(964,'池','68cab8ab20f441c1ab0dfe9965fe29a0'),(965,'，','68cab8ab20f441c1ab0dfe9965fe29a0'),(966,'只','68cab8ab20f441c1ab0dfe9965fe29a0'),(967,'有','68cab8ab20f441c1ab0dfe9965fe29a0'),(968,'针','68cab8ab20f441c1ab0dfe9965fe29a0'),(969,'对','68cab8ab20f441c1ab0dfe9965fe29a0'),(970,'此','68cab8ab20f441c1ab0dfe9965fe29a0'),(971,'对','68cab8ab20f441c1ab0dfe9965fe29a0'),(972,'象','68cab8ab20f441c1ab0dfe9965fe29a0'),(973,'发','68cab8ab20f441c1ab0dfe9965fe29a0'),(974,'出','68cab8ab20f441c1ab0dfe9965fe29a0'),(975,'n','68cab8ab20f441c1ab0dfe9965fe29a0'),(976,'o','68cab8ab20f441c1ab0dfe9965fe29a0'),(977,'t','68cab8ab20f441c1ab0dfe9965fe29a0'),(978,'i','68cab8ab20f441c1ab0dfe9965fe29a0'),(979,'f','68cab8ab20f441c1ab0dfe9965fe29a0'),(980,'y','68cab8ab20f441c1ab0dfe9965fe29a0'),(981,'方','68cab8ab20f441c1ab0dfe9965fe29a0'),(982,'法','68cab8ab20f441c1ab0dfe9965fe29a0'),(983,'后','68cab8ab20f441c1ab0dfe9965fe29a0'),(984,'获','68cab8ab20f441c1ab0dfe9965fe29a0'),(985,'得','68cab8ab20f441c1ab0dfe9965fe29a0'),(986,'对','68cab8ab20f441c1ab0dfe9965fe29a0'),(987,'象','68cab8ab20f441c1ab0dfe9965fe29a0'),(988,'锁','68cab8ab20f441c1ab0dfe9965fe29a0'),(989,'进','68cab8ab20f441c1ab0dfe9965fe29a0'),(990,'入','68cab8ab20f441c1ab0dfe9965fe29a0'),(991,'运','68cab8ab20f441c1ab0dfe9965fe29a0'),(992,'行','68cab8ab20f441c1ab0dfe9965fe29a0'),(993,'状','68cab8ab20f441c1ab0dfe9965fe29a0'),(994,'态','68cab8ab20f441c1ab0dfe9965fe29a0'),(995,'。','68cab8ab20f441c1ab0dfe9965fe29a0'),(996,'$','e8e6b37a495040c7a42b5044e1977611'),(997,'{','e8e6b37a495040c7a42b5044e1977611'),(998,'b','e8e6b37a495040c7a42b5044e1977611'),(999,'e','e8e6b37a495040c7a42b5044e1977611'),(1000,'a','e8e6b37a495040c7a42b5044e1977611'),(1001,'n','e8e6b37a495040c7a42b5044e1977611'),(1002,'.','e8e6b37a495040c7a42b5044e1977611'),(1003,'m','e8e6b37a495040c7a42b5044e1977611'),(1004,'e','e8e6b37a495040c7a42b5044e1977611'),(1005,'s','e8e6b37a495040c7a42b5044e1977611'),(1006,'s','e8e6b37a495040c7a42b5044e1977611'),(1007,'a','e8e6b37a495040c7a42b5044e1977611'),(1008,'g','e8e6b37a495040c7a42b5044e1977611'),(1009,'e','e8e6b37a495040c7a42b5044e1977611'),(1010,'}','e8e6b37a495040c7a42b5044e1977611'),(1011,'编','5fff04f70d774f5d8755b1d89504ae54'),(1012,'译','5fff04f70d774f5d8755b1d89504ae54'),(1013,'器','5fff04f70d774f5d8755b1d89504ae54'),(1014,'一','639921545d28411db6b172befeaf2a18'),(1015,'个','639921545d28411db6b172befeaf2a18'),(1016,'线','639921545d28411db6b172befeaf2a18'),(1017,'程','639921545d28411db6b172befeaf2a18'),(1018,'可','639921545d28411db6b172befeaf2a18'),(1019,'能','639921545d28411db6b172befeaf2a18'),(1020,'因','639921545d28411db6b172befeaf2a18'),(1021,'为','639921545d28411db6b172befeaf2a18'),(1022,'不','639921545d28411db6b172befeaf2a18'),(1023,'同','639921545d28411db6b172befeaf2a18'),(1024,'的','639921545d28411db6b172befeaf2a18'),(1025,'原','639921545d28411db6b172befeaf2a18'),(1026,'因','639921545d28411db6b172befeaf2a18'),(1027,'停','639921545d28411db6b172befeaf2a18'),(1028,'止','639921545d28411db6b172befeaf2a18'),(1029,'并','639921545d28411db6b172befeaf2a18'),(1030,'进','639921545d28411db6b172befeaf2a18'),(1031,'入','639921545d28411db6b172befeaf2a18'),(1032,'就','639921545d28411db6b172befeaf2a18'),(1033,'绪','639921545d28411db6b172befeaf2a18'),(1034,'状','639921545d28411db6b172befeaf2a18'),(1035,'态','639921545d28411db6b172befeaf2a18'),(1036,'I','f3bbcfaa45534a819b48de3c52d76888'),(1037,'/','f3bbcfaa45534a819b48de3c52d76888'),(1038,'O','f3bbcfaa45534a819b48de3c52d76888'),(1039,'用','f3bbcfaa45534a819b48de3c52d76888'),(1040,'于','f3bbcfaa45534a819b48de3c52d76888'),(1041,'多','f3bbcfaa45534a819b48de3c52d76888'),(1042,'线','f3bbcfaa45534a819b48de3c52d76888'),(1043,'程','f3bbcfaa45534a819b48de3c52d76888'),(1044,'G','7403c2f1dee74140b600fbe410e02490'),(1045,'C','7403c2f1dee74140b600fbe410e02490'),(1046,'是','7403c2f1dee74140b600fbe410e02490'),(1047,'垃','7403c2f1dee74140b600fbe410e02490'),(1048,'圾','7403c2f1dee74140b600fbe410e02490'),(1049,'收','7403c2f1dee74140b600fbe410e02490'),(1050,'集','7403c2f1dee74140b600fbe410e02490'),(1051,'器','7403c2f1dee74140b600fbe410e02490'),(1052,'，','7403c2f1dee74140b600fbe410e02490'),(1053,'程','7403c2f1dee74140b600fbe410e02490'),(1054,'序','7403c2f1dee74140b600fbe410e02490'),(1055,'员','7403c2f1dee74140b600fbe410e02490'),(1056,'不','7403c2f1dee74140b600fbe410e02490'),(1057,'用','7403c2f1dee74140b600fbe410e02490'),(1058,'担','7403c2f1dee74140b600fbe410e02490'),(1059,'心','7403c2f1dee74140b600fbe410e02490'),(1060,'内','7403c2f1dee74140b600fbe410e02490'),(1061,'存','7403c2f1dee74140b600fbe410e02490'),(1062,'管','7403c2f1dee74140b600fbe410e02490'),(1063,'理','7403c2f1dee74140b600fbe410e02490'),(1064,'一','64905cc258104eb7a2cc02998326f140'),(1065,'个','64905cc258104eb7a2cc02998326f140'),(1066,'线','64905cc258104eb7a2cc02998326f140'),(1067,'程','64905cc258104eb7a2cc02998326f140'),(1068,'可','64905cc258104eb7a2cc02998326f140'),(1069,'以','64905cc258104eb7a2cc02998326f140'),(1070,'包','64905cc258104eb7a2cc02998326f140'),(1071,'含','64905cc258104eb7a2cc02998326f140'),(1072,'多','64905cc258104eb7a2cc02998326f140'),(1073,'个','64905cc258104eb7a2cc02998326f140'),(1074,'进','64905cc258104eb7a2cc02998326f140'),(1075,'程','64905cc258104eb7a2cc02998326f140'),(1076,'L','bbfc083585d140d787f0444ada09b5a2'),(1077,'i','bbfc083585d140d787f0444ada09b5a2'),(1078,'s','bbfc083585d140d787f0444ada09b5a2'),(1079,'t','bbfc083585d140d787f0444ada09b5a2'),(1080,' ','bbfc083585d140d787f0444ada09b5a2'),(1081,'m','bbfc083585d140d787f0444ada09b5a2'),(1082,'y','bbfc083585d140d787f0444ada09b5a2'),(1083,'L','bbfc083585d140d787f0444ada09b5a2'),(1084,'i','bbfc083585d140d787f0444ada09b5a2'),(1085,'s','bbfc083585d140d787f0444ada09b5a2'),(1086,'t','bbfc083585d140d787f0444ada09b5a2'),(1087,' ','bbfc083585d140d787f0444ada09b5a2'),(1088,'=','bbfc083585d140d787f0444ada09b5a2'),(1089,' ','bbfc083585d140d787f0444ada09b5a2'),(1090,'n','bbfc083585d140d787f0444ada09b5a2'),(1091,'e','bbfc083585d140d787f0444ada09b5a2'),(1092,'w','bbfc083585d140d787f0444ada09b5a2'),(1093,' ','bbfc083585d140d787f0444ada09b5a2'),(1094,'L','bbfc083585d140d787f0444ada09b5a2'),(1095,'i','bbfc083585d140d787f0444ada09b5a2'),(1096,'s','bbfc083585d140d787f0444ada09b5a2'),(1097,'t','bbfc083585d140d787f0444ada09b5a2'),(1098,'(','bbfc083585d140d787f0444ada09b5a2'),(1099,')','bbfc083585d140d787f0444ada09b5a2'),(1100,';','bbfc083585d140d787f0444ada09b5a2'),(1101,'一','3e8b79b07a614aba80e248bf3fd97a84'),(1102,'个','3e8b79b07a614aba80e248bf3fd97a84'),(1103,'线','3e8b79b07a614aba80e248bf3fd97a84'),(1104,'程','3e8b79b07a614aba80e248bf3fd97a84'),(1105,'可','3e8b79b07a614aba80e248bf3fd97a84'),(1106,'以','3e8b79b07a614aba80e248bf3fd97a84'),(1107,'包','3e8b79b07a614aba80e248bf3fd97a84'),(1108,'含','3e8b79b07a614aba80e248bf3fd97a84'),(1109,'多','3e8b79b07a614aba80e248bf3fd97a84'),(1110,'个','3e8b79b07a614aba80e248bf3fd97a84'),(1111,'进','3e8b79b07a614aba80e248bf3fd97a84'),(1112,'程','3e8b79b07a614aba80e248bf3fd97a84'),(1113,'f','46fc9416a72d4d6e96a8f12232cd6c1f'),(1114,'t','46fc9416a72d4d6e96a8f12232cd6c1f'),(1115,'p','46fc9416a72d4d6e96a8f12232cd6c1f'),(1116,'J','6693a04918124b32b0b86d1577609e12'),(1117,'a','6693a04918124b32b0b86d1577609e12'),(1118,'v','6693a04918124b32b0b86d1577609e12'),(1119,'a','6693a04918124b32b0b86d1577609e12'),(1120,'网','6693a04918124b32b0b86d1577609e12'),(1121,'络','6693a04918124b32b0b86d1577609e12'),(1122,'接','6693a04918124b32b0b86d1577609e12'),(1123,'口','6693a04918124b32b0b86d1577609e12'),(1124,'支','6693a04918124b32b0b86d1577609e12'),(1125,'持','6693a04918124b32b0b86d1577609e12'),(1126,'I','6693a04918124b32b0b86d1577609e12'),(1127,'P','6693a04918124b32b0b86d1577609e12'),(1128,'以','6693a04918124b32b0b86d1577609e12'),(1129,'上','6693a04918124b32b0b86d1577609e12'),(1130,'的','6693a04918124b32b0b86d1577609e12'),(1131,'所','6693a04918124b32b0b86d1577609e12'),(1132,'有','6693a04918124b32b0b86d1577609e12'),(1133,'高','6693a04918124b32b0b86d1577609e12'),(1134,'层','6693a04918124b32b0b86d1577609e12'),(1135,'协','6693a04918124b32b0b86d1577609e12'),(1136,'议','6693a04918124b32b0b86d1577609e12'),(1137,'W','1d49e67b65fb4facabc924ba268558fe'),(1138,'e','1d49e67b65fb4facabc924ba268558fe'),(1139,'b','1d49e67b65fb4facabc924ba268558fe'),(1140,'S','1d49e67b65fb4facabc924ba268558fe'),(1141,'e','1d49e67b65fb4facabc924ba268558fe'),(1142,'r','1d49e67b65fb4facabc924ba268558fe'),(1143,'v','1d49e67b65fb4facabc924ba268558fe'),(1144,'i','1d49e67b65fb4facabc924ba268558fe'),(1145,'c','1d49e67b65fb4facabc924ba268558fe'),(1146,'e','1d49e67b65fb4facabc924ba268558fe'),(1147,'通','b33fd17060c84e7d9ff78f62370a3f94'),(1148,'过','b33fd17060c84e7d9ff78f62370a3f94'),(1149,'C','b33fd17060c84e7d9ff78f62370a3f94'),(1150,'o','b33fd17060c84e7d9ff78f62370a3f94'),(1151,'n','b33fd17060c84e7d9ff78f62370a3f94'),(1152,'n','b33fd17060c84e7d9ff78f62370a3f94'),(1153,'e','b33fd17060c84e7d9ff78f62370a3f94'),(1154,'c','b33fd17060c84e7d9ff78f62370a3f94'),(1155,'t','b33fd17060c84e7d9ff78f62370a3f94'),(1156,'i','b33fd17060c84e7d9ff78f62370a3f94'),(1157,'o','b33fd17060c84e7d9ff78f62370a3f94'),(1158,'n','b33fd17060c84e7d9ff78f62370a3f94'),(1159,'对','b33fd17060c84e7d9ff78f62370a3f94'),(1160,'象','b33fd17060c84e7d9ff78f62370a3f94'),(1161,'每','5c593c484e4a485d97190f5aa23226da'),(1162,'当','5c593c484e4a485d97190f5aa23226da'),(1163,'用','5c593c484e4a485d97190f5aa23226da'),(1164,'户','5c593c484e4a485d97190f5aa23226da'),(1165,'端','5c593c484e4a485d97190f5aa23226da'),(1166,'运','5c593c484e4a485d97190f5aa23226da'),(1167,'行','5c593c484e4a485d97190f5aa23226da'),(1168,'J','5c593c484e4a485d97190f5aa23226da'),(1169,'S','5c593c484e4a485d97190f5aa23226da'),(1170,'P','5c593c484e4a485d97190f5aa23226da'),(1171,'时','5c593c484e4a485d97190f5aa23226da'),(1172,'，','5c593c484e4a485d97190f5aa23226da'),(1173,'j','5c593c484e4a485d97190f5aa23226da'),(1174,'s','5c593c484e4a485d97190f5aa23226da'),(1175,'p','5c593c484e4a485d97190f5aa23226da'),(1176,'D','5c593c484e4a485d97190f5aa23226da'),(1177,'e','5c593c484e4a485d97190f5aa23226da'),(1178,'s','5c593c484e4a485d97190f5aa23226da'),(1179,'t','5c593c484e4a485d97190f5aa23226da'),(1180,'r','5c593c484e4a485d97190f5aa23226da'),(1181,'o','5c593c484e4a485d97190f5aa23226da'),(1182,'y','5c593c484e4a485d97190f5aa23226da'),(1183,'(','5c593c484e4a485d97190f5aa23226da'),(1184,')','5c593c484e4a485d97190f5aa23226da'),(1185,'方','5c593c484e4a485d97190f5aa23226da'),(1186,'法','5c593c484e4a485d97190f5aa23226da'),(1187,'都','5c593c484e4a485d97190f5aa23226da'),(1188,'会','5c593c484e4a485d97190f5aa23226da'),(1189,'运','5c593c484e4a485d97190f5aa23226da'),(1190,'行','5c593c484e4a485d97190f5aa23226da'),(1191,'一','5c593c484e4a485d97190f5aa23226da'),(1192,'次','5c593c484e4a485d97190f5aa23226da'),(1193,'C','b94ddff9193c41fdb504b848f9ae3d03'),(1194,'o','b94ddff9193c41fdb504b848f9ae3d03'),(1195,'n','b94ddff9193c41fdb504b848f9ae3d03'),(1196,'t','b94ddff9193c41fdb504b848f9ae3d03'),(1197,'r','b94ddff9193c41fdb504b848f9ae3d03'),(1198,'o','b94ddff9193c41fdb504b848f9ae3d03'),(1199,'l','b94ddff9193c41fdb504b848f9ae3d03'),(1200,'l','b94ddff9193c41fdb504b848f9ae3d03'),(1201,'e','b94ddff9193c41fdb504b848f9ae3d03'),(1202,'r','b94ddff9193c41fdb504b848f9ae3d03'),(1203,'<','5fe50b7ca40c413cabe90e6a561b302f'),(1204,'c','5fe50b7ca40c413cabe90e6a561b302f'),(1205,':','5fe50b7ca40c413cabe90e6a561b302f'),(1206,'c','5fe50b7ca40c413cabe90e6a561b302f'),(1207,'a','5fe50b7ca40c413cabe90e6a561b302f'),(1208,'t','5fe50b7ca40c413cabe90e6a561b302f'),(1209,'c','5fe50b7ca40c413cabe90e6a561b302f'),(1210,'h','5fe50b7ca40c413cabe90e6a561b302f'),(1211,'>','5fe50b7ca40c413cabe90e6a561b302f'),(1362,'A','909bd14bd65047e5a3d14e8a70139159'),(1363,'D','5aa4c70609e24c48850d4d6339e84b4c'),(1364,'A','131ed917d9c44513a5633f28d449d5b3'),(1365,'C','131ed917d9c44513a5633f28d449d5b3'),(1366,'B','116369da665b44ceb3246d2d7682042e'),(1367,'C','6a9374cf008f46b39329436c6a1b3208'),(1368,'A','d62a9d5432384283a2719df8879bbc1c'),(1369,'C','4cb48c7571894b4f9ec55d9f53d4836a'),(1370,'A','40bb8040eeea498eadefb4d3affd3efa'),(1371,'D','93578c12c0ff47e7a888b945caf96b41'),(1372,'D','4516a7c4ddbe4b158962cd225f862a2b'),(1373,'A','9951bbeb408a44a993400d4e7a17c79d'),(1374,'A','014cd684159c40f1bf385c7e411c5eb8'),(1375,'B','014cd684159c40f1bf385c7e411c5eb8'),(1376,'A','1bed7e77feed463aa313e4e3956a2a43'),(1377,'B','9426e04fa6c64a1593c2a4fe05597661'),(1378,'B','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1379,'C','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1380,'D','683943e1e3d34651a83cfa4549b2799a'),(1381,'A','82d63683b9b64b6c9bd79e7d6275295e'),(1382,'D','d8d6ce051cc74adda9daf2eb148b6054'),(1383,'A','dbf0d85317f241d48b6a8d91dc3f5763'),(1384,'C','97a43b8cba1d4e5cbf14123c615dba8a'),(1385,'B','d21ce5ab62bc4b3786c3903abc51add2'),(1386,'D','ee1dc62698ba4f3a83898f94b4b9d472'),(1387,'A','02076d1058dd4a15aa132ab8a3846e04'),(1388,'D','6b2301dde567463dbbd53680b363bbee'),(1389,'D','59bc97a58cdd46c3bc79261dc282c62f'),(1390,'D','f9446cfe21c44e199102c9be7a13f508'),(1391,'B','a77a9c5766a2404ebc1f14055751afab'),(1392,'A','9f594676ea16490584ab04c73fb44515'),(1393,'a','89578b4126ac417ca21a49a850406909'),(1394,'A','782e6f039ebf402fbda0363779394ec7'),(1395,'A','a79f9c7cba2a4c379c648c34516ceadd'),(1396,'A','0dddbefe024a41fabe0b3491f204eb2e'),(1397,'A','490e2106952f4c11ad7d51f433fca974'),(1398,'A','e21adbf54f9948c69da67bd6ff941719'),(1399,'D','4e41562006754a8fb1c50f7dee810c5b'),(1400,'B','628c38191f45499086980b02cb06c762'),(1401,'D','628c38191f45499086980b02cb06c762'),(1402,'B','8fedf8b65c954e23b173fcbcd522e916'),(1403,'B','7b00635c1e7d4e8f87caf2d376f57b65'),(1404,'C','7b00635c1e7d4e8f87caf2d376f57b65'),(1405,'D','7b00635c1e7d4e8f87caf2d376f57b65'),(1406,'A','c56482ede37c460ca5570e033772b0dd'),(1407,'A','564e350d1c2843ba8365b064f56c0439'),(1408,'D','564e350d1c2843ba8365b064f56c0439'),(1409,'C','32adc9ce3c7b4e3fa9f23a5b90410461'),(1410,'B','9020367beede44f5b93059a75713b034'),(1411,'C','fc69113129a44b4badeb408c7948c8ef'),(1412,'A','0882ec97c005432c874f57ba0e5c94ab'),(1413,'A','f60dcc77fb0649df9a16199fbede9b44'),(1414,'D','f60dcc77fb0649df9a16199fbede9b44'),(1415,'A','2cbd536c7819476495d6cae2301d9643'),(1416,'C','2cbd536c7819476495d6cae2301d9643'),(1417,'D','2cbd536c7819476495d6cae2301d9643'),(1418,'C','b3a378983d5e46de95c31633796f663b'),(1419,'A','68bbfca9f9d64b829fa471abd380890d'),(1420,'C','68bbfca9f9d64b829fa471abd380890d'),(1421,'C','55be2305662e46c199f9c9db6c175d9d'),(1422,'A','5dffbb7f55a84d458fe5326ccacdaa47'),(1423,'A','0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(1424,'D','ac74959aa3ff42789ec08555b95fdfe6'),(1425,'A','244f8104ff5847149a1918536377eca5'),(1426,'C','244f8104ff5847149a1918536377eca5'),(1427,'B','c1a4862c6bc4432185938cb15a0f6764'),(1428,'C','f4881d2c800847cea2fc07891268c1fb'),(1429,'A','8c289ea1bd714615a8a57b62efd56092'),(1430,'C','9bd8a2fbcead454496452e117b70974f'),(1431,'A','2a7a435aabd9473db634967686dd8597'),(1432,'D','462703eb5bd6419e8eabd19880f1bb53'),(1433,'D','16e156d20b7f48b9ae92c9db129233b5'),(1434,'A','6f66eba1cfa1454d94eceb320415fe1b'),(1435,'A','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1436,'B','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1437,'A','a65b42bbe6c2437eb40e9bc192d3c381'),(1438,'B','2896d8c737bc4f27824fb85bac44c56f'),(1439,'B','588fba50948e4005ac646356b762b9bd'),(1440,'C','588fba50948e4005ac646356b762b9bd'),(1441,'D','afb5261a51ca40f28be67902e29ebe7c'),(1442,'A','55e829ff5bc242868333f9588a7ec9d6'),(1443,'D','297d0479c7df487983358b78835c6797'),(1444,'A','1cbdc697f0504174aa93f5fa5bb1bdba'),(1445,'C','1dedd6878b164e219a58b070cc7f55f2'),(1446,'B','1fb52e896c61430ab7089d2ad9a8e11f'),(1447,'D','cdca664b0d22406db81a680ba2992e07'),(1448,'A','72329b2187b34b27b5cd701c02497955'),(1449,'D','ee37b7456f2c4aa780f5880fac338897'),(1450,'D','5366dc69b6c142c4aed60b7bfd6ec97c'),(1451,'D','ccb000367ed84bfea3e18f03d7028efe'),(1452,'B','3340719421a340178837663bc78a07d5'),(1453,'A','3bc8b36559b94a04a0bb937bffa2c432'),(1454,'a','85521921aaab4533b527c3ef044ce2e1'),(1455,'A','fbcbb40f929346f48798f7bc5a29c077'),(1456,'A','c30638dd08b34c06ab3d2d086a35faab'),(1457,'A','fefd7221d3bf434f8bd238390deed930'),(1458,'A','48517b3b986340ebadcb531175b68b0d'),(1459,'A','fab7bcf5532343f289b335d6d3fb6eaf'),(1460,'D','74b9e2aabc7340888e4bebb5b776476b'),(1461,'B','594f1dcedc2a45fea97e0ea56e91a1a1'),(1462,'D','594f1dcedc2a45fea97e0ea56e91a1a1'),(1463,'B','a91784f07138422ea28da88e5bdbcde3'),(1464,'B','39e32b60ee064dac8174c2871a07a937'),(1465,'C','39e32b60ee064dac8174c2871a07a937'),(1466,'D','39e32b60ee064dac8174c2871a07a937'),(1467,'A','3be4e1eec011407bbce0afee6505ffca'),(1468,'A','15f25c4647ed49879f53cd753f74dd78'),(1469,'D','15f25c4647ed49879f53cd753f74dd78'),(1470,'C','94aa5b5a5e304433a461e349efd38dd8'),(1471,'B','68014607c39742e49222a276d8b8de8d'),(1472,'C','b4deefe615974c4d858b73c36574c41e'),(1473,'A','b171105de04242d8898be0410dfe86dc'),(1474,'A','0107de32f873494fa383e9a1abddad48'),(1475,'D','0107de32f873494fa383e9a1abddad48'),(1476,'A','638e5d58924f467f9390a7e0cd67f1a6'),(1477,'C','638e5d58924f467f9390a7e0cd67f1a6'),(1478,'D','638e5d58924f467f9390a7e0cd67f1a6'),(1479,'C','9881b5ca9f664c3bb45f1d6f22ff5234'),(1480,'A','d9ecd0c469374f22a61b3a997b4737ba'),(1481,'C','d9ecd0c469374f22a61b3a997b4737ba'),(1482,'C','6f32eb7647e14653ac9b6ee42c6afc75'),(1483,'A','49c470f72aaa4be2a29c7d12143d92a5'),(1484,'A','7c89001a5fbb4d04b43a0bddcc190c80'),(1485,'D','e38bde24d58149c5a9e67fa92ce81ac5'),(1486,'A','3e544ea2716043b6a9acf1f1ac37a400'),(1487,'C','3e544ea2716043b6a9acf1f1ac37a400'),(1488,'B','f30c6491f80d40248c3821d9f7f7fb53'),(1489,'C','1918e2beb8cf4a488b399edd32d448e9'),(1490,'A','8680f59744ba43888754448c66244725'),(1491,'C','da77e5dbc4db455eb53aef765b50e9b0'),(1492,'A','a16d4a100c184469925ba2f098ccfb00'),(1493,'D','23a7da6daa904a91830751b1ca959756'),(1494,'D','b8f301502d164cfe95b05ecc73c79f05'),(1495,'A','03147897644546c9a9013ba8a147fa6d'),(1496,'A','f28f1de3b0844e13a0339bb8c9dd9c21'),(1497,'B','f28f1de3b0844e13a0339bb8c9dd9c21'),(1498,'A','0bec17b5cdf24b9fa4f3d2589805d1a9'),(1499,'B','a6690bb3880e41558793cefcd4716e4f'),(1500,'B','46cb8790d15541388561e5a973369732'),(1501,'C','46cb8790d15541388561e5a973369732'),(1502,'D','9931855ba5654b229d0823ad9ab8a5da'),(1503,'A','cecc2419ee64492592296b98fa88784a'),(1504,'D','97b4113429124586817a723573f559b8'),(1505,'A','93d48f2c919543ceb58c404f9bb5868d'),(1506,'C','dcb5310dacc147ec8502d1638f4b4d54'),(1507,'B','dfbbcccbd989440cb266c90f99ab6870'),(1508,'D','350e9a62ce3b46138cf0079d4b879410'),(1509,'A','37bdadaa708c4406802ef093a48b1c05'),(1510,'D','c4abbe5d6be8402b8dab1852218a8096'),(1511,'D','003da51b8a8a4e2baa66fc56083c55e1'),(1512,'D','dc9c9b3815014439a5918f6abf99a57c'),(1513,'B','0027848a71ef4fd6b32e26231d57fad8'),(1514,'A','17a4e16983bd4b56bbd5a1f2a9136bfb'),(1515,'a','2400bc5f55dc4de4bf4010b096a363b7'),(1516,'A','692fa2e4a02240d4ae67db4b43738846'),(1517,'A','08b43969104a49748831686fe64ca7f5'),(1518,'A','a0740e1949324df8967947674f78a8ad'),(1519,'A','4fca9d0f4e4c4cf0bf42759d5bae04f9'),(1520,'A','aa1cfc50092d417abe01f2f721ef7e18'),(1521,'D','e6ca12ed6b73477c8acacde5b107aa3d'),(1522,'B','ac3fb13976ff4aceb878cf7bf34bea9a'),(1523,'D','ac3fb13976ff4aceb878cf7bf34bea9a'),(1524,'B','a8153429f5ff44d2913150981e776622'),(1525,'B','d6a48ad41ca84fc4815d11e72356c5ff'),(1526,'C','d6a48ad41ca84fc4815d11e72356c5ff'),(1527,'D','d6a48ad41ca84fc4815d11e72356c5ff'),(1528,'A','2d7e4b98be4447198cb6f7080b602579'),(1529,'A','18794fa8e8284c849c02f627d9b0a0c4'),(1530,'D','18794fa8e8284c849c02f627d9b0a0c4'),(1531,'C','cac67d440e664fccbbe459011c0745a4'),(1532,'B','6acf1fb6a2d24cf99bf5fb8e7e985e49'),(1533,'C','7fd1904f5e54463a8f74200a9467c5a8'),(1534,'A','ed7970d17171416c88057ae5ad29de22'),(1535,'A','2d7b877ae08340de919a5d60692c40eb'),(1536,'D','2d7b877ae08340de919a5d60692c40eb'),(1537,'A','f354fa95401c47ab813f0fb32eb643ad'),(1538,'C','f354fa95401c47ab813f0fb32eb643ad'),(1539,'D','f354fa95401c47ab813f0fb32eb643ad'),(1540,'C','565143c36d0e432c9355fb096ecd7768'),(1541,'A','2b171df85b4548e8bc6f46a0046e496e'),(1542,'C','2b171df85b4548e8bc6f46a0046e496e'),(1543,'C','8cef7b5b21a44874ac7af50a1d5a3382'),(1544,'A','4d4a848543b74a708fd5df2230be027f'),(1545,'A','2192b2013e7549b69fec9b9ff923bbed'),(1546,'D','13f5212a4f674d9bb151196a1025b471'),(1547,'A','1b1cce5c6d044599b308511fc9a3597f'),(1548,'C','1b1cce5c6d044599b308511fc9a3597f'),(1549,'B','830161e7efa54937bdcc92bacb9c5872'),(1550,'C','71be85c182a743448e1dc392bb039ce9'),(1551,'A','3f49c7cd34bc4f0e9e9a18e4a26e455b'),(1552,'C','27c717cb8a19469e882a2922a6c5ea52'),(1553,'A','b69a22c014584bcb9fff5fb141adb006'),(1554,'D','52f1b9db3e734f44b3743bd780ed0857'),(1555,'D','bfb3410b1a8c4929bd2a01237b55913f'),(1556,'A','40d9c0a463fc40a69a807c2eb3ad6463'),(1557,'A','c0d7f49739dd4e849e7bdac0055c1a48'),(1558,'B','c0d7f49739dd4e849e7bdac0055c1a48'),(1559,'A','14cca6e3ef854bb397efb0aadfa31d63'),(1560,'B','165a378ebfc2416e8a266ab7b018e38a'),(1561,'B','f48e3a6fc8c14a648b1ccf860b763de5'),(1562,'C','f48e3a6fc8c14a648b1ccf860b763de5'),(1563,'D','ac4bd20ee9304f189869a40ff0cefcc1'),(1564,'A','4ff77a9c28be4d87a040673fcd90093e'),(1565,'D','c6418c4b353e493bb8d55f67780021aa'),(1566,'A','e64ba6758d30412d9215cec1b30a7b54'),(1567,'C','cf95fb31e0564b258377783cb70616bf'),(1568,'B','d9b2686b63344450ab2a1ef25f804b3a'),(1569,'D','56ac150c7fe9491f8f97c155e1e7435d'),(1570,'A','d43078beda5a41d8b59bea9ac51fde20'),(1571,'D','35eef0aa148a4aaabe115630208f097f'),(1572,'D','d4deecb7a92445a2bad722ceebd734db'),(1573,'D','8659e8558057407d916ac46c076ddeb6'),(1574,'B','12a8af5c01bc48a9984ffe9f4ba1dd9d'),(1575,'A','f5278b6690224ca8ba8451a1d42e4f50'),(1576,'a','749c0a104669457aa2450dc93c950956'),(1577,'A','5cef17afc56a4eae9c7d97da884a7bca'),(1578,'A','52f0938d4e4041a39392ddae83dadbb7'),(1579,'A','d737d9ef20c1446984d3fe682ba1c0b5'),(1580,'A','33fb760f316141f495bb943994f95b55'),(1581,'A','19d9fcd308024a9180cc1d9d609bfaef'),(1582,'D','01556a776dec4646a19fdb1c64e55ae7'),(1583,'B','6fd9c534cbf5458f88d17c3929e17f1a'),(1584,'D','6fd9c534cbf5458f88d17c3929e17f1a'),(1585,'B','f19e6b62a94b4f9aafcd60145297e9e7'),(1586,'B','265d006e5daa4440800685aab785c0c0'),(1587,'C','265d006e5daa4440800685aab785c0c0'),(1588,'D','265d006e5daa4440800685aab785c0c0'),(1589,'A','4e1f1f6dcba9443091927b560c6f4f0e'),(1590,'A','6214b31fd5df4d2686b2e12e705795bb'),(1591,'D','6214b31fd5df4d2686b2e12e705795bb'),(1592,'C','32ef4289799a4ed39203b2d66108fbc6'),(1593,'B','d2210e77b3214dd29100626b79a5dc1a'),(1594,'C','fb0710342c554d65803f72dbb2e6a66f'),(1595,'A','0499715fdfe642a79268a904d2ac3a97'),(1596,'A','6754cad30abd4c40a38424cd0fe79c2f'),(1597,'D','6754cad30abd4c40a38424cd0fe79c2f'),(1598,'A','1450df9964fd47a68c02488519c85338'),(1599,'C','1450df9964fd47a68c02488519c85338'),(1600,'D','1450df9964fd47a68c02488519c85338'),(1601,'C','f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(1602,'A','81d0fb9e895c45468c3031afacb1e19b'),(1603,'C','81d0fb9e895c45468c3031afacb1e19b'),(1604,'C','cb9865c857a341d9a38b9005310e9d04'),(1605,'A','56fb35cb35364282929fbb24c5bf453a');

/*Table structure for table `Questions_message` */

DROP TABLE IF EXISTS `Questions_message`;

CREATE TABLE `Questions_message` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `stem` varchar(500) NOT NULL COMMENT '题干',
  `Comment` varchar(500) DEFAULT NULL COMMENT '点评',
  `score` int(10) NOT NULL COMMENT '评分',
  `class_type` int(10) NOT NULL,
  `class_level` int(10) NOT NULL,
  `uid` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=517 DEFAULT CHARSET=utf8 COMMENT='题干信息表';

/*Data for the table `Questions_message` */

insert  into `Questions_message`(`id`,`stem`,`Comment`,`score`,`class_type`,`class_level`,`uid`) values (48,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,1,1,'57a446633a6543388814b664cc005444'),(49,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'55037bdaaef44631936cccd2070f04ab'),(50,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,1,1,'22ef1cce8ae64e92b08dd789dfb27419'),(51,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'3645ee7246f34091a6d3d0ef22c49c00'),(52,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,1,1,'267f4a4ba6934a39ab9e1689283ff7fb'),(53,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,1,1,'aa881d921b0544be89a86d369dc3056a'),(54,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,1,1,'4769b8c5f68f4f2eb98af9f64b01292c'),(55,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,1,1,'1c1b1268552d44828a9592f15a20627d'),(56,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,1,1,'e6aa897d8ff442a68dc5fa753bc6afed'),(57,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,1,1,'c55b2d9f4e994f94a0d9110f8abf8450'),(58,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,1,1,'7bdda4a7cfdf493b9b1dac7bd1f4185b'),(59,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,1,1,'9370fff49d4840369fb3da6af52ef496'),(60,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,1,1,'92c286733e354108bc40d94fe32414e2'),(61,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,1,1,'6dd4b94cae584048a78ef2856d6f3985'),(62,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,1,1,'6fed36f8c2664e888fdbad4481f64cab'),(63,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,1,1,'5d58d18f32e14553ad1b129049bae92d'),(64,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,1,1,'89e81dca7dbe48e395cb97dff26e5b66'),(65,'下面那几个函数是public void method(){...}的重载函数?  ','',2,1,1,'972c3583242545488cce4cd741865238'),(66,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,1,1,'9b98e4a9feef437aa187ae9285477fc7'),(67,'如下哪些不是java的关键字?','',1,1,1,'5f960859db894c6cb7f71999401b4ddd'),(68,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,1,1,'7809e2eac65449e9a7908838242ec00c'),(69,'方法resume()负责恢复哪些线程的执行 ','',1,1,1,'2d256d0fbedb44e281b16ece605f1038'),(70,'有关线程的哪些叙述是对的 (多选)','',2,1,1,'f0d0e20f35ea4b0380142dd997f77192'),(71,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,1,'cebc951416ec45a581a571570054eb91'),(72,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,1,1,'d949a72652944528ba271a4a158d1c6d'),(73,'下面的哪些声明是合法的？  ','',2,1,1,'5e1321e3ee05405f864afcccf88e1561'),(74,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,1,1,'8e4dd2ebe2bb491e8a337134269185d7'),(75,'以下哪个方法用于定义线程的执行体？  ','',1,1,1,'c93f3ad8c6b8437ab845966e87047389'),(76,'下列关于栈的叙述正确的是   ','',1,1,1,'8741da9946ed44a68ed855f8382d2636'),(77,'关于垃圾收集的哪些叙述是对的  ','',1,1,1,'3ec3f60955b748b8997cfc38ff39f2ff'),(78,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,1,1,'499734536a7d4480b8f559529f0bbf84'),(79,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'0b6d0f7622c94306984880a7705e3f52'),(80,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,1,1,'95cd6ab3b6474300a8d1d538693a2f6d'),(81,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'0979470ddbeb48b48cfa1e1bcf745dd8'),(82,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,1,1,'9989bc85a76d493d995b0ecca1fceed7'),(83,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,1,1,'36fb429d6a2640439157181b616a9ea7'),(84,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,1,1,'b274216832dc491894a7dde1e8efb55c'),(85,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,1,1,'93b80d394be34783b5680e434f4fac49'),(86,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,1,1,'3a37b9da03f14621b47008338bc71499'),(87,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,1,1,'62fa88ad8f174e589724bef4bbe9bbe4'),(88,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,1,1,'4145219dfc5a4401817b8d76d75f8375'),(89,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,1,1,'9c73cd4bd6a5494bab18e450b009a173'),(90,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,1,1,'492965ba58284f66b9e060f26a86ae77'),(91,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,1,1,'863ecfd1ec414fcf99a4f0b630b6246a'),(92,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,1,1,'eed7ac52082c45698fb2a1faa9226c03'),(93,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,1,1,'0e4f199c7af84262a55896d26c16a82b'),(94,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,1,1,'bc12d383722541cdaebba3d3346c0d50'),(95,'下面那几个函数是public void method(){...}的重载函数?  ','',2,1,1,'3238392cfa5b4c7d937643e0f7f42bf7'),(96,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,1,1,'2b81c8093fe54987a91b26fd4403e9e8'),(97,'如下哪些不是java的关键字?','',1,1,1,'28969610f88e44b6999619bf01f9e3b1'),(98,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,1,1,'86bb4f81334240a78457025ba9608e98'),(99,'方法resume()负责恢复哪些线程的执行 ','',1,1,1,'a2fe8e7903b64e5f9d6ef268f9e2de8f'),(100,'有关线程的哪些叙述是对的 (多选)','',2,1,1,'9bcfddb168b54e75854cd978b0a70bda'),(101,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,1,'c64a03ee9ceb44349a03e8d236f047f0'),(102,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,1,1,'4f48062a0cce415d834aec73a3b8032a'),(103,'下面的哪些声明是合法的？  ','',2,1,1,'60232efc41d24e6b84c16e090c6d6084'),(104,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,1,1,'35809ebfca43434f9665f850c113cf89'),(105,'以下哪个方法用于定义线程的执行体？  ','',1,1,1,'a27fb10053e749e993319b790609ceaf'),(106,'下列关于栈的叙述正确的是   ','',1,1,1,'550b31d98e6f4c9797f18e880b8bd302'),(107,'关于垃圾收集的哪些叙述是对的  ','',1,1,1,'8a7b8c9d1cc642e585302438d2d30493'),(108,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,1,1,'2782e588436842a5a8716f2a471d10c5'),(109,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'3f5f216a67d64b18aae9896095d3b2c1'),(110,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,1,1,'77e73195b8784e1dad06be125fcf31fb'),(111,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,1,1,'07f2483d79f0423ebd67148b6017ae6e'),(112,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,1,1,'f97c0d5325ac4ef09a346f02edc3a103'),(113,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,1,1,'9357c6c525e94fa2a931dfc2710ffd1e'),(114,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,1,1,'341e7a5771274518b3dfc3adf2808e2f'),(115,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,1,1,'8e97bb261db94e30a0f6b6e0a0618fc6'),(116,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,1,1,'8f55f67b36b247598224fed4da7ec555'),(117,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,1,1,'98dbb42cad2844dbbeebf25cc5a832bf'),(118,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,1,1,'8311c749320742aeb43ec1bf98ec2a8b'),(119,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,1,1,'87de338fb2af462b892f5e05f3ffdf38'),(120,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,1,1,'51ef8657b9ed434195789a21d09b8289'),(121,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,1,1,'8427a07b308141a39429a197a90c9feb'),(122,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,1,1,'37bb6ee2315a46b1959267772d30997b'),(123,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,1,1,'291ef4d1ff63464492b8a5e5ded212e0'),(124,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,1,1,'2040e52b11a044afa768f8611400f2f5'),(125,'下面那几个函数是public void method(){...}的重载函数?  ','',2,1,1,'54d4cda3c7ff4e709ffe37ae2a179585'),(126,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,1,1,'4521998d5492452a937a663597e4e46e'),(127,'如下哪些不是java的关键字?','',1,1,1,'56e4b65b31f5412a8aef245a2b659a4f'),(128,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,1,1,'ebecab2c5c6242da8864cae19ed65c9b'),(129,'方法resume()负责恢复哪些线程的执行 ','',1,1,1,'ba7a7a03af724bd2aab7130cf1b6d98f'),(130,'有关线程的哪些叙述是对的 (多选)','',2,1,1,'dcce0330928c42b099dbcf44aa55d367'),(131,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,1,'b96fb1ebe7d04e5da20d20677e03a772'),(132,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,1,1,'9ee58f1d252b488c8d3503d3257e0489'),(133,'下面的哪些声明是合法的？  ','',2,1,1,'589f85365953474c9dc4316d764006d1'),(134,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,1,1,'8d216f38f0c44bf688d354beed1b6866'),(135,'以下哪个方法用于定义线程的执行体？  ','',1,1,1,'5256a206377f489b9f8ec91ad00d81ff'),(136,'下列关于栈的叙述正确的是   ','',1,1,1,'fc5d6334eb31432c9c9c3f2e30190430'),(137,'关于垃圾收集的哪些叙述是对的  ','',1,1,1,'38266ab0c30643459203b9ec402a31f0'),(138,'关于面向对象的说法正确的是（  ）','',1,3,1,'88a68bc04d984a58a5a5fb715b10c91a'),(139,'以下关于抽象类和接口的说法错误的是（  ）  ','',1,3,1,'8062be40f2bc44e3931f43e3f5d7e36a'),(140,'以下用于创建容器对象的类是（  ）（选择两项）','',2,3,1,'d8f70d3d49c34caba653791d65e03075'),(141,'以下关于布局的说法，错误的是（  ） ','',1,3,1,'9038d6b293b141f294007c214d1d03ea'),(142,'在JAVA中ArrayList类实现了可变大小的数组，便于遍历元素和随机访问元素，已知 获得了ArrayList类的对象bookTypeList，则下列语句中能够实现判断列表中是否存在','',1,3,1,'bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(143,'分析选项中关于Java中this关键字的说法正确的是（  ）','',1,3,1,'e1d9217a179d4dc6a086bba7b1bad2d2'),(144,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,3,1,'b2c9595a4f9943ccac052842a490184d'),(145,'Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）','',1,3,1,'8777e01cda604b7f8761ae38dc4021e0'),(146,'下列选项中关于Java中封装的说法错误的是（ ）。 ','',1,3,1,'f52079f7db5b4e67988d50a94de7f758'),(147,'在JAVA中，Object类是所有类的父亲，用户自定义类默认扩展自Object类，下列选项 中的（  ）方法不属于Object类的方法。','',1,3,1,'447a4ff6e92e450bac70b311a7714c1f'),(148,'在JAVA的异常处理模型中，能单独和finally语句一起使用的块是（ ）','',1,3,1,'68ebb66d022649b6b02b8347f3c1328b'),(149,'在Java接口中，下列选项中有效的方法声明是（  ）。（选择二项） ','',2,3,1,'a59cfa5cdfa141e1b31eae5d2dadca8d'),(150,'下列选项中关于Java中super关键字的说法正确的是（ ）','',1,3,1,'5805162af038471a915a74292e25b76a'),(151,'`','B',2,3,1,'ec79577e06f24aa382a13bbc9ac83f2d'),(152,'','BC',2,3,1,'e0d56f51b8b842b1b04181553cb0cdcf'),(153,'','D',2,3,1,'bf3f7ba00d274129aea4b9aeb2300b34'),(154,'','A',2,3,1,'6095a401ca8a404ca7f13e8e9725fb62'),(155,'','D',2,3,1,'76b96d4a859645088ea3117d14e10c8b'),(156,'','A',2,3,1,'227e55a3fc3342d9b04a3e7503290c75'),(157,'','C',2,3,1,'410c38fbce94425bb813bddee3c79daf'),(158,'','B',2,3,1,'1d07e5d16cd042ad926760f9b3211863'),(159,'','D',2,3,1,'3b130363445b4b32bb311b5f3c44d224'),(160,'','A',2,3,1,'126f3689546d4c8f9ecad6cf4baf0037'),(161,'','D',2,3,1,'bc1040b6c26d4bc28a306a5d5e167b4f'),(162,'','D',2,3,1,'c2d82e059bef4634b439ae58349f01b3'),(163,'','D',2,3,1,'a35a5aebdd354ae5ae0f75a6a77d4374'),(164,'','B',2,3,1,'717586535ae7442ead3dd17363782956'),(165,'','A',2,3,1,'b42e049c44b74cce9f8fa882a599cdb3'),(166,'','a',2,3,1,'0ded419a03a8402a8f0c7605c37ee303'),(167,'','A',2,3,1,'954ce958d8ea4e65ad75dd6c4c544aa8'),(168,'','A',2,3,1,'8b414f97f37c4d5282693c7e4a410630'),(169,'','A',2,3,1,'daaac5f7f17648ad9f72669c4cbc5067'),(170,'','A',2,3,1,'43da938ab13542e196dbccc649c80bd1'),(171,'','A',2,3,1,'678c081b2dac4f24bfe4d5168d0fd051'),(172,'','D',2,3,1,'68cab8ab20f441c1ab0dfe9965fe29a0'),(173,'','BD',2,3,1,'e8e6b37a495040c7a42b5044e1977611'),(174,'','B',2,3,1,'5fff04f70d774f5d8755b1d89504ae54'),(175,'','BCD',2,3,1,'639921545d28411db6b172befeaf2a18'),(176,'','A',2,3,1,'f3bbcfaa45534a819b48de3c52d76888'),(177,'','AD',2,3,1,'7403c2f1dee74140b600fbe410e02490'),(178,'','C',2,3,1,'64905cc258104eb7a2cc02998326f140'),(179,'','B',2,3,1,'bbfc083585d140d787f0444ada09b5a2'),(180,'','C',2,3,1,'3e8b79b07a614aba80e248bf3fd97a84'),(181,'','',2,3,1,'46fc9416a72d4d6e96a8f12232cd6c1f'),(182,'','AD',2,3,1,'6693a04918124b32b0b86d1577609e12'),(183,'','ACD',2,3,1,'1d49e67b65fb4facabc924ba268558fe'),(184,'','C',2,3,1,'b33fd17060c84e7d9ff78f62370a3f94'),(185,'','AC',2,3,1,'5c593c484e4a485d97190f5aa23226da'),(186,'','C',2,3,1,'b94ddff9193c41fdb504b848f9ae3d03'),(187,'','A',2,3,1,'5fe50b7ca40c413cabe90e6a561b302f'),(317,'关于面向对象的说法正确的是（  ）','',1,1,3,'909bd14bd65047e5a3d14e8a70139159'),(318,'以下关于抽象类和接口的说法错误的是（  ）  ','',1,1,3,'5aa4c70609e24c48850d4d6339e84b4c'),(319,'以下用于创建容器对象的类是（  ）（选择两项）','',2,1,3,'131ed917d9c44513a5633f28d449d5b3'),(320,'以下关于布局的说法，错误的是（  ） ','',1,1,3,'116369da665b44ceb3246d2d7682042e'),(321,'在JAVA中ArrayList类实现了可变大小的数组，便于遍历元素和随机访问元素，已知 获得了ArrayList类的对象bookTypeList，则下列语句中能够实现判断列表中是否存在','',1,1,3,'6a9374cf008f46b39329436c6a1b3208'),(322,'分析选项中关于Java中this关键字的说法正确的是（  ）','',1,1,3,'d62a9d5432384283a2719df8879bbc1c'),(323,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,3,'4cb48c7571894b4f9ec55d9f53d4836a'),(324,'Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）','',1,1,3,'40bb8040eeea498eadefb4d3affd3efa'),(325,'下列选项中关于Java中封装的说法错误的是（ ）。 ','',1,1,3,'93578c12c0ff47e7a888b945caf96b41'),(326,'在JAVA中，Object类是所有类的父亲，用户自定义类默认扩展自Object类，下列选项 中的（  ）方法不属于Object类的方法。','',1,1,3,'4516a7c4ddbe4b158962cd225f862a2b'),(327,'在JAVA的异常处理模型中，能单独和finally语句一起使用的块是（ ）','',1,1,3,'9951bbeb408a44a993400d4e7a17c79d'),(328,'在Java接口中，下列选项中有效的方法声明是（  ）。（选择二项） ','',2,1,3,'014cd684159c40f1bf385c7e411c5eb8'),(329,'下列选项中关于Java中super关键字的说法正确的是（ ）','',1,1,3,'1bed7e77feed463aa313e4e3956a2a43'),(330,'在Java语言中，下列关于类的继承的描述，正确的是（ ）','',1,1,3,'9426e04fa6c64a1593c2a4fe05597661'),(331,'在Java中，下面对于构造函数的描述错误的是（  ）（选择两项）','',2,1,3,'a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(332,'下面关于OPM的说法不正确的是','',1,1,3,'683943e1e3d34651a83cfa4549b2799a'),(333,'spring能管理的组件不包括','',1,1,3,'82d63683b9b64b6c9bd79e7d6275295e'),(334,'在J2EE中，request对象的方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据','',1,1,3,'d8d6ce051cc74adda9daf2eb148b6054'),(335,'在J2EE中，test.jsp文件中有如下一行代码：\n<jsp:useBean id=”user”scope=”_”type=”com.UserBean”/>要使user对象只能在使用test.jsp时使用，当加载页面时就会将其销毁','',1,1,3,'dbf0d85317f241d48b6a8d91dc3f5763'),(336,'要设计一个大型的基于多层体系结构的web应用系统，系统界面端基于HTML和XML，该系统要不断的进行版级（即日后维护、二次需求开发等任务量较大），要达成这些目标，最适合的开发模式是','',1,1,3,'97a43b8cba1d4e5cbf14123c615dba8a'),(337,'在J2EE中，使用Servlet过滤器时，需要在web.xml通过（B）元素将过滤器映射到Web资源。','',1,1,3,'d21ce5ab62bc4b3786c3903abc51add2'),(338,'在J2EE的Model II模式中，模型层对象被编写为','',1,1,3,'ee1dc62698ba4f3a83898f94b4b9d472'),(339,'J2EE中，()类的（）方法用于返回应用程序的上下文路径。','',1,1,3,'02076d1058dd4a15aa132ab8a3846e04'),(340,'Web应用中，常用的会话跟踪方法不包括','',1,1,3,'6b2301dde567463dbbd53680b363bbee'),(341,'给顶一个JSP程序源代码，如下：\n<jsp:include page=\"two.jsp\" flush=\"true\">\n<jsp:param name=\"location\" value=\"bejing\"/>\n</jsp:include>在two.jsp中使用（）代码片段可以输出参数location的值。','',1,1,3,'59bc97a58cdd46c3bc79261dc282c62f'),(342,'JavaMail是一组用于发送和接收邮件消息的API。发送邮件使用（）协议，接收邮件使用（）协议','',1,1,3,'f9446cfe21c44e199102c9be7a13f508'),(343,'在J2EE中，在一个JSP文件中，有表达式<%=2+3 %>，它将输出（ ）','',1,1,3,'a77a9c5766a2404ebc1f14055751afab'),(344,'在JSP中，（）动作用于将请求转发给其他JSP页面','',1,1,3,'9f594676ea16490584ab04c73fb44515'),(345,'在J2EE实现企业级应用开发中，（ ）是描述标记库的XML文档','',1,1,3,'89578b4126ac417ca21a49a850406909'),(346,'用来获取一个已被创建的JavaBean组件的属性值','',1,1,3,'782e6f039ebf402fbda0363779394ec7'),(347,'在WAR文件中，web.xml放在哪个目录中','',1,1,3,'a79f9c7cba2a4c379c648c34516ceadd'),(348,'Servlet间完成协作，需要用到（ ）完成请求指派','',1,1,3,'0dddbefe024a41fabe0b3491f204eb2e'),(349,'JSP从HTML表单中获得用户输入的正确语句为','',1,1,3,'490e2106952f4c11ad7d51f433fca974'),(350,'常用的上传邮件的协议是','',1,1,3,'e21adbf54f9948c69da67bd6ff941719'),(351,'关于sleep()和wait()，以下描述错误的一项是（ ）','',1,1,3,'4e41562006754a8fb1c50f7dee810c5b'),(352,'[多选]  在Session范围中以名称\"bean\"放置了一个JavaBean属性，JavaBean上有个 getMessage()方法，请问以下哪个方式呼叫getMessage()以取得讯息并显示出来？','',2,1,3,'628c38191f45499086980b02cb06c762'),(353,'在Java中，负责对字节代码解释执行的是   ','',1,1,3,'8fedf8b65c954e23b173fcbcd522e916'),(354,'有关线程的哪些叙述是对的（ ）','',2,1,3,'7b00635c1e7d4e8f87caf2d376f57b65'),(355,'Java I/O程序设计中，下列描述正确的是','',1,1,3,'c56482ede37c460ca5570e033772b0dd'),(356,'关于Java语言，下列描述正确的是（多选）','',2,1,3,'564e350d1c2843ba8365b064f56c0439'),(357,' 关于线程设计，下列描述正确的是','',1,1,3,'32adc9ce3c7b4e3fa9f23a5b90410461'),(358,' 欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的','',1,1,3,'9020367beede44f5b93059a75713b034'),(359,'关于线程设计，下列描述正确的是','',1,1,3,'fc69113129a44b4badeb408c7948c8ef'),(360,'以下哪个命令用于测试网络连通。','',1,1,3,'0882ec97c005432c874f57ba0e5c94ab'),(361,'Java网络程序设计中，下列正确的描述是','',2,1,3,'f60dcc77fb0649df9a16199fbede9b44'),(362,'下列哪些是J2EE的体系','',2,1,3,'2cbd536c7819476495d6cae2301d9643'),(363,'如何取得数据源。','',1,1,3,'b3a378983d5e46de95c31633796f663b'),(364,'关于JSP生命周期的叙述，下列哪些为真？','',2,1,3,'68bbfca9f9d64b829fa471abd380890d'),(365,'下面的那一个不属于MVC模式中的对象','',1,1,3,'55be2305662e46c199f9c9db6c175d9d'),(366,'下面哪些属于JSTL中的表达式操作标签。(选择1项)','',1,1,3,'5dffbb7f55a84d458fe5326ccacdaa47'),(367,'关于面向对象的说法正确的是（  ）','',1,1,3,'0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(368,'以下关于抽象类和接口的说法错误的是（  ）  ','',1,1,3,'ac74959aa3ff42789ec08555b95fdfe6'),(369,'以下用于创建容器对象的类是（  ）（选择两项）','',2,1,3,'244f8104ff5847149a1918536377eca5'),(370,'以下关于布局的说法，错误的是（  ） ','',1,1,3,'c1a4862c6bc4432185938cb15a0f6764'),(371,'在JAVA中ArrayList类实现了可变大小的数组，便于遍历元素和随机访问元素，已知 获得了ArrayList类的对象bookTypeList，则下列语句中能够实现判断列表中是否存在','',1,1,3,'f4881d2c800847cea2fc07891268c1fb'),(372,'分析选项中关于Java中this关键字的说法正确的是（  ）','',1,1,3,'8c289ea1bd714615a8a57b62efd56092'),(373,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,3,'9bd8a2fbcead454496452e117b70974f'),(374,'Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）','',1,1,3,'2a7a435aabd9473db634967686dd8597'),(375,'下列选项中关于Java中封装的说法错误的是（ ）。 ','',1,1,3,'462703eb5bd6419e8eabd19880f1bb53'),(376,'在JAVA中，Object类是所有类的父亲，用户自定义类默认扩展自Object类，下列选项 中的（  ）方法不属于Object类的方法。','',1,1,3,'16e156d20b7f48b9ae92c9db129233b5'),(377,'在JAVA的异常处理模型中，能单独和finally语句一起使用的块是（ ）','',1,1,3,'6f66eba1cfa1454d94eceb320415fe1b'),(378,'在Java接口中，下列选项中有效的方法声明是（  ）。（选择二项） ','',2,1,3,'e33a3c7098ac453a9c5b6d62c3c56b8b'),(379,'下列选项中关于Java中super关键字的说法正确的是（ ）','',1,1,3,'a65b42bbe6c2437eb40e9bc192d3c381'),(380,'在Java语言中，下列关于类的继承的描述，正确的是（ ）','',1,1,3,'2896d8c737bc4f27824fb85bac44c56f'),(381,'在Java中，下面对于构造函数的描述错误的是（  ）（选择两项）','',2,1,3,'588fba50948e4005ac646356b762b9bd'),(382,'下面关于OPM的说法不正确的是','',1,1,3,'afb5261a51ca40f28be67902e29ebe7c'),(383,'spring能管理的组件不包括','',1,1,3,'55e829ff5bc242868333f9588a7ec9d6'),(384,'在J2EE中，request对象的方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据','',1,1,3,'297d0479c7df487983358b78835c6797'),(385,'在J2EE中，test.jsp文件中有如下一行代码：\n<jsp:useBean id=”user”scope=”_”type=”com.UserBean”/>要使user对象只能在使用test.jsp时使用，当加载页面时就会将其销毁','',1,1,3,'1cbdc697f0504174aa93f5fa5bb1bdba'),(386,'要设计一个大型的基于多层体系结构的web应用系统，系统界面端基于HTML和XML，该系统要不断的进行版级（即日后维护、二次需求开发等任务量较大），要达成这些目标，最适合的开发模式是','',1,1,3,'1dedd6878b164e219a58b070cc7f55f2'),(387,'在J2EE中，使用Servlet过滤器时，需要在web.xml通过（B）元素将过滤器映射到Web资源。','',1,1,3,'1fb52e896c61430ab7089d2ad9a8e11f'),(388,'在J2EE的Model II模式中，模型层对象被编写为','',1,1,3,'cdca664b0d22406db81a680ba2992e07'),(389,'J2EE中，()类的（）方法用于返回应用程序的上下文路径。','',1,1,3,'72329b2187b34b27b5cd701c02497955'),(390,'Web应用中，常用的会话跟踪方法不包括','',1,1,3,'ee37b7456f2c4aa780f5880fac338897'),(391,'给顶一个JSP程序源代码，如下：\n<jsp:include page=\"two.jsp\" flush=\"true\">\n<jsp:param name=\"location\" value=\"bejing\"/>\n</jsp:include>在two.jsp中使用（）代码片段可以输出参数location的值。','',1,1,3,'5366dc69b6c142c4aed60b7bfd6ec97c'),(392,'JavaMail是一组用于发送和接收邮件消息的API。发送邮件使用（）协议，接收邮件使用（）协议','',1,1,3,'ccb000367ed84bfea3e18f03d7028efe'),(393,'在J2EE中，在一个JSP文件中，有表达式<%=2+3 %>，它将输出（ ）','',1,1,3,'3340719421a340178837663bc78a07d5'),(394,'在JSP中，（）动作用于将请求转发给其他JSP页面','',1,1,3,'3bc8b36559b94a04a0bb937bffa2c432'),(395,'在J2EE实现企业级应用开发中，（ ）是描述标记库的XML文档','',1,1,3,'85521921aaab4533b527c3ef044ce2e1'),(396,'用来获取一个已被创建的JavaBean组件的属性值','',1,1,3,'fbcbb40f929346f48798f7bc5a29c077'),(397,'在WAR文件中，web.xml放在哪个目录中','',1,1,3,'c30638dd08b34c06ab3d2d086a35faab'),(398,'Servlet间完成协作，需要用到（ ）完成请求指派','',1,1,3,'fefd7221d3bf434f8bd238390deed930'),(399,'JSP从HTML表单中获得用户输入的正确语句为','',1,1,3,'48517b3b986340ebadcb531175b68b0d'),(400,'常用的上传邮件的协议是','',1,1,3,'fab7bcf5532343f289b335d6d3fb6eaf'),(401,'关于sleep()和wait()，以下描述错误的一项是（ ）','',1,1,3,'74b9e2aabc7340888e4bebb5b776476b'),(402,'[多选]  在Session范围中以名称\"bean\"放置了一个JavaBean属性，JavaBean上有个 getMessage()方法，请问以下哪个方式呼叫getMessage()以取得讯息并显示出来？','',2,1,3,'594f1dcedc2a45fea97e0ea56e91a1a1'),(403,'在Java中，负责对字节代码解释执行的是   ','',1,1,3,'a91784f07138422ea28da88e5bdbcde3'),(404,'有关线程的哪些叙述是对的（ ）','',2,1,3,'39e32b60ee064dac8174c2871a07a937'),(405,'Java I/O程序设计中，下列描述正确的是','',1,1,3,'3be4e1eec011407bbce0afee6505ffca'),(406,'关于Java语言，下列描述正确的是（多选）','',2,1,3,'15f25c4647ed49879f53cd753f74dd78'),(407,' 关于线程设计，下列描述正确的是','',1,1,3,'94aa5b5a5e304433a461e349efd38dd8'),(408,' 欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的','',1,1,3,'68014607c39742e49222a276d8b8de8d'),(409,'关于线程设计，下列描述正确的是','',1,1,3,'b4deefe615974c4d858b73c36574c41e'),(410,'以下哪个命令用于测试网络连通。','',1,1,3,'b171105de04242d8898be0410dfe86dc'),(411,'Java网络程序设计中，下列正确的描述是','',2,1,3,'0107de32f873494fa383e9a1abddad48'),(412,'下列哪些是J2EE的体系','',2,1,3,'638e5d58924f467f9390a7e0cd67f1a6'),(413,'如何取得数据源。','',1,1,3,'9881b5ca9f664c3bb45f1d6f22ff5234'),(414,'关于JSP生命周期的叙述，下列哪些为真？','',2,1,3,'d9ecd0c469374f22a61b3a997b4737ba'),(415,'下面的那一个不属于MVC模式中的对象','',1,1,3,'6f32eb7647e14653ac9b6ee42c6afc75'),(416,'下面哪些属于JSTL中的表达式操作标签。(选择1项)','',1,1,3,'49c470f72aaa4be2a29c7d12143d92a5'),(417,'关于面向对象的说法正确的是（  ）','',1,1,3,'7c89001a5fbb4d04b43a0bddcc190c80'),(418,'以下关于抽象类和接口的说法错误的是（  ）  ','',1,1,3,'e38bde24d58149c5a9e67fa92ce81ac5'),(419,'以下用于创建容器对象的类是（  ）（选择两项）','',2,1,3,'3e544ea2716043b6a9acf1f1ac37a400'),(420,'以下关于布局的说法，错误的是（  ） ','',1,1,3,'f30c6491f80d40248c3821d9f7f7fb53'),(421,'在JAVA中ArrayList类实现了可变大小的数组，便于遍历元素和随机访问元素，已知 获得了ArrayList类的对象bookTypeList，则下列语句中能够实现判断列表中是否存在','',1,1,3,'1918e2beb8cf4a488b399edd32d448e9'),(422,'分析选项中关于Java中this关键字的说法正确的是（  ）','',1,1,3,'8680f59744ba43888754448c66244725'),(423,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,3,'da77e5dbc4db455eb53aef765b50e9b0'),(424,'Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）','',1,1,3,'a16d4a100c184469925ba2f098ccfb00'),(425,'下列选项中关于Java中封装的说法错误的是（ ）。 ','',1,1,3,'23a7da6daa904a91830751b1ca959756'),(426,'在JAVA中，Object类是所有类的父亲，用户自定义类默认扩展自Object类，下列选项 中的（  ）方法不属于Object类的方法。','',1,1,3,'b8f301502d164cfe95b05ecc73c79f05'),(427,'在JAVA的异常处理模型中，能单独和finally语句一起使用的块是（ ）','',1,1,3,'03147897644546c9a9013ba8a147fa6d'),(428,'在Java接口中，下列选项中有效的方法声明是（  ）。（选择二项） ','',2,1,3,'f28f1de3b0844e13a0339bb8c9dd9c21'),(429,'下列选项中关于Java中super关键字的说法正确的是（ ）','',1,1,3,'0bec17b5cdf24b9fa4f3d2589805d1a9'),(430,'在Java语言中，下列关于类的继承的描述，正确的是（ ）','',1,1,3,'a6690bb3880e41558793cefcd4716e4f'),(431,'在Java中，下面对于构造函数的描述错误的是（  ）（选择两项）','',2,1,3,'46cb8790d15541388561e5a973369732'),(432,'下面关于OPM的说法不正确的是','',1,1,3,'9931855ba5654b229d0823ad9ab8a5da'),(433,'spring能管理的组件不包括','',1,1,3,'cecc2419ee64492592296b98fa88784a'),(434,'在J2EE中，request对象的方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据','',1,1,3,'97b4113429124586817a723573f559b8'),(435,'在J2EE中，test.jsp文件中有如下一行代码：\n<jsp:useBean id=”user”scope=”_”type=”com.UserBean”/>要使user对象只能在使用test.jsp时使用，当加载页面时就会将其销毁','',1,1,3,'93d48f2c919543ceb58c404f9bb5868d'),(436,'要设计一个大型的基于多层体系结构的web应用系统，系统界面端基于HTML和XML，该系统要不断的进行版级（即日后维护、二次需求开发等任务量较大），要达成这些目标，最适合的开发模式是','',1,1,3,'dcb5310dacc147ec8502d1638f4b4d54'),(437,'在J2EE中，使用Servlet过滤器时，需要在web.xml通过（B）元素将过滤器映射到Web资源。','',1,1,3,'dfbbcccbd989440cb266c90f99ab6870'),(438,'在J2EE的Model II模式中，模型层对象被编写为','',1,1,3,'350e9a62ce3b46138cf0079d4b879410'),(439,'J2EE中，()类的（）方法用于返回应用程序的上下文路径。','',1,1,3,'37bdadaa708c4406802ef093a48b1c05'),(440,'Web应用中，常用的会话跟踪方法不包括','',1,1,3,'c4abbe5d6be8402b8dab1852218a8096'),(441,'给顶一个JSP程序源代码，如下：\n<jsp:include page=\"two.jsp\" flush=\"true\">\n<jsp:param name=\"location\" value=\"bejing\"/>\n</jsp:include>在two.jsp中使用（）代码片段可以输出参数location的值。','',1,1,3,'003da51b8a8a4e2baa66fc56083c55e1'),(442,'JavaMail是一组用于发送和接收邮件消息的API。发送邮件使用（）协议，接收邮件使用（）协议','',1,1,3,'dc9c9b3815014439a5918f6abf99a57c'),(443,'在J2EE中，在一个JSP文件中，有表达式<%=2+3 %>，它将输出（ ）','',1,1,3,'0027848a71ef4fd6b32e26231d57fad8'),(444,'在JSP中，（）动作用于将请求转发给其他JSP页面','',1,1,3,'17a4e16983bd4b56bbd5a1f2a9136bfb'),(445,'在J2EE实现企业级应用开发中，（ ）是描述标记库的XML文档','',1,1,3,'2400bc5f55dc4de4bf4010b096a363b7'),(446,'用来获取一个已被创建的JavaBean组件的属性值','',1,1,3,'692fa2e4a02240d4ae67db4b43738846'),(447,'在WAR文件中，web.xml放在哪个目录中','',1,1,3,'08b43969104a49748831686fe64ca7f5'),(448,'Servlet间完成协作，需要用到（ ）完成请求指派','',1,1,3,'a0740e1949324df8967947674f78a8ad'),(449,'JSP从HTML表单中获得用户输入的正确语句为','',1,1,3,'4fca9d0f4e4c4cf0bf42759d5bae04f9'),(450,'常用的上传邮件的协议是','',1,1,3,'aa1cfc50092d417abe01f2f721ef7e18'),(451,'关于sleep()和wait()，以下描述错误的一项是（ ）','',1,1,3,'e6ca12ed6b73477c8acacde5b107aa3d'),(452,'[多选]  在Session范围中以名称\"bean\"放置了一个JavaBean属性，JavaBean上有个 getMessage()方法，请问以下哪个方式呼叫getMessage()以取得讯息并显示出来？','',2,1,3,'ac3fb13976ff4aceb878cf7bf34bea9a'),(453,'在Java中，负责对字节代码解释执行的是   ','',1,1,3,'a8153429f5ff44d2913150981e776622'),(454,'有关线程的哪些叙述是对的（ ）','',2,1,3,'d6a48ad41ca84fc4815d11e72356c5ff'),(455,'Java I/O程序设计中，下列描述正确的是','',1,1,3,'2d7e4b98be4447198cb6f7080b602579'),(456,'关于Java语言，下列描述正确的是（多选）','',2,1,3,'18794fa8e8284c849c02f627d9b0a0c4'),(457,' 关于线程设计，下列描述正确的是','',1,1,3,'cac67d440e664fccbbe459011c0745a4'),(458,' 欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的','',1,1,3,'6acf1fb6a2d24cf99bf5fb8e7e985e49'),(459,'关于线程设计，下列描述正确的是','',1,1,3,'7fd1904f5e54463a8f74200a9467c5a8'),(460,'以下哪个命令用于测试网络连通。','',1,1,3,'ed7970d17171416c88057ae5ad29de22'),(461,'Java网络程序设计中，下列正确的描述是','',2,1,3,'2d7b877ae08340de919a5d60692c40eb'),(462,'下列哪些是J2EE的体系','',2,1,3,'f354fa95401c47ab813f0fb32eb643ad'),(463,'如何取得数据源。','',1,1,3,'565143c36d0e432c9355fb096ecd7768'),(464,'关于JSP生命周期的叙述，下列哪些为真？','',2,1,3,'2b171df85b4548e8bc6f46a0046e496e'),(465,'下面的那一个不属于MVC模式中的对象','',1,1,3,'8cef7b5b21a44874ac7af50a1d5a3382'),(466,'下面哪些属于JSTL中的表达式操作标签。(选择1项)','',1,1,3,'4d4a848543b74a708fd5df2230be027f'),(467,'关于面向对象的说法正确的是（  ）','',1,1,3,'2192b2013e7549b69fec9b9ff923bbed'),(468,'以下关于抽象类和接口的说法错误的是（  ）  ','',1,1,3,'13f5212a4f674d9bb151196a1025b471'),(469,'以下用于创建容器对象的类是（  ）（选择两项）','',2,1,3,'1b1cce5c6d044599b308511fc9a3597f'),(470,'以下关于布局的说法，错误的是（  ） ','',1,1,3,'830161e7efa54937bdcc92bacb9c5872'),(471,'在JAVA中ArrayList类实现了可变大小的数组，便于遍历元素和随机访问元素，已知 获得了ArrayList类的对象bookTypeList，则下列语句中能够实现判断列表中是否存在','',1,1,3,'71be85c182a743448e1dc392bb039ce9'),(472,'分析选项中关于Java中this关键字的说法正确的是（  ）','',1,1,3,'3f49c7cd34bc4f0e9e9a18e4a26e455b'),(473,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,1,3,'27c717cb8a19469e882a2922a6c5ea52'),(474,'Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）','',1,1,3,'b69a22c014584bcb9fff5fb141adb006'),(475,'下列选项中关于Java中封装的说法错误的是（ ）。 ','',1,1,3,'52f1b9db3e734f44b3743bd780ed0857'),(476,'在JAVA中，Object类是所有类的父亲，用户自定义类默认扩展自Object类，下列选项 中的（  ）方法不属于Object类的方法。','',1,1,3,'bfb3410b1a8c4929bd2a01237b55913f'),(477,'在JAVA的异常处理模型中，能单独和finally语句一起使用的块是（ ）','',1,1,3,'40d9c0a463fc40a69a807c2eb3ad6463'),(478,'在Java接口中，下列选项中有效的方法声明是（  ）。（选择二项） ','',2,1,3,'c0d7f49739dd4e849e7bdac0055c1a48'),(479,'下列选项中关于Java中super关键字的说法正确的是（ ）','',1,1,3,'14cca6e3ef854bb397efb0aadfa31d63'),(480,'在Java语言中，下列关于类的继承的描述，正确的是（ ）','',1,1,3,'165a378ebfc2416e8a266ab7b018e38a'),(481,'在Java中，下面对于构造函数的描述错误的是（  ）（选择两项）','',2,1,3,'f48e3a6fc8c14a648b1ccf860b763de5'),(482,'下面关于OPM的说法不正确的是','',1,1,3,'ac4bd20ee9304f189869a40ff0cefcc1'),(483,'spring能管理的组件不包括','',1,1,3,'4ff77a9c28be4d87a040673fcd90093e'),(484,'在J2EE中，request对象的方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据','',1,1,3,'c6418c4b353e493bb8d55f67780021aa'),(485,'在J2EE中，test.jsp文件中有如下一行代码：\n<jsp:useBean id=”user”scope=”_”type=”com.UserBean”/>要使user对象只能在使用test.jsp时使用，当加载页面时就会将其销毁','',1,1,3,'e64ba6758d30412d9215cec1b30a7b54'),(486,'要设计一个大型的基于多层体系结构的web应用系统，系统界面端基于HTML和XML，该系统要不断的进行版级（即日后维护、二次需求开发等任务量较大），要达成这些目标，最适合的开发模式是','',1,1,3,'cf95fb31e0564b258377783cb70616bf'),(487,'在J2EE中，使用Servlet过滤器时，需要在web.xml通过（B）元素将过滤器映射到Web资源。','',1,1,3,'d9b2686b63344450ab2a1ef25f804b3a'),(488,'在J2EE的Model II模式中，模型层对象被编写为','',1,1,3,'56ac150c7fe9491f8f97c155e1e7435d'),(489,'J2EE中，()类的（）方法用于返回应用程序的上下文路径。','',1,1,3,'d43078beda5a41d8b59bea9ac51fde20'),(490,'Web应用中，常用的会话跟踪方法不包括','',1,1,3,'35eef0aa148a4aaabe115630208f097f'),(491,'给顶一个JSP程序源代码，如下：\n<jsp:include page=\"two.jsp\" flush=\"true\">\n<jsp:param name=\"location\" value=\"bejing\"/>\n</jsp:include>在two.jsp中使用（）代码片段可以输出参数location的值。','',1,1,3,'d4deecb7a92445a2bad722ceebd734db'),(492,'JavaMail是一组用于发送和接收邮件消息的API。发送邮件使用（）协议，接收邮件使用（）协议','',1,1,3,'8659e8558057407d916ac46c076ddeb6'),(493,'在J2EE中，在一个JSP文件中，有表达式<%=2+3 %>，它将输出（ ）','',1,1,3,'12a8af5c01bc48a9984ffe9f4ba1dd9d'),(494,'在JSP中，（）动作用于将请求转发给其他JSP页面','',1,1,3,'f5278b6690224ca8ba8451a1d42e4f50'),(495,'在J2EE实现企业级应用开发中，（ ）是描述标记库的XML文档','',1,1,3,'749c0a104669457aa2450dc93c950956'),(496,'用来获取一个已被创建的JavaBean组件的属性值','',1,1,3,'5cef17afc56a4eae9c7d97da884a7bca'),(497,'在WAR文件中，web.xml放在哪个目录中','',1,1,3,'52f0938d4e4041a39392ddae83dadbb7'),(498,'Servlet间完成协作，需要用到（ ）完成请求指派','',1,1,3,'d737d9ef20c1446984d3fe682ba1c0b5'),(499,'JSP从HTML表单中获得用户输入的正确语句为','',1,1,3,'33fb760f316141f495bb943994f95b55'),(500,'常用的上传邮件的协议是','',1,1,3,'19d9fcd308024a9180cc1d9d609bfaef'),(501,'关于sleep()和wait()，以下描述错误的一项是（ ）','',1,1,3,'01556a776dec4646a19fdb1c64e55ae7'),(502,'[多选]  在Session范围中以名称\"bean\"放置了一个JavaBean属性，JavaBean上有个 getMessage()方法，请问以下哪个方式呼叫getMessage()以取得讯息并显示出来？','',2,1,3,'6fd9c534cbf5458f88d17c3929e17f1a'),(503,'在Java中，负责对字节代码解释执行的是   ','',1,1,3,'f19e6b62a94b4f9aafcd60145297e9e7'),(504,'有关线程的哪些叙述是对的（ ）','',2,1,3,'265d006e5daa4440800685aab785c0c0'),(505,'Java I/O程序设计中，下列描述正确的是','',1,1,3,'4e1f1f6dcba9443091927b560c6f4f0e'),(506,'关于Java语言，下列描述正确的是（多选）','',2,1,3,'6214b31fd5df4d2686b2e12e705795bb'),(507,' 关于线程设计，下列描述正确的是','',1,1,3,'32ef4289799a4ed39203b2d66108fbc6'),(508,' 欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的','',1,1,3,'d2210e77b3214dd29100626b79a5dc1a'),(509,'关于线程设计，下列描述正确的是','',1,1,3,'fb0710342c554d65803f72dbb2e6a66f'),(510,'以下哪个命令用于测试网络连通。','',1,1,3,'0499715fdfe642a79268a904d2ac3a97'),(511,'Java网络程序设计中，下列正确的描述是','',2,1,3,'6754cad30abd4c40a38424cd0fe79c2f'),(512,'下列哪些是J2EE的体系','',2,1,3,'1450df9964fd47a68c02488519c85338'),(513,'如何取得数据源。','',1,1,3,'f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(514,'关于JSP生命周期的叙述，下列哪些为真？','',2,1,3,'81d0fb9e895c45468c3031afacb1e19b'),(515,'下面的那一个不属于MVC模式中的对象','',1,1,3,'cb9865c857a341d9a38b9005310e9d04'),(516,'下面哪些属于JSTL中的表达式操作标签。(选择1项)','',1,1,3,'56fb35cb35364282929fbb24c5bf453a');

/*Table structure for table `Questions_option` */

DROP TABLE IF EXISTS `Questions_option`;

CREATE TABLE `Questions_option` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `lable` varchar(10) NOT NULL COMMENT '选项标签',
  `context` varchar(500) NOT NULL COMMENT '选项内容',
  `uid` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2081 DEFAULT CHARSET=utf8 COMMENT='题干选项表';

/*Data for the table `Questions_option` */

insert  into `Questions_option`(`id`,`lable`,`context`,`uid`) values (193,'a','编译错误 ','57a446633a6543388814b664cc005444'),(194,'b','程序可以通过编译，运行后文件company.txt没有任何改变','57a446633a6543388814b664cc005444'),(195,'c','程序可以通过编译，运行后文件company.txt的长度变为0','57a446633a6543388814b664cc005444'),(196,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','57a446633a6543388814b664cc005444'),(197,'a','编译错误 ','55037bdaaef44631936cccd2070f04ab'),(198,'b','实现向文件record.dat追加写入字符a ','55037bdaaef44631936cccd2070f04ab'),(199,'c','实现向文件record.dat覆盖写入字符a ','55037bdaaef44631936cccd2070f04ab'),(200,'d','文件record.dat无任何内容 ','55037bdaaef44631936cccd2070f04ab'),(201,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','22ef1cce8ae64e92b08dd789dfb27419'),(202,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','22ef1cce8ae64e92b08dd789dfb27419'),(203,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','22ef1cce8ae64e92b08dd789dfb27419'),(204,'d','new InputStreamReader(\"1.dat\") ; ','22ef1cce8ae64e92b08dd789dfb27419'),(205,'a','编译错误 ','3645ee7246f34091a6d3d0ef22c49c00'),(206,'b','实现向文件record.dat追加写入字符a ','3645ee7246f34091a6d3d0ef22c49c00'),(207,'c','实现向文件record.dat覆盖写入字符a ','3645ee7246f34091a6d3d0ef22c49c00'),(208,'d','文件record.dat无任何内容 ','3645ee7246f34091a6d3d0ef22c49c00'),(209,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','267f4a4ba6934a39ab9e1689283ff7fb'),(210,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','267f4a4ba6934a39ab9e1689283ff7fb'),(211,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','267f4a4ba6934a39ab9e1689283ff7fb'),(212,'d','new InputStreamReader(\"dat\") ; ','267f4a4ba6934a39ab9e1689283ff7fb'),(213,'a','InputStreamReader','aa881d921b0544be89a86d369dc3056a'),(214,'b','BufferedReader','aa881d921b0544be89a86d369dc3056a'),(215,'c','FileInputStream','aa881d921b0544be89a86d369dc3056a'),(216,'d','InputStream','aa881d921b0544be89a86d369dc3056a'),(217,'a','输出：test ','4769b8c5f68f4f2eb98af9f64b01292c'),(218,'b','输出：Exception ','4769b8c5f68f4f2eb98af9f64b01292c'),(219,'c','编译失败 ','4769b8c5f68f4f2eb98af9f64b01292c'),(220,'d','输出：NullPointerException ','4769b8c5f68f4f2eb98af9f64b01292c'),(221,'a','第3行抛出异常 ','1c1b1268552d44828a9592f15a20627d'),(222,'b','第1行抛出异常 ','1c1b1268552d44828a9592f15a20627d'),(223,'c','第5行抛出异常 ','1c1b1268552d44828a9592f15a20627d'),(224,'d','第3行代码成功执行 ','1c1b1268552d44828a9592f15a20627d'),(225,'a','输出：4 ','e6aa897d8ff442a68dc5fa753bc6afed'),(226,'b','在运行时抛出NullPointerException异常 ','e6aa897d8ff442a68dc5fa753bc6afed'),(227,'c','在运行时抛出NumberFormatException异常 ','e6aa897d8ff442a68dc5fa753bc6afed'),(228,'d','在运行时抛出IllegalStateException异常 ','e6aa897d8ff442a68dc5fa753bc6afed'),(229,'a','sleep方法 ','c55b2d9f4e994f94a0d9110f8abf8450'),(230,'b','IO等待 ','c55b2d9f4e994f94a0d9110f8abf8450'),(231,'c','yield方法 ','c55b2d9f4e994f94a0d9110f8abf8450'),(232,'d','wait方法 ','c55b2d9f4e994f94a0d9110f8abf8450'),(233,'a','名为dtThread的线程为守护线程 ','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(234,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(235,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(236,'d','main线程是守护线程 ','7bdda4a7cfdf493b9b1dac7bd1f4185b'),(237,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','9370fff49d4840369fb3da6af52ef496'),(238,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','9370fff49d4840369fb3da6af52ef496'),(239,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','9370fff49d4840369fb3da6af52ef496'),(240,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','9370fff49d4840369fb3da6af52ef496'),(241,'a','编译错误 ','92c286733e354108bc40d94fe32414e2'),(242,'b','抛出运行时异常 ','92c286733e354108bc40d94fe32414e2'),(243,'c','输出：bar ','92c286733e354108bc40d94fe32414e2'),(244,'d','代码正常运行，但是无输出 ','92c286733e354108bc40d94fe32414e2'),(245,'a','编译错误 ','6dd4b94cae584048a78ef2856d6f3985'),(246,'b','抛出运行时异常 ','6dd4b94cae584048a78ef2856d6f3985'),(247,'c','输出：sleep ','6dd4b94cae584048a78ef2856d6f3985'),(248,'d','代码正常运行，但是无输出 ','6dd4b94cae584048a78ef2856d6f3985'),(249,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','6fed36f8c2664e888fdbad4481f64cab'),(250,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','6fed36f8c2664e888fdbad4481f64cab'),(251,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','6fed36f8c2664e888fdbad4481f64cab'),(252,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','6fed36f8c2664e888fdbad4481f64cab'),(253,'a','private synchronized Object o; ','5d58d18f32e14553ad1b129049bae92d'),(254,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','5d58d18f32e14553ad1b129049bae92d'),(255,'c','public synchronized void go() { /* code here */ } ','5d58d18f32e14553ad1b129049bae92d'),(256,'d','private synchronized(this) void go() { /* code here */ } ','5d58d18f32e14553ad1b129049bae92d'),(257,'a','输出Exception ','89e81dca7dbe48e395cb97dff26e5b66'),(258,'b','输出A,B,Exception ','89e81dca7dbe48e395cb97dff26e5b66'),(259,'c','编译失败 ','89e81dca7dbe48e395cb97dff26e5b66'),(260,'d','在运行时抛出NullPointerException异常 ','89e81dca7dbe48e395cb97dff26e5b66'),(261,'a','public void method( int m){...}     ','972c3583242545488cce4cd741865238'),(262,'b','public int method(){...} ','972c3583242545488cce4cd741865238'),(263,'c','public void method2(){...}    ','972c3583242545488cce4cd741865238'),(264,'d','public int method(int m，float f ){...} ','972c3583242545488cce4cd741865238'),(265,'a','s>>>=3   ','9b98e4a9feef437aa187ae9285477fc7'),(266,'b','s[3]= “X”  ','9b98e4a9feef437aa187ae9285477fc7'),(267,'c','int i = s.length()   ','9b98e4a9feef437aa187ae9285477fc7'),(268,'d','s = s + 10 ','9b98e4a9feef437aa187ae9285477fc7'),(269,'a','const   ','5f960859db894c6cb7f71999401b4ddd'),(270,'b','NULL  ','5f960859db894c6cb7f71999401b4ddd'),(271,'c','false   ','5f960859db894c6cb7f71999401b4ddd'),(272,'d','this  ','5f960859db894c6cb7f71999401b4ddd'),(273,'a','m.length()    ','7809e2eac65449e9a7908838242ec00c'),(274,'b','m.length   ','7809e2eac65449e9a7908838242ec00c'),(275,'c','m.length()+1   ','7809e2eac65449e9a7908838242ec00c'),(276,'d','m.length-1','7809e2eac65449e9a7908838242ec00c'),(277,'a','通过调用stop()方法而停止的线程。 ','2d256d0fbedb44e281b16ece605f1038'),(278,'b','通过调用sleep()方法而停止的线程。 ','2d256d0fbedb44e281b16ece605f1038'),(279,'c','通过调用wait()方法而停止的线程。 ','2d256d0fbedb44e281b16ece605f1038'),(280,'d','通过调用suspend()方法而停止的线程。 ','2d256d0fbedb44e281b16ece605f1038'),(281,'a','一旦一个线程被创建，它就立即开始运行。  ','f0d0e20f35ea4b0380142dd997f77192'),(282,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','f0d0e20f35ea4b0380142dd997f77192'),(283,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','f0d0e20f35ea4b0380142dd997f77192'),(284,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','f0d0e20f35ea4b0380142dd997f77192'),(285,'a','Output is null.             ','cebc951416ec45a581a571570054eb91'),(286,'b','Output is 0 ','cebc951416ec45a581a571570054eb91'),(287,'c','编译时报错 ','cebc951416ec45a581a571570054eb91'),(288,'d','运行时报错','cebc951416ec45a581a571570054eb91'),(289,'a','5.0','d949a72652944528ba271a4a158d1c6d'),(290,'b','4.0','d949a72652944528ba271a4a158d1c6d'),(291,'c','6.0','d949a72652944528ba271a4a158d1c6d'),(292,'d','finished','d949a72652944528ba271a4a158d1c6d'),(293,'a','long 1 = 4990  ','5e1321e3ee05405f864afcccf88e1561'),(294,'b','int i = 4L  ','5e1321e3ee05405f864afcccf88e1561'),(295,'c','float f =1.1  ','5e1321e3ee05405f864afcccf88e1561'),(296,'d','double d = 34.4','5e1321e3ee05405f864afcccf88e1561'),(297,'a','将private int m改为 protected int m  ','8e4dd2ebe2bb491e8a337134269185d7'),(298,'b','将private int m改为 public int m    ','8e4dd2ebe2bb491e8a337134269185d7'),(299,'c','将private int m改为 static int m     ','8e4dd2ebe2bb491e8a337134269185d7'),(300,'d','将private int m改为int m ','8e4dd2ebe2bb491e8a337134269185d7'),(301,'a','start()    ','c93f3ad8c6b8437ab845966e87047389'),(302,'b','init()    ','c93f3ad8c6b8437ab845966e87047389'),(303,'c','run()    ','c93f3ad8c6b8437ab845966e87047389'),(304,'d','main()  ','c93f3ad8c6b8437ab845966e87047389'),(305,'a','栈是非线性结构        ','8741da9946ed44a68ed855f8382d2636'),(306,'b','栈是一种树状结构 ','8741da9946ed44a68ed855f8382d2636'),(307,'c','栈具有先进先出的特征  ','8741da9946ed44a68ed855f8382d2636'),(308,'d','栈具有后进先出的特征 ','8741da9946ed44a68ed855f8382d2636'),(309,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','3ec3f60955b748b8997cfc38ff39f2ff'),(310,'b','垃圾收集将检查并释放不在使用的内存  ','3ec3f60955b748b8997cfc38ff39f2ff'),(311,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','3ec3f60955b748b8997cfc38ff39f2ff'),(312,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','3ec3f60955b748b8997cfc38ff39f2ff'),(313,'a','编译错误 ','499734536a7d4480b8f559529f0bbf84'),(314,'b','程序可以通过编译，运行后文件company.txt没有任何改变','499734536a7d4480b8f559529f0bbf84'),(315,'c','程序可以通过编译，运行后文件company.txt的长度变为0','499734536a7d4480b8f559529f0bbf84'),(316,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','499734536a7d4480b8f559529f0bbf84'),(317,'a','编译错误 ','0b6d0f7622c94306984880a7705e3f52'),(318,'b','实现向文件record.dat追加写入字符a ','0b6d0f7622c94306984880a7705e3f52'),(319,'c','实现向文件record.dat覆盖写入字符a ','0b6d0f7622c94306984880a7705e3f52'),(320,'d','文件record.dat无任何内容 ','0b6d0f7622c94306984880a7705e3f52'),(321,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','95cd6ab3b6474300a8d1d538693a2f6d'),(322,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','95cd6ab3b6474300a8d1d538693a2f6d'),(323,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','95cd6ab3b6474300a8d1d538693a2f6d'),(324,'d','new InputStreamReader(\"1.dat\") ; ','95cd6ab3b6474300a8d1d538693a2f6d'),(325,'a','编译错误 ','0979470ddbeb48b48cfa1e1bcf745dd8'),(326,'b','实现向文件record.dat追加写入字符a ','0979470ddbeb48b48cfa1e1bcf745dd8'),(327,'c','实现向文件record.dat覆盖写入字符a ','0979470ddbeb48b48cfa1e1bcf745dd8'),(328,'d','文件record.dat无任何内容 ','0979470ddbeb48b48cfa1e1bcf745dd8'),(329,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','9989bc85a76d493d995b0ecca1fceed7'),(330,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','9989bc85a76d493d995b0ecca1fceed7'),(331,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','9989bc85a76d493d995b0ecca1fceed7'),(332,'d','new InputStreamReader(\"dat\") ; ','9989bc85a76d493d995b0ecca1fceed7'),(333,'a','InputStreamReader','36fb429d6a2640439157181b616a9ea7'),(334,'b','BufferedReader','36fb429d6a2640439157181b616a9ea7'),(335,'c','FileInputStream','36fb429d6a2640439157181b616a9ea7'),(336,'d','InputStream','36fb429d6a2640439157181b616a9ea7'),(337,'a','输出：test ','b274216832dc491894a7dde1e8efb55c'),(338,'b','输出：Exception ','b274216832dc491894a7dde1e8efb55c'),(339,'c','编译失败 ','b274216832dc491894a7dde1e8efb55c'),(340,'d','输出：NullPointerException ','b274216832dc491894a7dde1e8efb55c'),(341,'a','第3行抛出异常 ','93b80d394be34783b5680e434f4fac49'),(342,'b','第1行抛出异常 ','93b80d394be34783b5680e434f4fac49'),(343,'c','第5行抛出异常 ','93b80d394be34783b5680e434f4fac49'),(344,'d','第3行代码成功执行 ','93b80d394be34783b5680e434f4fac49'),(345,'a','输出：4 ','3a37b9da03f14621b47008338bc71499'),(346,'b','在运行时抛出NullPointerException异常 ','3a37b9da03f14621b47008338bc71499'),(347,'c','在运行时抛出NumberFormatException异常 ','3a37b9da03f14621b47008338bc71499'),(348,'d','在运行时抛出IllegalStateException异常 ','3a37b9da03f14621b47008338bc71499'),(349,'a','sleep方法 ','62fa88ad8f174e589724bef4bbe9bbe4'),(350,'b','IO等待 ','62fa88ad8f174e589724bef4bbe9bbe4'),(351,'c','yield方法 ','62fa88ad8f174e589724bef4bbe9bbe4'),(352,'d','wait方法 ','62fa88ad8f174e589724bef4bbe9bbe4'),(353,'a','名为dtThread的线程为守护线程 ','4145219dfc5a4401817b8d76d75f8375'),(354,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','4145219dfc5a4401817b8d76d75f8375'),(355,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','4145219dfc5a4401817b8d76d75f8375'),(356,'d','main线程是守护线程 ','4145219dfc5a4401817b8d76d75f8375'),(357,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','9c73cd4bd6a5494bab18e450b009a173'),(358,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','9c73cd4bd6a5494bab18e450b009a173'),(359,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','9c73cd4bd6a5494bab18e450b009a173'),(360,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','9c73cd4bd6a5494bab18e450b009a173'),(361,'a','编译错误 ','492965ba58284f66b9e060f26a86ae77'),(362,'b','抛出运行时异常 ','492965ba58284f66b9e060f26a86ae77'),(363,'c','输出：bar ','492965ba58284f66b9e060f26a86ae77'),(364,'d','代码正常运行，但是无输出 ','492965ba58284f66b9e060f26a86ae77'),(365,'a','编译错误 ','863ecfd1ec414fcf99a4f0b630b6246a'),(366,'b','抛出运行时异常 ','863ecfd1ec414fcf99a4f0b630b6246a'),(367,'c','输出：sleep ','863ecfd1ec414fcf99a4f0b630b6246a'),(368,'d','代码正常运行，但是无输出 ','863ecfd1ec414fcf99a4f0b630b6246a'),(369,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','eed7ac52082c45698fb2a1faa9226c03'),(370,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','eed7ac52082c45698fb2a1faa9226c03'),(371,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','eed7ac52082c45698fb2a1faa9226c03'),(372,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','eed7ac52082c45698fb2a1faa9226c03'),(373,'a','private synchronized Object o; ','0e4f199c7af84262a55896d26c16a82b'),(374,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','0e4f199c7af84262a55896d26c16a82b'),(375,'c','public synchronized void go() { /* code here */ } ','0e4f199c7af84262a55896d26c16a82b'),(376,'d','private synchronized(this) void go() { /* code here */ } ','0e4f199c7af84262a55896d26c16a82b'),(377,'a','输出Exception ','bc12d383722541cdaebba3d3346c0d50'),(378,'b','输出A,B,Exception ','bc12d383722541cdaebba3d3346c0d50'),(379,'c','编译失败 ','bc12d383722541cdaebba3d3346c0d50'),(380,'d','在运行时抛出NullPointerException异常 ','bc12d383722541cdaebba3d3346c0d50'),(381,'a','public void method( int m){...}     ','3238392cfa5b4c7d937643e0f7f42bf7'),(382,'b','public int method(){...} ','3238392cfa5b4c7d937643e0f7f42bf7'),(383,'c','public void method2(){...}    ','3238392cfa5b4c7d937643e0f7f42bf7'),(384,'d','public int method(int m，float f ){...} ','3238392cfa5b4c7d937643e0f7f42bf7'),(385,'a','s>>>=3   ','2b81c8093fe54987a91b26fd4403e9e8'),(386,'b','s[3]= “X”  ','2b81c8093fe54987a91b26fd4403e9e8'),(387,'c','int i = s.length()   ','2b81c8093fe54987a91b26fd4403e9e8'),(388,'d','s = s + 10 ','2b81c8093fe54987a91b26fd4403e9e8'),(389,'a','const   ','28969610f88e44b6999619bf01f9e3b1'),(390,'b','NULL  ','28969610f88e44b6999619bf01f9e3b1'),(391,'c','false   ','28969610f88e44b6999619bf01f9e3b1'),(392,'d','this  ','28969610f88e44b6999619bf01f9e3b1'),(393,'a','m.length()    ','86bb4f81334240a78457025ba9608e98'),(394,'b','m.length   ','86bb4f81334240a78457025ba9608e98'),(395,'c','m.length()+1   ','86bb4f81334240a78457025ba9608e98'),(396,'d','m.length-1','86bb4f81334240a78457025ba9608e98'),(397,'a','通过调用stop()方法而停止的线程。 ','a2fe8e7903b64e5f9d6ef268f9e2de8f'),(398,'b','通过调用sleep()方法而停止的线程。 ','a2fe8e7903b64e5f9d6ef268f9e2de8f'),(399,'c','通过调用wait()方法而停止的线程。 ','a2fe8e7903b64e5f9d6ef268f9e2de8f'),(400,'d','通过调用suspend()方法而停止的线程。 ','a2fe8e7903b64e5f9d6ef268f9e2de8f'),(401,'a','一旦一个线程被创建，它就立即开始运行。  ','9bcfddb168b54e75854cd978b0a70bda'),(402,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','9bcfddb168b54e75854cd978b0a70bda'),(403,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','9bcfddb168b54e75854cd978b0a70bda'),(404,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','9bcfddb168b54e75854cd978b0a70bda'),(405,'a','Output is null.             ','c64a03ee9ceb44349a03e8d236f047f0'),(406,'b','Output is 0 ','c64a03ee9ceb44349a03e8d236f047f0'),(407,'c','编译时报错 ','c64a03ee9ceb44349a03e8d236f047f0'),(408,'d','运行时报错','c64a03ee9ceb44349a03e8d236f047f0'),(409,'a','5.0','4f48062a0cce415d834aec73a3b8032a'),(410,'b','4.0','4f48062a0cce415d834aec73a3b8032a'),(411,'c','6.0','4f48062a0cce415d834aec73a3b8032a'),(412,'d','finished','4f48062a0cce415d834aec73a3b8032a'),(413,'a','long 1 = 4990  ','60232efc41d24e6b84c16e090c6d6084'),(414,'b','int i = 4L  ','60232efc41d24e6b84c16e090c6d6084'),(415,'c','float f =1.1  ','60232efc41d24e6b84c16e090c6d6084'),(416,'d','double d = 34.4','60232efc41d24e6b84c16e090c6d6084'),(417,'a','将private int m改为 protected int m  ','35809ebfca43434f9665f850c113cf89'),(418,'b','将private int m改为 public int m    ','35809ebfca43434f9665f850c113cf89'),(419,'c','将private int m改为 static int m     ','35809ebfca43434f9665f850c113cf89'),(420,'d','将private int m改为int m ','35809ebfca43434f9665f850c113cf89'),(421,'a','start()    ','a27fb10053e749e993319b790609ceaf'),(422,'b','init()    ','a27fb10053e749e993319b790609ceaf'),(423,'c','run()    ','a27fb10053e749e993319b790609ceaf'),(424,'d','main()  ','a27fb10053e749e993319b790609ceaf'),(425,'a','栈是非线性结构        ','550b31d98e6f4c9797f18e880b8bd302'),(426,'b','栈是一种树状结构 ','550b31d98e6f4c9797f18e880b8bd302'),(427,'c','栈具有先进先出的特征  ','550b31d98e6f4c9797f18e880b8bd302'),(428,'d','栈具有后进先出的特征 ','550b31d98e6f4c9797f18e880b8bd302'),(429,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','8a7b8c9d1cc642e585302438d2d30493'),(430,'b','垃圾收集将检查并释放不在使用的内存  ','8a7b8c9d1cc642e585302438d2d30493'),(431,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','8a7b8c9d1cc642e585302438d2d30493'),(432,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','8a7b8c9d1cc642e585302438d2d30493'),(433,'a','编译错误 ','2782e588436842a5a8716f2a471d10c5'),(434,'b','程序可以通过编译，运行后文件company.txt没有任何改变','2782e588436842a5a8716f2a471d10c5'),(435,'c','程序可以通过编译，运行后文件company.txt的长度变为0','2782e588436842a5a8716f2a471d10c5'),(436,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','2782e588436842a5a8716f2a471d10c5'),(437,'a','编译错误 ','3f5f216a67d64b18aae9896095d3b2c1'),(438,'b','实现向文件record.dat追加写入字符a ','3f5f216a67d64b18aae9896095d3b2c1'),(439,'c','实现向文件record.dat覆盖写入字符a ','3f5f216a67d64b18aae9896095d3b2c1'),(440,'d','文件record.dat无任何内容 ','3f5f216a67d64b18aae9896095d3b2c1'),(441,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','77e73195b8784e1dad06be125fcf31fb'),(442,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','77e73195b8784e1dad06be125fcf31fb'),(443,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','77e73195b8784e1dad06be125fcf31fb'),(444,'d','new InputStreamReader(\"1.dat\") ; ','77e73195b8784e1dad06be125fcf31fb'),(445,'a','编译错误 ','07f2483d79f0423ebd67148b6017ae6e'),(446,'b','实现向文件record.dat追加写入字符a ','07f2483d79f0423ebd67148b6017ae6e'),(447,'c','实现向文件record.dat覆盖写入字符a ','07f2483d79f0423ebd67148b6017ae6e'),(448,'d','文件record.dat无任何内容 ','07f2483d79f0423ebd67148b6017ae6e'),(449,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','f97c0d5325ac4ef09a346f02edc3a103'),(450,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','f97c0d5325ac4ef09a346f02edc3a103'),(451,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','f97c0d5325ac4ef09a346f02edc3a103'),(452,'d','new InputStreamReader(\"dat\") ; ','f97c0d5325ac4ef09a346f02edc3a103'),(453,'a','InputStreamReader','9357c6c525e94fa2a931dfc2710ffd1e'),(454,'b','BufferedReader','9357c6c525e94fa2a931dfc2710ffd1e'),(455,'c','FileInputStream','9357c6c525e94fa2a931dfc2710ffd1e'),(456,'d','InputStream','9357c6c525e94fa2a931dfc2710ffd1e'),(457,'a','输出：test ','341e7a5771274518b3dfc3adf2808e2f'),(458,'b','输出：Exception ','341e7a5771274518b3dfc3adf2808e2f'),(459,'c','编译失败 ','341e7a5771274518b3dfc3adf2808e2f'),(460,'d','输出：NullPointerException ','341e7a5771274518b3dfc3adf2808e2f'),(461,'a','第3行抛出异常 ','8e97bb261db94e30a0f6b6e0a0618fc6'),(462,'b','第1行抛出异常 ','8e97bb261db94e30a0f6b6e0a0618fc6'),(463,'c','第5行抛出异常 ','8e97bb261db94e30a0f6b6e0a0618fc6'),(464,'d','第3行代码成功执行 ','8e97bb261db94e30a0f6b6e0a0618fc6'),(465,'a','输出：4 ','8f55f67b36b247598224fed4da7ec555'),(466,'b','在运行时抛出NullPointerException异常 ','8f55f67b36b247598224fed4da7ec555'),(467,'c','在运行时抛出NumberFormatException异常 ','8f55f67b36b247598224fed4da7ec555'),(468,'d','在运行时抛出IllegalStateException异常 ','8f55f67b36b247598224fed4da7ec555'),(469,'a','sleep方法 ','98dbb42cad2844dbbeebf25cc5a832bf'),(470,'b','IO等待 ','98dbb42cad2844dbbeebf25cc5a832bf'),(471,'c','yield方法 ','98dbb42cad2844dbbeebf25cc5a832bf'),(472,'d','wait方法 ','98dbb42cad2844dbbeebf25cc5a832bf'),(473,'a','名为dtThread的线程为守护线程 ','8311c749320742aeb43ec1bf98ec2a8b'),(474,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','8311c749320742aeb43ec1bf98ec2a8b'),(475,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','8311c749320742aeb43ec1bf98ec2a8b'),(476,'d','main线程是守护线程 ','8311c749320742aeb43ec1bf98ec2a8b'),(477,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','87de338fb2af462b892f5e05f3ffdf38'),(478,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','87de338fb2af462b892f5e05f3ffdf38'),(479,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','87de338fb2af462b892f5e05f3ffdf38'),(480,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','87de338fb2af462b892f5e05f3ffdf38'),(481,'a','编译错误 ','51ef8657b9ed434195789a21d09b8289'),(482,'b','抛出运行时异常 ','51ef8657b9ed434195789a21d09b8289'),(483,'c','输出：bar ','51ef8657b9ed434195789a21d09b8289'),(484,'d','代码正常运行，但是无输出 ','51ef8657b9ed434195789a21d09b8289'),(485,'a','编译错误 ','8427a07b308141a39429a197a90c9feb'),(486,'b','抛出运行时异常 ','8427a07b308141a39429a197a90c9feb'),(487,'c','输出：sleep ','8427a07b308141a39429a197a90c9feb'),(488,'d','代码正常运行，但是无输出 ','8427a07b308141a39429a197a90c9feb'),(489,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','37bb6ee2315a46b1959267772d30997b'),(490,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','37bb6ee2315a46b1959267772d30997b'),(491,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','37bb6ee2315a46b1959267772d30997b'),(492,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','37bb6ee2315a46b1959267772d30997b'),(493,'a','private synchronized Object o; ','291ef4d1ff63464492b8a5e5ded212e0'),(494,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','291ef4d1ff63464492b8a5e5ded212e0'),(495,'c','public synchronized void go() { /* code here */ } ','291ef4d1ff63464492b8a5e5ded212e0'),(496,'d','private synchronized(this) void go() { /* code here */ } ','291ef4d1ff63464492b8a5e5ded212e0'),(497,'a','输出Exception ','2040e52b11a044afa768f8611400f2f5'),(498,'b','输出A,B,Exception ','2040e52b11a044afa768f8611400f2f5'),(499,'c','编译失败 ','2040e52b11a044afa768f8611400f2f5'),(500,'d','在运行时抛出NullPointerException异常 ','2040e52b11a044afa768f8611400f2f5'),(501,'a','public void method( int m){...}     ','54d4cda3c7ff4e709ffe37ae2a179585'),(502,'b','public int method(){...} ','54d4cda3c7ff4e709ffe37ae2a179585'),(503,'c','public void method2(){...}    ','54d4cda3c7ff4e709ffe37ae2a179585'),(504,'d','public int method(int m，float f ){...} ','54d4cda3c7ff4e709ffe37ae2a179585'),(505,'a','s>>>=3   ','4521998d5492452a937a663597e4e46e'),(506,'b','s[3]= “X”  ','4521998d5492452a937a663597e4e46e'),(507,'c','int i = s.length()   ','4521998d5492452a937a663597e4e46e'),(508,'d','s = s + 10 ','4521998d5492452a937a663597e4e46e'),(509,'a','const   ','56e4b65b31f5412a8aef245a2b659a4f'),(510,'b','NULL  ','56e4b65b31f5412a8aef245a2b659a4f'),(511,'c','false   ','56e4b65b31f5412a8aef245a2b659a4f'),(512,'d','this  ','56e4b65b31f5412a8aef245a2b659a4f'),(513,'a','m.length()    ','ebecab2c5c6242da8864cae19ed65c9b'),(514,'b','m.length   ','ebecab2c5c6242da8864cae19ed65c9b'),(515,'c','m.length()+1   ','ebecab2c5c6242da8864cae19ed65c9b'),(516,'d','m.length-1','ebecab2c5c6242da8864cae19ed65c9b'),(517,'a','通过调用stop()方法而停止的线程。 ','ba7a7a03af724bd2aab7130cf1b6d98f'),(518,'b','通过调用sleep()方法而停止的线程。 ','ba7a7a03af724bd2aab7130cf1b6d98f'),(519,'c','通过调用wait()方法而停止的线程。 ','ba7a7a03af724bd2aab7130cf1b6d98f'),(520,'d','通过调用suspend()方法而停止的线程。 ','ba7a7a03af724bd2aab7130cf1b6d98f'),(521,'a','一旦一个线程被创建，它就立即开始运行。  ','dcce0330928c42b099dbcf44aa55d367'),(522,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','dcce0330928c42b099dbcf44aa55d367'),(523,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','dcce0330928c42b099dbcf44aa55d367'),(524,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','dcce0330928c42b099dbcf44aa55d367'),(525,'a','Output is null.             ','b96fb1ebe7d04e5da20d20677e03a772'),(526,'b','Output is 0 ','b96fb1ebe7d04e5da20d20677e03a772'),(527,'c','编译时报错 ','b96fb1ebe7d04e5da20d20677e03a772'),(528,'d','运行时报错','b96fb1ebe7d04e5da20d20677e03a772'),(529,'a','5.0','9ee58f1d252b488c8d3503d3257e0489'),(530,'b','4.0','9ee58f1d252b488c8d3503d3257e0489'),(531,'c','6.0','9ee58f1d252b488c8d3503d3257e0489'),(532,'d','finished','9ee58f1d252b488c8d3503d3257e0489'),(533,'a','long 1 = 4990  ','589f85365953474c9dc4316d764006d1'),(534,'b','int i = 4L  ','589f85365953474c9dc4316d764006d1'),(535,'c','float f =1.1  ','589f85365953474c9dc4316d764006d1'),(536,'d','double d = 34.4','589f85365953474c9dc4316d764006d1'),(537,'a','将private int m改为 protected int m  ','8d216f38f0c44bf688d354beed1b6866'),(538,'b','将private int m改为 public int m    ','8d216f38f0c44bf688d354beed1b6866'),(539,'c','将private int m改为 static int m     ','8d216f38f0c44bf688d354beed1b6866'),(540,'d','将private int m改为int m ','8d216f38f0c44bf688d354beed1b6866'),(541,'a','start()    ','5256a206377f489b9f8ec91ad00d81ff'),(542,'b','init()    ','5256a206377f489b9f8ec91ad00d81ff'),(543,'c','run()    ','5256a206377f489b9f8ec91ad00d81ff'),(544,'d','main()  ','5256a206377f489b9f8ec91ad00d81ff'),(545,'a','栈是非线性结构        ','fc5d6334eb31432c9c9c3f2e30190430'),(546,'b','栈是一种树状结构 ','fc5d6334eb31432c9c9c3f2e30190430'),(547,'c','栈具有先进先出的特征  ','fc5d6334eb31432c9c9c3f2e30190430'),(548,'d','栈具有后进先出的特征 ','fc5d6334eb31432c9c9c3f2e30190430'),(549,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','38266ab0c30643459203b9ec402a31f0'),(550,'b','垃圾收集将检查并释放不在使用的内存  ','38266ab0c30643459203b9ec402a31f0'),(551,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','38266ab0c30643459203b9ec402a31f0'),(552,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','38266ab0c30643459203b9ec402a31f0'),(553,'a','类可以让我们用程序模拟现实世界中的实体','88a68bc04d984a58a5a5fb715b10c91a'),(554,'b','有多少个实体就要创建多少个类 ','88a68bc04d984a58a5a5fb715b10c91a'),(555,'c','对象的行为和属性被封装在类中，外界通过调用类的方法来获得，但是要知道类的 内部是如何实现 ','88a68bc04d984a58a5a5fb715b10c91a'),(556,'d','现实世界中的某些实体不能用类来描述','88a68bc04d984a58a5a5fb715b10c91a'),(557,'a','抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承。但是一 个类却可以实现多个接口。','8062be40f2bc44e3931f43e3f5d7e36a'),(558,'b','在抽象类中可以没有抽象方法 ','8062be40f2bc44e3931f43e3f5d7e36a'),(559,'c','实现抽象类和接口的类必须实现其中的所有方法，除非它也是抽象类。接口中的方 法都不能被实现 ','8062be40f2bc44e3931f43e3f5d7e36a'),(560,'d','接口中的方法都必须加上public关键字。','8062be40f2bc44e3931f43e3f5d7e36a'),(561,'a',' Frame','d8f70d3d49c34caba653791d65e03075'),(562,'b','Checkbox','d8f70d3d49c34caba653791d65e03075'),(563,'c',' Panel','d8f70d3d49c34caba653791d65e03075'),(564,'d','TextField','d8f70d3d49c34caba653791d65e03075'),(565,'a',' BorderLayout是边框布局，它是窗体的默认布局 ','9038d6b293b141f294007c214d1d03ea'),(566,'b',' null是空布局，它是面板的默认布局 ','9038d6b293b141f294007c214d1d03ea'),(567,'c','FlowLayout是流布局，这种布局将其中的组件按照加入的先后顺序从左向右排列，  一行排满之后就转到下一行继续从左至右排列 ','9038d6b293b141f294007c214d1d03ea'),(568,'d','GridLayout是网格布局，它以矩形网格形式对容器的组件进行布置。容器被分成大 小相等的矩形，一个矩形中放置一个组件 ','9038d6b293b141f294007c214d1d03ea'),(569,'a','bookTypeList.add(\"小说\"); ','bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(570,'b','bookTypeList.get(\"小说\"); ','bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(571,'c','bookTypeList.contains(\"小说\");','bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(572,'d',' bookTypeList.remove(\"小说\"); ','bcc1fb0d28bc4d5eb0efcbf22c9e09f4'),(573,'a',' this关键字是在对象内部指代自身的引用','e1d9217a179d4dc6a086bba7b1bad2d2'),(574,'b',' this关键字可以在类中的任何位置使用 ','e1d9217a179d4dc6a086bba7b1bad2d2'),(575,'c','this关键字和类关联，而不是和特定的对象关联 ','e1d9217a179d4dc6a086bba7b1bad2d2'),(576,'d','同一个类的不同对象共用一个this','e1d9217a179d4dc6a086bba7b1bad2d2'),(577,'a','Output is null.             ','b2c9595a4f9943ccac052842a490184d'),(578,'b','Output is 0 ','b2c9595a4f9943ccac052842a490184d'),(579,'c','编译时报错 ','b2c9595a4f9943ccac052842a490184d'),(580,'d','运行时报错','b2c9595a4f9943ccac052842a490184d'),(581,'a',' C不仅继承了B中的成员，同样也继承了A中的成员 ','8777e01cda604b7f8761ae38dc4021e0'),(582,'b','C只继承了B中的成员','8777e01cda604b7f8761ae38dc4021e0'),(583,'c','C只继承了A中的成员 ','8777e01cda604b7f8761ae38dc4021e0'),(584,'d',' C不能继承A或B中的成员','8777e01cda604b7f8761ae38dc4021e0'),(585,'a','封装就是将属性私有化，提供共有的方法访问私有属性','f52079f7db5b4e67988d50a94de7f758'),(586,'b','属性的访问方法包括setter方法和getter方法','f52079f7db5b4e67988d50a94de7f758'),(587,'c','setter方法用于赋值，getter方法用于取值','f52079f7db5b4e67988d50a94de7f758'),(588,'d','包含属性的类都必须封装属性，否则无法通过编译 ','f52079f7db5b4e67988d50a94de7f758'),(589,'a','equals(Object obj) ','447a4ff6e92e450bac70b311a7714c1f'),(590,'b','getClass()','447a4ff6e92e450bac70b311a7714c1f'),(591,'c',' toString()   ','447a4ff6e92e450bac70b311a7714c1f'),(592,'d','trim() ','447a4ff6e92e450bac70b311a7714c1f'),(593,'a',' try','68ebb66d022649b6b02b8347f3c1328b'),(594,'b','catch','68ebb66d022649b6b02b8347f3c1328b'),(595,'c','throw ','68ebb66d022649b6b02b8347f3c1328b'),(596,'d','throws ','68ebb66d022649b6b02b8347f3c1328b'),(597,'a',' public void aMethod(); ','a59cfa5cdfa141e1b31eae5d2dadca8d'),(598,'b','void aMethod();','a59cfa5cdfa141e1b31eae5d2dadca8d'),(599,'c',' protected void aMethod();','a59cfa5cdfa141e1b31eae5d2dadca8d'),(600,'d','private void aMethod(); ','a59cfa5cdfa141e1b31eae5d2dadca8d'),(601,'a','super关键字是在子类对象内部指代其父类对象的引用','5805162af038471a915a74292e25b76a'),(602,'b',' super关键字不仅可以指代子类的直接父类，还可以指代父类的父类','5805162af038471a915a74292e25b76a'),(603,'c',' 子类通过super关键字只能调用父类的方法，而不能调用父类的属性','5805162af038471a915a74292e25b76a'),(604,'d','子类通过super关键字只能调用父类的属性，而不能调用父类的方法','5805162af038471a915a74292e25b76a'),(605,'','在Java语言中，下列关于类的继承的描述，正确的是（ ）','ec79577e06f24aa382a13bbc9ac83f2d'),(606,'a',' 一个类可以继承多个父类','ec79577e06f24aa382a13bbc9ac83f2d'),(607,'b','一个类可以具有多个子类','ec79577e06f24aa382a13bbc9ac83f2d'),(608,'c','子类可以使用父类的所有方法','ec79577e06f24aa382a13bbc9ac83f2d'),(609,'','在Java中，下面对于构造函数的描述错误的是（  ）（选择两项）','e0d56f51b8b842b1b04181553cb0cdcf'),(610,'a','类不一定要显式定义构造函数 ','e0d56f51b8b842b1b04181553cb0cdcf'),(611,'b','构造函数的返回类型是void ','e0d56f51b8b842b1b04181553cb0cdcf'),(612,'c','如果构造函数不带任何参数，那么构造函数的名称和类名可以不同 ','e0d56f51b8b842b1b04181553cb0cdcf'),(613,'','下面关于OPM的说法不正确的是','bf3f7ba00d274129aea4b9aeb2300b34'),(614,'a','持久化是将程序中数据在瞬时状态和持久状态间转换的机制','bf3f7ba00d274129aea4b9aeb2300b34'),(615,'b','瞬时状态是指程序数据保存在内存中，程序退出时，数据就不存在了','bf3f7ba00d274129aea4b9aeb2300b34'),(616,'c','把关系数据库中的数据读出来不属于持久化','bf3f7ba00d274129aea4b9aeb2300b34'),(617,'','spring能管理的组件不包括','6095a401ca8a404ca7f13e8e9725fb62'),(618,'a','Jsp ','6095a401ca8a404ca7f13e8e9725fb62'),(619,'b','javabean','6095a401ca8a404ca7f13e8e9725fb62'),(620,'c','pojo','6095a401ca8a404ca7f13e8e9725fb62'),(621,'','在J2EE中，request对象的方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据','76b96d4a859645088ea3117d14e10c8b'),(622,'a','String getParameter(String name)','76b96d4a859645088ea3117d14e10c8b'),(623,'b','String[] getParameter(String name)','76b96d4a859645088ea3117d14e10c8b'),(624,'c','String getParameterValues(String name)','76b96d4a859645088ea3117d14e10c8b'),(625,'','在J2EE中，test.jsp文件中有如下一行代码：\n<jsp:useBean id=”user”scope=”_”type=”com.UserBean”/>要使user对象只能在使用test.jsp时使用，当加载页面时就会将其销毁','227e55a3fc3342d9b04a3e7503290c75'),(626,'a','page','227e55a3fc3342d9b04a3e7503290c75'),(627,'b','request','227e55a3fc3342d9b04a3e7503290c75'),(628,'c','session','227e55a3fc3342d9b04a3e7503290c75'),(629,'','要设计一个大型的基于多层体系结构的web应用系统，系统界面端基于HTML和XML，该系统要不断的进行版级（即日后维护、二次需求开发等任务量较大），要达成这些目标，最适合的开发模式是','410c38fbce94425bb813bddee3c79daf'),(630,'a','DAO','410c38fbce94425bb813bddee3c79daf'),(631,'b','ValueObject','410c38fbce94425bb813bddee3c79daf'),(632,'c','MVC','410c38fbce94425bb813bddee3c79daf'),(633,'','在J2EE中，使用Servlet过滤器时，需要在web.xml通过（B）元素将过滤器映射到Web资源。','1d07e5d16cd042ad926760f9b3211863'),(634,'a','<filter>','1d07e5d16cd042ad926760f9b3211863'),(635,'b','<filter-mapping>','1d07e5d16cd042ad926760f9b3211863'),(636,'c','<servlet>','1d07e5d16cd042ad926760f9b3211863'),(637,'','在J2EE的Model II模式中，模型层对象被编写为','3b130363445b4b32bb311b5f3c44d224'),(638,'a','Applet','3b130363445b4b32bb311b5f3c44d224'),(639,'b','JSP','3b130363445b4b32bb311b5f3c44d224'),(640,'c','Servlet','3b130363445b4b32bb311b5f3c44d224'),(641,'','J2EE中，()类的（）方法用于返回应用程序的上下文路径。','126f3689546d4c8f9ecad6cf4baf0037'),(642,'a','HttpServletRequest、getContextPath()','126f3689546d4c8f9ecad6cf4baf0037'),(643,'b','HttpServletRequest、getPathInfo()','126f3689546d4c8f9ecad6cf4baf0037'),(644,'c','ServlettContext、getContextPath()','126f3689546d4c8f9ecad6cf4baf0037'),(645,'','Web应用中，常用的会话跟踪方法不包括','bc1040b6c26d4bc28a306a5d5e167b4f'),(646,'a','URL重写','bc1040b6c26d4bc28a306a5d5e167b4f'),(647,'b','Cookie','bc1040b6c26d4bc28a306a5d5e167b4f'),(648,'c','隐藏表单域','bc1040b6c26d4bc28a306a5d5e167b4f'),(649,'','给顶一个JSP程序源代码，如下：\n<jsp:include page=\"two.jsp\" flush=\"true\">\n<jsp:param name=\"location\" value=\"bejing\"/>\n</jsp:include>在two.jsp中使用（）代码片段可以输出参数location的值。','c2d82e059bef4634b439ae58349f01b3'),(650,'a','<jsp:getParam name=\"location\">','c2d82e059bef4634b439ae58349f01b3'),(651,'b','<jsp:getParameter name=\"location\">','c2d82e059bef4634b439ae58349f01b3'),(652,'c','<%=request.getAttribute(\"location\")%>','c2d82e059bef4634b439ae58349f01b3'),(653,'','JavaMail是一组用于发送和接收邮件消息的API。发送邮件使用（）协议，接收邮件使用（）协议','a35a5aebdd354ae5ae0f75a6a77d4374'),(654,'a','POP3 SMTP','a35a5aebdd354ae5ae0f75a6a77d4374'),(655,'b','POP3 TCP','a35a5aebdd354ae5ae0f75a6a77d4374'),(656,'c','SMTP TCP','a35a5aebdd354ae5ae0f75a6a77d4374'),(657,'','在J2EE中，在一个JSP文件中，有表达式<%=2+3 %>，它将输出（ ）','717586535ae7442ead3dd17363782956'),(658,'a','2+3','717586535ae7442ead3dd17363782956'),(659,'b','5.0','717586535ae7442ead3dd17363782956'),(660,'c','23.0','717586535ae7442ead3dd17363782956'),(661,'','在JSP中，（）动作用于将请求转发给其他JSP页面','b42e049c44b74cce9f8fa882a599cdb3'),(662,'a','forward','b42e049c44b74cce9f8fa882a599cdb3'),(663,'b','include','b42e049c44b74cce9f8fa882a599cdb3'),(664,'c','useBean','b42e049c44b74cce9f8fa882a599cdb3'),(665,'','在J2EE实现企业级应用开发中，（ ）是描述标记库的XML文档','0ded419a03a8402a8f0c7605c37ee303'),(666,'a','TLD文件','0ded419a03a8402a8f0c7605c37ee303'),(667,'b','DTD文件','0ded419a03a8402a8f0c7605c37ee303'),(668,'c','WAR文件','0ded419a03a8402a8f0c7605c37ee303'),(669,'','用来获取一个已被创建的JavaBean组件的属性值','954ce958d8ea4e65ad75dd6c4c544aa8'),(670,'a','<jsp:getProperty>','954ce958d8ea4e65ad75dd6c4c544aa8'),(671,'b','<Bean:getProperty>','954ce958d8ea4e65ad75dd6c4c544aa8'),(672,'c','<jsp:getAttrib>','954ce958d8ea4e65ad75dd6c4c544aa8'),(673,'','在WAR文件中，web.xml放在哪个目录中','8b414f97f37c4d5282693c7e4a410630'),(674,'a','WEB-INF','8b414f97f37c4d5282693c7e4a410630'),(675,'b','APP-INF','8b414f97f37c4d5282693c7e4a410630'),(676,'c','META-INF','8b414f97f37c4d5282693c7e4a410630'),(677,'','Servlet间完成协作，需要用到（ ）完成请求指派','daaac5f7f17648ad9f72669c4cbc5067'),(678,'a','Requestdispatcher','daaac5f7f17648ad9f72669c4cbc5067'),(679,'b','Responsedispatcher','daaac5f7f17648ad9f72669c4cbc5067'),(680,'c','Servletdispatcher','daaac5f7f17648ad9f72669c4cbc5067'),(681,'','JSP从HTML表单中获得用户输入的正确语句为','43da938ab13542e196dbccc649c80bd1'),(682,'a','Request.getParameter(“ID”)','43da938ab13542e196dbccc649c80bd1'),(683,'b','Reponse.getParameter(“ID”)','43da938ab13542e196dbccc649c80bd1'),(684,'c','Request.getAttribute(“ID”)','43da938ab13542e196dbccc649c80bd1'),(685,'','常用的上传邮件的协议是','678c081b2dac4f24bfe4d5168d0fd051'),(686,'a','SMTP','678c081b2dac4f24bfe4d5168d0fd051'),(687,'b','POP3','678c081b2dac4f24bfe4d5168d0fd051'),(688,'c','IMAP','678c081b2dac4f24bfe4d5168d0fd051'),(689,'','关于sleep()和wait()，以下描述错误的一项是（ ）','68cab8ab20f441c1ab0dfe9965fe29a0'),(690,'a','sleep是线程类（Thread）的方法，wait是Object类的方法','68cab8ab20f441c1ab0dfe9965fe29a0'),(691,'b','sleep是线程类（Thread）的方法，wait是Object类的方法','68cab8ab20f441c1ab0dfe9965fe29a0'),(692,'c','sleep暂停线程、但监控状态仍然保持，结束后会自动恢复','68cab8ab20f441c1ab0dfe9965fe29a0'),(693,'','[多选]  在Session范围中以名称\"bean\"放置了一个JavaBean属性，JavaBean上有个 getMessage()方法，请问以下哪个方式呼叫getMessage()以取得讯息并显示出来？','e8e6b37a495040c7a42b5044e1977611'),(694,'a','<jsp:getProperty name=\"bean\" property=\"message\"> ','e8e6b37a495040c7a42b5044e1977611'),(695,'b','${requestScope.bean.message} ','e8e6b37a495040c7a42b5044e1977611'),(696,'c','<%= request.getBean().getMessage() %> ','e8e6b37a495040c7a42b5044e1977611'),(697,'','在Java中，负责对字节代码解释执行的是   ','5fff04f70d774f5d8755b1d89504ae54'),(698,'a','应用服务器','5fff04f70d774f5d8755b1d89504ae54'),(699,'b','虚拟机','5fff04f70d774f5d8755b1d89504ae54'),(700,'c','垃圾回收器','5fff04f70d774f5d8755b1d89504ae54'),(701,'','有关线程的哪些叙述是对的（ ）','639921545d28411db6b172befeaf2a18'),(702,'a','一旦一个线程被创建，它就立即开始运行','639921545d28411db6b172befeaf2a18'),(703,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行','639921545d28411db6b172befeaf2a18'),(704,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面','639921545d28411db6b172befeaf2a18'),(705,'','Java I/O程序设计中，下列描述正确的是','f3bbcfaa45534a819b48de3c52d76888'),(706,'a','OutputStream用于写操作','f3bbcfaa45534a819b48de3c52d76888'),(707,'b','InputStream用于写操作','f3bbcfaa45534a819b48de3c52d76888'),(708,'c','I/O库不支持对文件可读可写API','f3bbcfaa45534a819b48de3c52d76888'),(709,'','关于Java语言，下列描述正确的是（多选）','7403c2f1dee74140b600fbe410e02490'),(710,'a','switch 不能够作用在String类型上','7403c2f1dee74140b600fbe410e02490'),(711,'b',' List， Set， Map都继承自Collection接口','7403c2f1dee74140b600fbe410e02490'),(712,'c','Java语言支持goto语句','7403c2f1dee74140b600fbe410e02490'),(713,'',' 关于线程设计，下列描述正确的是','64905cc258104eb7a2cc02998326f140'),(714,'a','线程对象必须实现Runnable接口','64905cc258104eb7a2cc02998326f140'),(715,'b','启动一个线程直接调用线程对象的run()方法','64905cc258104eb7a2cc02998326f140'),(716,'c','Java提供对多线程同步提供语言级的支持','64905cc258104eb7a2cc02998326f140'),(717,'',' 欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的','bbfc083585d140d787f0444ada09b5a2'),(718,'a','ArrayList myList = new Object();','bbfc083585d140d787f0444ada09b5a2'),(719,'b','List myList = new ArrayList();','bbfc083585d140d787f0444ada09b5a2'),(720,'c','ArraylList myList = new List();','bbfc083585d140d787f0444ada09b5a2'),(721,'','关于线程设计，下列描述正确的是','3e8b79b07a614aba80e248bf3fd97a84'),(722,'a','线程对象必须实现Runnable接口','3e8b79b07a614aba80e248bf3fd97a84'),(723,'b','启动一个线程直接调用线程对象的run()方法','3e8b79b07a614aba80e248bf3fd97a84'),(724,'c','Java提供对多线程同步提供语言级的支持','3e8b79b07a614aba80e248bf3fd97a84'),(725,'','以下哪个命令用于测试网络连通。','46fc9416a72d4d6e96a8f12232cd6c1f'),(726,'a','telnet','46fc9416a72d4d6e96a8f12232cd6c1f'),(727,'b','netstat','46fc9416a72d4d6e96a8f12232cd6c1f'),(728,'c','ping','46fc9416a72d4d6e96a8f12232cd6c1f'),(729,'','Java网络程序设计中，下列正确的描述是','6693a04918124b32b0b86d1577609e12'),(730,'a','Java网络编程API建立在Socket基础之上','6693a04918124b32b0b86d1577609e12'),(731,'b','Java网络接口只支持TCP以及其上层协议','6693a04918124b32b0b86d1577609e12'),(732,'c','Java网络接口只支持UDP以及其上层协议','6693a04918124b32b0b86d1577609e12'),(733,'','下列哪些是J2EE的体系','1d49e67b65fb4facabc924ba268558fe'),(734,'a','JSP','1d49e67b65fb4facabc924ba268558fe'),(735,'b','JAVA','1d49e67b65fb4facabc924ba268558fe'),(736,'c','Servlet','1d49e67b65fb4facabc924ba268558fe'),(737,'','如何取得数据源。','b33fd17060c84e7d9ff78f62370a3f94'),(738,'a','通过Http','b33fd17060c84e7d9ff78f62370a3f94'),(739,'b','通过ftp','b33fd17060c84e7d9ff78f62370a3f94'),(740,'c','JNDI','b33fd17060c84e7d9ff78f62370a3f94'),(741,'','关于JSP生命周期的叙述，下列哪些为真？','5c593c484e4a485d97190f5aa23226da'),(742,'a','JSP会先解释成Servlet源文件，然后编译成Servlet类文件','5c593c484e4a485d97190f5aa23226da'),(743,'b','每当用户端运行JSP时，jspInit()方法都会运行一次','5c593c484e4a485d97190f5aa23226da'),(744,'c','每当用户端运行JSP时，_jspService()方法都会运行一次','5c593c484e4a485d97190f5aa23226da'),(745,'','下面的那一个不属于MVC模式中的对象','b94ddff9193c41fdb504b848f9ae3d03'),(746,'a','Model','b94ddff9193c41fdb504b848f9ae3d03'),(747,'b','View','b94ddff9193c41fdb504b848f9ae3d03'),(748,'c','Collection','b94ddff9193c41fdb504b848f9ae3d03'),(749,'','下面哪些属于JSTL中的表达式操作标签。(选择1项)','5fe50b7ca40c413cabe90e6a561b302f'),(750,'a','<c:out>','5fe50b7ca40c413cabe90e6a561b302f'),(751,'b','<c:if>','5fe50b7ca40c413cabe90e6a561b302f'),(752,'c','<c:url>','5fe50b7ca40c413cabe90e6a561b302f'),(1281,'a','类可以让我们用程序模拟现实世界中的实体','909bd14bd65047e5a3d14e8a70139159'),(1282,'b','有多少个实体就要创建多少个类 ','909bd14bd65047e5a3d14e8a70139159'),(1283,'c','对象的行为和属性被封装在类中，外界通过调用类的方法来获得，但是要知道类的 内部是如何实现 ','909bd14bd65047e5a3d14e8a70139159'),(1284,'d','现实世界中的某些实体不能用类来描述','909bd14bd65047e5a3d14e8a70139159'),(1285,'a','抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承。但是一 个类却可以实现多个接口。','5aa4c70609e24c48850d4d6339e84b4c'),(1286,'b','在抽象类中可以没有抽象方法 ','5aa4c70609e24c48850d4d6339e84b4c'),(1287,'c','实现抽象类和接口的类必须实现其中的所有方法，除非它也是抽象类。接口中的方 法都不能被实现 ','5aa4c70609e24c48850d4d6339e84b4c'),(1288,'d','接口中的方法都必须加上public关键字。','5aa4c70609e24c48850d4d6339e84b4c'),(1289,'a',' Frame','131ed917d9c44513a5633f28d449d5b3'),(1290,'b','Checkbox','131ed917d9c44513a5633f28d449d5b3'),(1291,'c',' Panel','131ed917d9c44513a5633f28d449d5b3'),(1292,'d','TextField','131ed917d9c44513a5633f28d449d5b3'),(1293,'a',' BorderLayout是边框布局，它是窗体的默认布局 ','116369da665b44ceb3246d2d7682042e'),(1294,'b',' null是空布局，它是面板的默认布局 ','116369da665b44ceb3246d2d7682042e'),(1295,'c','FlowLayout是流布局，这种布局将其中的组件按照加入的先后顺序从左向右排列，  一行排满之后就转到下一行继续从左至右排列 ','116369da665b44ceb3246d2d7682042e'),(1296,'d','GridLayout是网格布局，它以矩形网格形式对容器的组件进行布置。容器被分成大 小相等的矩形，一个矩形中放置一个组件 ','116369da665b44ceb3246d2d7682042e'),(1297,'a','bookTypeList.add(\"小说\"); ','6a9374cf008f46b39329436c6a1b3208'),(1298,'b','bookTypeList.get(\"小说\"); ','6a9374cf008f46b39329436c6a1b3208'),(1299,'c','bookTypeList.contains(\"小说\");','6a9374cf008f46b39329436c6a1b3208'),(1300,'d',' bookTypeList.remove(\"小说\"); ','6a9374cf008f46b39329436c6a1b3208'),(1301,'a',' this关键字是在对象内部指代自身的引用','d62a9d5432384283a2719df8879bbc1c'),(1302,'b',' this关键字可以在类中的任何位置使用 ','d62a9d5432384283a2719df8879bbc1c'),(1303,'c','this关键字和类关联，而不是和特定的对象关联 ','d62a9d5432384283a2719df8879bbc1c'),(1304,'d','同一个类的不同对象共用一个this','d62a9d5432384283a2719df8879bbc1c'),(1305,'a','Output is null.             ','4cb48c7571894b4f9ec55d9f53d4836a'),(1306,'b','Output is 0 ','4cb48c7571894b4f9ec55d9f53d4836a'),(1307,'c','编译时报错 ','4cb48c7571894b4f9ec55d9f53d4836a'),(1308,'d','运行时报错','4cb48c7571894b4f9ec55d9f53d4836a'),(1309,'a',' C不仅继承了B中的成员，同样也继承了A中的成员 ','40bb8040eeea498eadefb4d3affd3efa'),(1310,'b','C只继承了B中的成员','40bb8040eeea498eadefb4d3affd3efa'),(1311,'c','C只继承了A中的成员 ','40bb8040eeea498eadefb4d3affd3efa'),(1312,'d',' C不能继承A或B中的成员','40bb8040eeea498eadefb4d3affd3efa'),(1313,'a','封装就是将属性私有化，提供共有的方法访问私有属性','93578c12c0ff47e7a888b945caf96b41'),(1314,'b','属性的访问方法包括setter方法和getter方法','93578c12c0ff47e7a888b945caf96b41'),(1315,'c','setter方法用于赋值，getter方法用于取值','93578c12c0ff47e7a888b945caf96b41'),(1316,'d','包含属性的类都必须封装属性，否则无法通过编译 ','93578c12c0ff47e7a888b945caf96b41'),(1317,'a','equals(Object obj) ','4516a7c4ddbe4b158962cd225f862a2b'),(1318,'b','getClass()','4516a7c4ddbe4b158962cd225f862a2b'),(1319,'c',' toString()   ','4516a7c4ddbe4b158962cd225f862a2b'),(1320,'d','trim() ','4516a7c4ddbe4b158962cd225f862a2b'),(1321,'a',' try','9951bbeb408a44a993400d4e7a17c79d'),(1322,'b','catch','9951bbeb408a44a993400d4e7a17c79d'),(1323,'c','throw ','9951bbeb408a44a993400d4e7a17c79d'),(1324,'d','throws ','9951bbeb408a44a993400d4e7a17c79d'),(1325,'a',' public void aMethod(); ','014cd684159c40f1bf385c7e411c5eb8'),(1326,'b','void aMethod();','014cd684159c40f1bf385c7e411c5eb8'),(1327,'c',' protected void aMethod();','014cd684159c40f1bf385c7e411c5eb8'),(1328,'d','private void aMethod(); ','014cd684159c40f1bf385c7e411c5eb8'),(1329,'a','super关键字是在子类对象内部指代其父类对象的引用','1bed7e77feed463aa313e4e3956a2a43'),(1330,'b',' super关键字不仅可以指代子类的直接父类，还可以指代父类的父类','1bed7e77feed463aa313e4e3956a2a43'),(1331,'c',' 子类通过super关键字只能调用父类的方法，而不能调用父类的属性','1bed7e77feed463aa313e4e3956a2a43'),(1332,'d','子类通过super关键字只能调用父类的属性，而不能调用父类的方法','1bed7e77feed463aa313e4e3956a2a43'),(1333,'a',' 一个类可以继承多个父类','9426e04fa6c64a1593c2a4fe05597661'),(1334,'b','一个类可以具有多个子类','9426e04fa6c64a1593c2a4fe05597661'),(1335,'c','子类可以使用父类的所有方法','9426e04fa6c64a1593c2a4fe05597661'),(1336,'d','子类一定比父类有更多的成员方法','9426e04fa6c64a1593c2a4fe05597661'),(1337,'a','类不一定要显式定义构造函数 ','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1338,'b','构造函数的返回类型是void ','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1339,'c','如果构造函数不带任何参数，那么构造函数的名称和类名可以不同 ','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1340,'d','一个类可以定义多个构造函数','a0fcd30d27e34048a2a3a0f3e8b8bd7c'),(1341,'a','持久化是将程序中数据在瞬时状态和持久状态间转换的机制','683943e1e3d34651a83cfa4549b2799a'),(1342,'b','瞬时状态是指程序数据保存在内存中，程序退出时，数据就不存在了','683943e1e3d34651a83cfa4549b2799a'),(1343,'c','把关系数据库中的数据读出来不属于持久化','683943e1e3d34651a83cfa4549b2799a'),(1344,'d','程序数据直接保存成文本文件属于持久化','683943e1e3d34651a83cfa4549b2799a'),(1345,'a','Jsp ','82d63683b9b64b6c9bd79e7d6275295e'),(1346,'b','javabean','82d63683b9b64b6c9bd79e7d6275295e'),(1347,'c','pojo','82d63683b9b64b6c9bd79e7d6275295e'),(1348,'b','DAO ','82d63683b9b64b6c9bd79e7d6275295e'),(1349,'a','String getParameter(String name)','d8d6ce051cc74adda9daf2eb148b6054'),(1350,'b','String[] getParameter(String name)','d8d6ce051cc74adda9daf2eb148b6054'),(1351,'c','String getParameterValues(String name)','d8d6ce051cc74adda9daf2eb148b6054'),(1352,'d','String[] getParameterValues(String name)','d8d6ce051cc74adda9daf2eb148b6054'),(1353,'a','page','dbf0d85317f241d48b6a8d91dc3f5763'),(1354,'b','request','dbf0d85317f241d48b6a8d91dc3f5763'),(1355,'c','session','dbf0d85317f241d48b6a8d91dc3f5763'),(1356,'d','application','dbf0d85317f241d48b6a8d91dc3f5763'),(1357,'a','DAO','97a43b8cba1d4e5cbf14123c615dba8a'),(1358,'b','ValueObject','97a43b8cba1d4e5cbf14123c615dba8a'),(1359,'c','MVC','97a43b8cba1d4e5cbf14123c615dba8a'),(1360,'d','Proxy','97a43b8cba1d4e5cbf14123c615dba8a'),(1361,'a','<filter>','d21ce5ab62bc4b3786c3903abc51add2'),(1362,'b','<filter-mapping>','d21ce5ab62bc4b3786c3903abc51add2'),(1363,'c','<servlet>','d21ce5ab62bc4b3786c3903abc51add2'),(1364,'d','<servlet-mapping>','d21ce5ab62bc4b3786c3903abc51add2'),(1365,'a','Applet','ee1dc62698ba4f3a83898f94b4b9d472'),(1366,'b','JSP','ee1dc62698ba4f3a83898f94b4b9d472'),(1367,'c','Servlet','ee1dc62698ba4f3a83898f94b4b9d472'),(1368,'d','JavaBean','ee1dc62698ba4f3a83898f94b4b9d472'),(1369,'a','HttpServletRequest、getContextPath()','02076d1058dd4a15aa132ab8a3846e04'),(1370,'b','HttpServletRequest、getPathInfo()','02076d1058dd4a15aa132ab8a3846e04'),(1371,'c','ServlettContext、getContextPath()','02076d1058dd4a15aa132ab8a3846e04'),(1372,'d','ServlettContext、getPathInfo()','02076d1058dd4a15aa132ab8a3846e04'),(1373,'a','URL重写','6b2301dde567463dbbd53680b363bbee'),(1374,'b','Cookie','6b2301dde567463dbbd53680b363bbee'),(1375,'c','隐藏表单域','6b2301dde567463dbbd53680b363bbee'),(1376,'d','有状态HTTP协议','6b2301dde567463dbbd53680b363bbee'),(1377,'a','<jsp:getParam name=\"location\">','59bc97a58cdd46c3bc79261dc282c62f'),(1378,'b','<jsp:getParameter name=\"location\">','59bc97a58cdd46c3bc79261dc282c62f'),(1379,'c','<%=request.getAttribute(\"location\")%>','59bc97a58cdd46c3bc79261dc282c62f'),(1380,'d','<%=request.getParameter(\"location\")%>','59bc97a58cdd46c3bc79261dc282c62f'),(1381,'a','POP3 SMTP','f9446cfe21c44e199102c9be7a13f508'),(1382,'b','POP3 TCP','f9446cfe21c44e199102c9be7a13f508'),(1383,'c','SMTP TCP','f9446cfe21c44e199102c9be7a13f508'),(1384,'d','SMTP POP3','f9446cfe21c44e199102c9be7a13f508'),(1385,'a','2+3','a77a9c5766a2404ebc1f14055751afab'),(1386,'b','5.0','a77a9c5766a2404ebc1f14055751afab'),(1387,'c','23.0','a77a9c5766a2404ebc1f14055751afab'),(1388,'d','不会输出，因为表达式是错误的','a77a9c5766a2404ebc1f14055751afab'),(1389,'a','forward','9f594676ea16490584ab04c73fb44515'),(1390,'b','include','9f594676ea16490584ab04c73fb44515'),(1391,'c','useBean','9f594676ea16490584ab04c73fb44515'),(1392,'d','setProperty','9f594676ea16490584ab04c73fb44515'),(1393,'a','TLD文件','89578b4126ac417ca21a49a850406909'),(1394,'b','DTD文件','89578b4126ac417ca21a49a850406909'),(1395,'c','WAR文件','89578b4126ac417ca21a49a850406909'),(1396,'d','EAR文件','89578b4126ac417ca21a49a850406909'),(1397,'a','<jsp:getProperty>','782e6f039ebf402fbda0363779394ec7'),(1398,'b','<Bean:getProperty>','782e6f039ebf402fbda0363779394ec7'),(1399,'c','<jsp:getAttrib>','782e6f039ebf402fbda0363779394ec7'),(1400,'d','<JavaBean:getProperty>','782e6f039ebf402fbda0363779394ec7'),(1401,'a','WEB-INF','a79f9c7cba2a4c379c648c34516ceadd'),(1402,'b','APP-INF','a79f9c7cba2a4c379c648c34516ceadd'),(1403,'c','META-INF','a79f9c7cba2a4c379c648c34516ceadd'),(1404,'d','WEB-INF\\lib','a79f9c7cba2a4c379c648c34516ceadd'),(1405,'a','Requestdispatcher','0dddbefe024a41fabe0b3491f204eb2e'),(1406,'b','Responsedispatcher','0dddbefe024a41fabe0b3491f204eb2e'),(1407,'c','Servletdispatcher','0dddbefe024a41fabe0b3491f204eb2e'),(1408,'d','includedispatcher','0dddbefe024a41fabe0b3491f204eb2e'),(1409,'a','Request.getParameter(“ID”)','490e2106952f4c11ad7d51f433fca974'),(1410,'b','Reponse.getParameter(“ID”)','490e2106952f4c11ad7d51f433fca974'),(1411,'c','Request.getAttribute(“ID”)','490e2106952f4c11ad7d51f433fca974'),(1412,'d','Reponse.getAttribute(“ID”)','490e2106952f4c11ad7d51f433fca974'),(1413,'a','SMTP','e21adbf54f9948c69da67bd6ff941719'),(1414,'b','POP3','e21adbf54f9948c69da67bd6ff941719'),(1415,'c','IMAP','e21adbf54f9948c69da67bd6ff941719'),(1416,'d','MIME','e21adbf54f9948c69da67bd6ff941719'),(1417,'a','sleep是线程类（Thread）的方法，wait是Object类的方法','4e41562006754a8fb1c50f7dee810c5b'),(1418,'b','sleep是线程类（Thread）的方法，wait是Object类的方法','4e41562006754a8fb1c50f7dee810c5b'),(1419,'c','sleep暂停线程、但监控状态仍然保持，结束后会自动恢复','4e41562006754a8fb1c50f7dee810c5b'),(1420,'d','wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。','4e41562006754a8fb1c50f7dee810c5b'),(1421,'a','<jsp:getProperty name=\"bean\" property=\"message\"> ','628c38191f45499086980b02cb06c762'),(1422,'b','${requestScope.bean.message} ','628c38191f45499086980b02cb06c762'),(1423,'c','<%= request.getBean().getMessage() %> ','628c38191f45499086980b02cb06c762'),(1424,'d','${bean.message} ','628c38191f45499086980b02cb06c762'),(1425,'a','应用服务器','8fedf8b65c954e23b173fcbcd522e916'),(1426,'b','虚拟机','8fedf8b65c954e23b173fcbcd522e916'),(1427,'c','垃圾回收器','8fedf8b65c954e23b173fcbcd522e916'),(1428,'d','编译器','8fedf8b65c954e23b173fcbcd522e916'),(1429,'a','一旦一个线程被创建，它就立即开始运行','7b00635c1e7d4e8f87caf2d376f57b65'),(1430,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行','7b00635c1e7d4e8f87caf2d376f57b65'),(1431,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面','7b00635c1e7d4e8f87caf2d376f57b65'),(1432,'d','一个线程可能因为不同的原因停止并进入就绪状态','7b00635c1e7d4e8f87caf2d376f57b65'),(1433,'a','OutputStream用于写操作','c56482ede37c460ca5570e033772b0dd'),(1434,'b','InputStream用于写操作','c56482ede37c460ca5570e033772b0dd'),(1435,'c','I/O库不支持对文件可读可写API','c56482ede37c460ca5570e033772b0dd'),(1436,'d','I/O用于多线程','c56482ede37c460ca5570e033772b0dd'),(1437,'a','switch 不能够作用在String类型上','564e350d1c2843ba8365b064f56c0439'),(1438,'b',' List， Set， Map都继承自Collection接口','564e350d1c2843ba8365b064f56c0439'),(1439,'c','Java语言支持goto语句','564e350d1c2843ba8365b064f56c0439'),(1440,'d',' GC是垃圾收集器，程序员不用担心内存管理','564e350d1c2843ba8365b064f56c0439'),(1441,'a','线程对象必须实现Runnable接口','32adc9ce3c7b4e3fa9f23a5b90410461'),(1442,'b','启动一个线程直接调用线程对象的run()方法','32adc9ce3c7b4e3fa9f23a5b90410461'),(1443,'c','Java提供对多线程同步提供语言级的支持','32adc9ce3c7b4e3fa9f23a5b90410461'),(1444,'d','一个线程可以包含多个进程','32adc9ce3c7b4e3fa9f23a5b90410461'),(1445,'a','ArrayList myList = new Object();','9020367beede44f5b93059a75713b034'),(1446,'b','List myList = new ArrayList();','9020367beede44f5b93059a75713b034'),(1447,'c','ArraylList myList = new List();','9020367beede44f5b93059a75713b034'),(1448,'d','List myList = new List();','9020367beede44f5b93059a75713b034'),(1449,'a','线程对象必须实现Runnable接口','fc69113129a44b4badeb408c7948c8ef'),(1450,'b','启动一个线程直接调用线程对象的run()方法','fc69113129a44b4badeb408c7948c8ef'),(1451,'c','Java提供对多线程同步提供语言级的支持','fc69113129a44b4badeb408c7948c8ef'),(1452,'d',' 一个线程可以包含多个进程','fc69113129a44b4badeb408c7948c8ef'),(1453,'a','telnet','0882ec97c005432c874f57ba0e5c94ab'),(1454,'b','netstat','0882ec97c005432c874f57ba0e5c94ab'),(1455,'c','ping','0882ec97c005432c874f57ba0e5c94ab'),(1456,'d','ftp','0882ec97c005432c874f57ba0e5c94ab'),(1457,'a','Java网络编程API建立在Socket基础之上','f60dcc77fb0649df9a16199fbede9b44'),(1458,'b','Java网络接口只支持TCP以及其上层协议','f60dcc77fb0649df9a16199fbede9b44'),(1459,'c','Java网络接口只支持UDP以及其上层协议','f60dcc77fb0649df9a16199fbede9b44'),(1460,'d','Java网络接口支持IP以上的所有高层协议','f60dcc77fb0649df9a16199fbede9b44'),(1461,'a','JSP','2cbd536c7819476495d6cae2301d9643'),(1462,'b','JAVA','2cbd536c7819476495d6cae2301d9643'),(1463,'c','Servlet','2cbd536c7819476495d6cae2301d9643'),(1464,'d','WebService','2cbd536c7819476495d6cae2301d9643'),(1465,'a','通过Http','b3a378983d5e46de95c31633796f663b'),(1466,'b','通过ftp','b3a378983d5e46de95c31633796f663b'),(1467,'c','JNDI','b3a378983d5e46de95c31633796f663b'),(1468,'d','通过Connection对象','b3a378983d5e46de95c31633796f663b'),(1469,'a','JSP会先解释成Servlet源文件，然后编译成Servlet类文件','68bbfca9f9d64b829fa471abd380890d'),(1470,'b','每当用户端运行JSP时，jspInit()方法都会运行一次','68bbfca9f9d64b829fa471abd380890d'),(1471,'c','每当用户端运行JSP时，_jspService()方法都会运行一次','68bbfca9f9d64b829fa471abd380890d'),(1472,'d','每当用户端运行JSP时，jspDestroy()方法都会运行一次','68bbfca9f9d64b829fa471abd380890d'),(1473,'a','Model','55be2305662e46c199f9c9db6c175d9d'),(1474,'b','View','55be2305662e46c199f9c9db6c175d9d'),(1475,'c','Collection','55be2305662e46c199f9c9db6c175d9d'),(1476,'d','Controller','55be2305662e46c199f9c9db6c175d9d'),(1477,'a','<c:out>','5dffbb7f55a84d458fe5326ccacdaa47'),(1478,'b','<c:if>','5dffbb7f55a84d458fe5326ccacdaa47'),(1479,'c','<c:url>','5dffbb7f55a84d458fe5326ccacdaa47'),(1480,'d','<c:catch>','5dffbb7f55a84d458fe5326ccacdaa47'),(1481,'a','类可以让我们用程序模拟现实世界中的实体','0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(1482,'b','有多少个实体就要创建多少个类 ','0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(1483,'c','对象的行为和属性被封装在类中，外界通过调用类的方法来获得，但是要知道类的 内部是如何实现 ','0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(1484,'d','现实世界中的某些实体不能用类来描述','0ecfcbcf0e1e4c59bf6fdb32fa31dfae'),(1485,'a','抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承。但是一 个类却可以实现多个接口。','ac74959aa3ff42789ec08555b95fdfe6'),(1486,'b','在抽象类中可以没有抽象方法 ','ac74959aa3ff42789ec08555b95fdfe6'),(1487,'c','实现抽象类和接口的类必须实现其中的所有方法，除非它也是抽象类。接口中的方 法都不能被实现 ','ac74959aa3ff42789ec08555b95fdfe6'),(1488,'d','接口中的方法都必须加上public关键字。','ac74959aa3ff42789ec08555b95fdfe6'),(1489,'a',' Frame','244f8104ff5847149a1918536377eca5'),(1490,'b','Checkbox','244f8104ff5847149a1918536377eca5'),(1491,'c',' Panel','244f8104ff5847149a1918536377eca5'),(1492,'d','TextField','244f8104ff5847149a1918536377eca5'),(1493,'a',' BorderLayout是边框布局，它是窗体的默认布局 ','c1a4862c6bc4432185938cb15a0f6764'),(1494,'b',' null是空布局，它是面板的默认布局 ','c1a4862c6bc4432185938cb15a0f6764'),(1495,'c','FlowLayout是流布局，这种布局将其中的组件按照加入的先后顺序从左向右排列，  一行排满之后就转到下一行继续从左至右排列 ','c1a4862c6bc4432185938cb15a0f6764'),(1496,'d','GridLayout是网格布局，它以矩形网格形式对容器的组件进行布置。容器被分成大 小相等的矩形，一个矩形中放置一个组件 ','c1a4862c6bc4432185938cb15a0f6764'),(1497,'a','bookTypeList.add(\"小说\"); ','f4881d2c800847cea2fc07891268c1fb'),(1498,'b','bookTypeList.get(\"小说\"); ','f4881d2c800847cea2fc07891268c1fb'),(1499,'c','bookTypeList.contains(\"小说\");','f4881d2c800847cea2fc07891268c1fb'),(1500,'d',' bookTypeList.remove(\"小说\"); ','f4881d2c800847cea2fc07891268c1fb'),(1501,'a',' this关键字是在对象内部指代自身的引用','8c289ea1bd714615a8a57b62efd56092'),(1502,'b',' this关键字可以在类中的任何位置使用 ','8c289ea1bd714615a8a57b62efd56092'),(1503,'c','this关键字和类关联，而不是和特定的对象关联 ','8c289ea1bd714615a8a57b62efd56092'),(1504,'d','同一个类的不同对象共用一个this','8c289ea1bd714615a8a57b62efd56092'),(1505,'a','Output is null.             ','9bd8a2fbcead454496452e117b70974f'),(1506,'b','Output is 0 ','9bd8a2fbcead454496452e117b70974f'),(1507,'c','编译时报错 ','9bd8a2fbcead454496452e117b70974f'),(1508,'d','运行时报错','9bd8a2fbcead454496452e117b70974f'),(1509,'a',' C不仅继承了B中的成员，同样也继承了A中的成员 ','2a7a435aabd9473db634967686dd8597'),(1510,'b','C只继承了B中的成员','2a7a435aabd9473db634967686dd8597'),(1511,'c','C只继承了A中的成员 ','2a7a435aabd9473db634967686dd8597'),(1512,'d',' C不能继承A或B中的成员','2a7a435aabd9473db634967686dd8597'),(1513,'a','封装就是将属性私有化，提供共有的方法访问私有属性','462703eb5bd6419e8eabd19880f1bb53'),(1514,'b','属性的访问方法包括setter方法和getter方法','462703eb5bd6419e8eabd19880f1bb53'),(1515,'c','setter方法用于赋值，getter方法用于取值','462703eb5bd6419e8eabd19880f1bb53'),(1516,'d','包含属性的类都必须封装属性，否则无法通过编译 ','462703eb5bd6419e8eabd19880f1bb53'),(1517,'a','equals(Object obj) ','16e156d20b7f48b9ae92c9db129233b5'),(1518,'b','getClass()','16e156d20b7f48b9ae92c9db129233b5'),(1519,'c',' toString()   ','16e156d20b7f48b9ae92c9db129233b5'),(1520,'d','trim() ','16e156d20b7f48b9ae92c9db129233b5'),(1521,'a',' try','6f66eba1cfa1454d94eceb320415fe1b'),(1522,'b','catch','6f66eba1cfa1454d94eceb320415fe1b'),(1523,'c','throw ','6f66eba1cfa1454d94eceb320415fe1b'),(1524,'d','throws ','6f66eba1cfa1454d94eceb320415fe1b'),(1525,'a',' public void aMethod(); ','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1526,'b','void aMethod();','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1527,'c',' protected void aMethod();','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1528,'d','private void aMethod(); ','e33a3c7098ac453a9c5b6d62c3c56b8b'),(1529,'a','super关键字是在子类对象内部指代其父类对象的引用','a65b42bbe6c2437eb40e9bc192d3c381'),(1530,'b',' super关键字不仅可以指代子类的直接父类，还可以指代父类的父类','a65b42bbe6c2437eb40e9bc192d3c381'),(1531,'c',' 子类通过super关键字只能调用父类的方法，而不能调用父类的属性','a65b42bbe6c2437eb40e9bc192d3c381'),(1532,'d','子类通过super关键字只能调用父类的属性，而不能调用父类的方法','a65b42bbe6c2437eb40e9bc192d3c381'),(1533,'a',' 一个类可以继承多个父类','2896d8c737bc4f27824fb85bac44c56f'),(1534,'b','一个类可以具有多个子类','2896d8c737bc4f27824fb85bac44c56f'),(1535,'c','子类可以使用父类的所有方法','2896d8c737bc4f27824fb85bac44c56f'),(1536,'d','子类一定比父类有更多的成员方法','2896d8c737bc4f27824fb85bac44c56f'),(1537,'a','类不一定要显式定义构造函数 ','588fba50948e4005ac646356b762b9bd'),(1538,'b','构造函数的返回类型是void ','588fba50948e4005ac646356b762b9bd'),(1539,'c','如果构造函数不带任何参数，那么构造函数的名称和类名可以不同 ','588fba50948e4005ac646356b762b9bd'),(1540,'d','一个类可以定义多个构造函数','588fba50948e4005ac646356b762b9bd'),(1541,'a','持久化是将程序中数据在瞬时状态和持久状态间转换的机制','afb5261a51ca40f28be67902e29ebe7c'),(1542,'b','瞬时状态是指程序数据保存在内存中，程序退出时，数据就不存在了','afb5261a51ca40f28be67902e29ebe7c'),(1543,'c','把关系数据库中的数据读出来不属于持久化','afb5261a51ca40f28be67902e29ebe7c'),(1544,'d','程序数据直接保存成文本文件属于持久化','afb5261a51ca40f28be67902e29ebe7c'),(1545,'a','Jsp ','55e829ff5bc242868333f9588a7ec9d6'),(1546,'b','javabean','55e829ff5bc242868333f9588a7ec9d6'),(1547,'c','pojo','55e829ff5bc242868333f9588a7ec9d6'),(1548,'b','DAO ','55e829ff5bc242868333f9588a7ec9d6'),(1549,'a','String getParameter(String name)','297d0479c7df487983358b78835c6797'),(1550,'b','String[] getParameter(String name)','297d0479c7df487983358b78835c6797'),(1551,'c','String getParameterValues(String name)','297d0479c7df487983358b78835c6797'),(1552,'d','String[] getParameterValues(String name)','297d0479c7df487983358b78835c6797'),(1553,'a','page','1cbdc697f0504174aa93f5fa5bb1bdba'),(1554,'b','request','1cbdc697f0504174aa93f5fa5bb1bdba'),(1555,'c','session','1cbdc697f0504174aa93f5fa5bb1bdba'),(1556,'d','application','1cbdc697f0504174aa93f5fa5bb1bdba'),(1557,'a','DAO','1dedd6878b164e219a58b070cc7f55f2'),(1558,'b','ValueObject','1dedd6878b164e219a58b070cc7f55f2'),(1559,'c','MVC','1dedd6878b164e219a58b070cc7f55f2'),(1560,'d','Proxy','1dedd6878b164e219a58b070cc7f55f2'),(1561,'a','<filter>','1fb52e896c61430ab7089d2ad9a8e11f'),(1562,'b','<filter-mapping>','1fb52e896c61430ab7089d2ad9a8e11f'),(1563,'c','<servlet>','1fb52e896c61430ab7089d2ad9a8e11f'),(1564,'d','<servlet-mapping>','1fb52e896c61430ab7089d2ad9a8e11f'),(1565,'a','Applet','cdca664b0d22406db81a680ba2992e07'),(1566,'b','JSP','cdca664b0d22406db81a680ba2992e07'),(1567,'c','Servlet','cdca664b0d22406db81a680ba2992e07'),(1568,'d','JavaBean','cdca664b0d22406db81a680ba2992e07'),(1569,'a','HttpServletRequest、getContextPath()','72329b2187b34b27b5cd701c02497955'),(1570,'b','HttpServletRequest、getPathInfo()','72329b2187b34b27b5cd701c02497955'),(1571,'c','ServlettContext、getContextPath()','72329b2187b34b27b5cd701c02497955'),(1572,'d','ServlettContext、getPathInfo()','72329b2187b34b27b5cd701c02497955'),(1573,'a','URL重写','ee37b7456f2c4aa780f5880fac338897'),(1574,'b','Cookie','ee37b7456f2c4aa780f5880fac338897'),(1575,'c','隐藏表单域','ee37b7456f2c4aa780f5880fac338897'),(1576,'d','有状态HTTP协议','ee37b7456f2c4aa780f5880fac338897'),(1577,'a','<jsp:getParam name=\"location\">','5366dc69b6c142c4aed60b7bfd6ec97c'),(1578,'b','<jsp:getParameter name=\"location\">','5366dc69b6c142c4aed60b7bfd6ec97c'),(1579,'c','<%=request.getAttribute(\"location\")%>','5366dc69b6c142c4aed60b7bfd6ec97c'),(1580,'d','<%=request.getParameter(\"location\")%>','5366dc69b6c142c4aed60b7bfd6ec97c'),(1581,'a','POP3 SMTP','ccb000367ed84bfea3e18f03d7028efe'),(1582,'b','POP3 TCP','ccb000367ed84bfea3e18f03d7028efe'),(1583,'c','SMTP TCP','ccb000367ed84bfea3e18f03d7028efe'),(1584,'d','SMTP POP3','ccb000367ed84bfea3e18f03d7028efe'),(1585,'a','2+3','3340719421a340178837663bc78a07d5'),(1586,'b','5.0','3340719421a340178837663bc78a07d5'),(1587,'c','23.0','3340719421a340178837663bc78a07d5'),(1588,'d','不会输出，因为表达式是错误的','3340719421a340178837663bc78a07d5'),(1589,'a','forward','3bc8b36559b94a04a0bb937bffa2c432'),(1590,'b','include','3bc8b36559b94a04a0bb937bffa2c432'),(1591,'c','useBean','3bc8b36559b94a04a0bb937bffa2c432'),(1592,'d','setProperty','3bc8b36559b94a04a0bb937bffa2c432'),(1593,'a','TLD文件','85521921aaab4533b527c3ef044ce2e1'),(1594,'b','DTD文件','85521921aaab4533b527c3ef044ce2e1'),(1595,'c','WAR文件','85521921aaab4533b527c3ef044ce2e1'),(1596,'d','EAR文件','85521921aaab4533b527c3ef044ce2e1'),(1597,'a','<jsp:getProperty>','fbcbb40f929346f48798f7bc5a29c077'),(1598,'b','<Bean:getProperty>','fbcbb40f929346f48798f7bc5a29c077'),(1599,'c','<jsp:getAttrib>','fbcbb40f929346f48798f7bc5a29c077'),(1600,'d','<JavaBean:getProperty>','fbcbb40f929346f48798f7bc5a29c077'),(1601,'a','WEB-INF','c30638dd08b34c06ab3d2d086a35faab'),(1602,'b','APP-INF','c30638dd08b34c06ab3d2d086a35faab'),(1603,'c','META-INF','c30638dd08b34c06ab3d2d086a35faab'),(1604,'d','WEB-INF\\lib','c30638dd08b34c06ab3d2d086a35faab'),(1605,'a','Requestdispatcher','fefd7221d3bf434f8bd238390deed930'),(1606,'b','Responsedispatcher','fefd7221d3bf434f8bd238390deed930'),(1607,'c','Servletdispatcher','fefd7221d3bf434f8bd238390deed930'),(1608,'d','includedispatcher','fefd7221d3bf434f8bd238390deed930'),(1609,'a','Request.getParameter(“ID”)','48517b3b986340ebadcb531175b68b0d'),(1610,'b','Reponse.getParameter(“ID”)','48517b3b986340ebadcb531175b68b0d'),(1611,'c','Request.getAttribute(“ID”)','48517b3b986340ebadcb531175b68b0d'),(1612,'d','Reponse.getAttribute(“ID”)','48517b3b986340ebadcb531175b68b0d'),(1613,'a','SMTP','fab7bcf5532343f289b335d6d3fb6eaf'),(1614,'b','POP3','fab7bcf5532343f289b335d6d3fb6eaf'),(1615,'c','IMAP','fab7bcf5532343f289b335d6d3fb6eaf'),(1616,'d','MIME','fab7bcf5532343f289b335d6d3fb6eaf'),(1617,'a','sleep是线程类（Thread）的方法，wait是Object类的方法','74b9e2aabc7340888e4bebb5b776476b'),(1618,'b','sleep是线程类（Thread）的方法，wait是Object类的方法','74b9e2aabc7340888e4bebb5b776476b'),(1619,'c','sleep暂停线程、但监控状态仍然保持，结束后会自动恢复','74b9e2aabc7340888e4bebb5b776476b'),(1620,'d','wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。','74b9e2aabc7340888e4bebb5b776476b'),(1621,'a','<jsp:getProperty name=\"bean\" property=\"message\"> ','594f1dcedc2a45fea97e0ea56e91a1a1'),(1622,'b','${requestScope.bean.message} ','594f1dcedc2a45fea97e0ea56e91a1a1'),(1623,'c','<%= request.getBean().getMessage() %> ','594f1dcedc2a45fea97e0ea56e91a1a1'),(1624,'d','${bean.message} ','594f1dcedc2a45fea97e0ea56e91a1a1'),(1625,'a','应用服务器','a91784f07138422ea28da88e5bdbcde3'),(1626,'b','虚拟机','a91784f07138422ea28da88e5bdbcde3'),(1627,'c','垃圾回收器','a91784f07138422ea28da88e5bdbcde3'),(1628,'d','编译器','a91784f07138422ea28da88e5bdbcde3'),(1629,'a','一旦一个线程被创建，它就立即开始运行','39e32b60ee064dac8174c2871a07a937'),(1630,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行','39e32b60ee064dac8174c2871a07a937'),(1631,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面','39e32b60ee064dac8174c2871a07a937'),(1632,'d','一个线程可能因为不同的原因停止并进入就绪状态','39e32b60ee064dac8174c2871a07a937'),(1633,'a','OutputStream用于写操作','3be4e1eec011407bbce0afee6505ffca'),(1634,'b','InputStream用于写操作','3be4e1eec011407bbce0afee6505ffca'),(1635,'c','I/O库不支持对文件可读可写API','3be4e1eec011407bbce0afee6505ffca'),(1636,'d','I/O用于多线程','3be4e1eec011407bbce0afee6505ffca'),(1637,'a','switch 不能够作用在String类型上','15f25c4647ed49879f53cd753f74dd78'),(1638,'b',' List， Set， Map都继承自Collection接口','15f25c4647ed49879f53cd753f74dd78'),(1639,'c','Java语言支持goto语句','15f25c4647ed49879f53cd753f74dd78'),(1640,'d',' GC是垃圾收集器，程序员不用担心内存管理','15f25c4647ed49879f53cd753f74dd78'),(1641,'a','线程对象必须实现Runnable接口','94aa5b5a5e304433a461e349efd38dd8'),(1642,'b','启动一个线程直接调用线程对象的run()方法','94aa5b5a5e304433a461e349efd38dd8'),(1643,'c','Java提供对多线程同步提供语言级的支持','94aa5b5a5e304433a461e349efd38dd8'),(1644,'d','一个线程可以包含多个进程','94aa5b5a5e304433a461e349efd38dd8'),(1645,'a','ArrayList myList = new Object();','68014607c39742e49222a276d8b8de8d'),(1646,'b','List myList = new ArrayList();','68014607c39742e49222a276d8b8de8d'),(1647,'c','ArraylList myList = new List();','68014607c39742e49222a276d8b8de8d'),(1648,'d','List myList = new List();','68014607c39742e49222a276d8b8de8d'),(1649,'a','线程对象必须实现Runnable接口','b4deefe615974c4d858b73c36574c41e'),(1650,'b','启动一个线程直接调用线程对象的run()方法','b4deefe615974c4d858b73c36574c41e'),(1651,'c','Java提供对多线程同步提供语言级的支持','b4deefe615974c4d858b73c36574c41e'),(1652,'d',' 一个线程可以包含多个进程','b4deefe615974c4d858b73c36574c41e'),(1653,'a','telnet','b171105de04242d8898be0410dfe86dc'),(1654,'b','netstat','b171105de04242d8898be0410dfe86dc'),(1655,'c','ping','b171105de04242d8898be0410dfe86dc'),(1656,'d','ftp','b171105de04242d8898be0410dfe86dc'),(1657,'a','Java网络编程API建立在Socket基础之上','0107de32f873494fa383e9a1abddad48'),(1658,'b','Java网络接口只支持TCP以及其上层协议','0107de32f873494fa383e9a1abddad48'),(1659,'c','Java网络接口只支持UDP以及其上层协议','0107de32f873494fa383e9a1abddad48'),(1660,'d','Java网络接口支持IP以上的所有高层协议','0107de32f873494fa383e9a1abddad48'),(1661,'a','JSP','638e5d58924f467f9390a7e0cd67f1a6'),(1662,'b','JAVA','638e5d58924f467f9390a7e0cd67f1a6'),(1663,'c','Servlet','638e5d58924f467f9390a7e0cd67f1a6'),(1664,'d','WebService','638e5d58924f467f9390a7e0cd67f1a6'),(1665,'a','通过Http','9881b5ca9f664c3bb45f1d6f22ff5234'),(1666,'b','通过ftp','9881b5ca9f664c3bb45f1d6f22ff5234'),(1667,'c','JNDI','9881b5ca9f664c3bb45f1d6f22ff5234'),(1668,'d','通过Connection对象','9881b5ca9f664c3bb45f1d6f22ff5234'),(1669,'a','JSP会先解释成Servlet源文件，然后编译成Servlet类文件','d9ecd0c469374f22a61b3a997b4737ba'),(1670,'b','每当用户端运行JSP时，jspInit()方法都会运行一次','d9ecd0c469374f22a61b3a997b4737ba'),(1671,'c','每当用户端运行JSP时，_jspService()方法都会运行一次','d9ecd0c469374f22a61b3a997b4737ba'),(1672,'d','每当用户端运行JSP时，jspDestroy()方法都会运行一次','d9ecd0c469374f22a61b3a997b4737ba'),(1673,'a','Model','6f32eb7647e14653ac9b6ee42c6afc75'),(1674,'b','View','6f32eb7647e14653ac9b6ee42c6afc75'),(1675,'c','Collection','6f32eb7647e14653ac9b6ee42c6afc75'),(1676,'d','Controller','6f32eb7647e14653ac9b6ee42c6afc75'),(1677,'a','<c:out>','49c470f72aaa4be2a29c7d12143d92a5'),(1678,'b','<c:if>','49c470f72aaa4be2a29c7d12143d92a5'),(1679,'c','<c:url>','49c470f72aaa4be2a29c7d12143d92a5'),(1680,'d','<c:catch>','49c470f72aaa4be2a29c7d12143d92a5'),(1681,'a','类可以让我们用程序模拟现实世界中的实体','7c89001a5fbb4d04b43a0bddcc190c80'),(1682,'b','有多少个实体就要创建多少个类 ','7c89001a5fbb4d04b43a0bddcc190c80'),(1683,'c','对象的行为和属性被封装在类中，外界通过调用类的方法来获得，但是要知道类的 内部是如何实现 ','7c89001a5fbb4d04b43a0bddcc190c80'),(1684,'d','现实世界中的某些实体不能用类来描述','7c89001a5fbb4d04b43a0bddcc190c80'),(1685,'a','抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承。但是一 个类却可以实现多个接口。','e38bde24d58149c5a9e67fa92ce81ac5'),(1686,'b','在抽象类中可以没有抽象方法 ','e38bde24d58149c5a9e67fa92ce81ac5'),(1687,'c','实现抽象类和接口的类必须实现其中的所有方法，除非它也是抽象类。接口中的方 法都不能被实现 ','e38bde24d58149c5a9e67fa92ce81ac5'),(1688,'d','接口中的方法都必须加上public关键字。','e38bde24d58149c5a9e67fa92ce81ac5'),(1689,'a',' Frame','3e544ea2716043b6a9acf1f1ac37a400'),(1690,'b','Checkbox','3e544ea2716043b6a9acf1f1ac37a400'),(1691,'c',' Panel','3e544ea2716043b6a9acf1f1ac37a400'),(1692,'d','TextField','3e544ea2716043b6a9acf1f1ac37a400'),(1693,'a',' BorderLayout是边框布局，它是窗体的默认布局 ','f30c6491f80d40248c3821d9f7f7fb53'),(1694,'b',' null是空布局，它是面板的默认布局 ','f30c6491f80d40248c3821d9f7f7fb53'),(1695,'c','FlowLayout是流布局，这种布局将其中的组件按照加入的先后顺序从左向右排列，  一行排满之后就转到下一行继续从左至右排列 ','f30c6491f80d40248c3821d9f7f7fb53'),(1696,'d','GridLayout是网格布局，它以矩形网格形式对容器的组件进行布置。容器被分成大 小相等的矩形，一个矩形中放置一个组件 ','f30c6491f80d40248c3821d9f7f7fb53'),(1697,'a','bookTypeList.add(\"小说\"); ','1918e2beb8cf4a488b399edd32d448e9'),(1698,'b','bookTypeList.get(\"小说\"); ','1918e2beb8cf4a488b399edd32d448e9'),(1699,'c','bookTypeList.contains(\"小说\");','1918e2beb8cf4a488b399edd32d448e9'),(1700,'d',' bookTypeList.remove(\"小说\"); ','1918e2beb8cf4a488b399edd32d448e9'),(1701,'a',' this关键字是在对象内部指代自身的引用','8680f59744ba43888754448c66244725'),(1702,'b',' this关键字可以在类中的任何位置使用 ','8680f59744ba43888754448c66244725'),(1703,'c','this关键字和类关联，而不是和特定的对象关联 ','8680f59744ba43888754448c66244725'),(1704,'d','同一个类的不同对象共用一个this','8680f59744ba43888754448c66244725'),(1705,'a','Output is null.             ','da77e5dbc4db455eb53aef765b50e9b0'),(1706,'b','Output is 0 ','da77e5dbc4db455eb53aef765b50e9b0'),(1707,'c','编译时报错 ','da77e5dbc4db455eb53aef765b50e9b0'),(1708,'d','运行时报错','da77e5dbc4db455eb53aef765b50e9b0'),(1709,'a',' C不仅继承了B中的成员，同样也继承了A中的成员 ','a16d4a100c184469925ba2f098ccfb00'),(1710,'b','C只继承了B中的成员','a16d4a100c184469925ba2f098ccfb00'),(1711,'c','C只继承了A中的成员 ','a16d4a100c184469925ba2f098ccfb00'),(1712,'d',' C不能继承A或B中的成员','a16d4a100c184469925ba2f098ccfb00'),(1713,'a','封装就是将属性私有化，提供共有的方法访问私有属性','23a7da6daa904a91830751b1ca959756'),(1714,'b','属性的访问方法包括setter方法和getter方法','23a7da6daa904a91830751b1ca959756'),(1715,'c','setter方法用于赋值，getter方法用于取值','23a7da6daa904a91830751b1ca959756'),(1716,'d','包含属性的类都必须封装属性，否则无法通过编译 ','23a7da6daa904a91830751b1ca959756'),(1717,'a','equals(Object obj) ','b8f301502d164cfe95b05ecc73c79f05'),(1718,'b','getClass()','b8f301502d164cfe95b05ecc73c79f05'),(1719,'c',' toString()   ','b8f301502d164cfe95b05ecc73c79f05'),(1720,'d','trim() ','b8f301502d164cfe95b05ecc73c79f05'),(1721,'a',' try','03147897644546c9a9013ba8a147fa6d'),(1722,'b','catch','03147897644546c9a9013ba8a147fa6d'),(1723,'c','throw ','03147897644546c9a9013ba8a147fa6d'),(1724,'d','throws ','03147897644546c9a9013ba8a147fa6d'),(1725,'a',' public void aMethod(); ','f28f1de3b0844e13a0339bb8c9dd9c21'),(1726,'b','void aMethod();','f28f1de3b0844e13a0339bb8c9dd9c21'),(1727,'c',' protected void aMethod();','f28f1de3b0844e13a0339bb8c9dd9c21'),(1728,'d','private void aMethod(); ','f28f1de3b0844e13a0339bb8c9dd9c21'),(1729,'a','super关键字是在子类对象内部指代其父类对象的引用','0bec17b5cdf24b9fa4f3d2589805d1a9'),(1730,'b',' super关键字不仅可以指代子类的直接父类，还可以指代父类的父类','0bec17b5cdf24b9fa4f3d2589805d1a9'),(1731,'c',' 子类通过super关键字只能调用父类的方法，而不能调用父类的属性','0bec17b5cdf24b9fa4f3d2589805d1a9'),(1732,'d','子类通过super关键字只能调用父类的属性，而不能调用父类的方法','0bec17b5cdf24b9fa4f3d2589805d1a9'),(1733,'a',' 一个类可以继承多个父类','a6690bb3880e41558793cefcd4716e4f'),(1734,'b','一个类可以具有多个子类','a6690bb3880e41558793cefcd4716e4f'),(1735,'c','子类可以使用父类的所有方法','a6690bb3880e41558793cefcd4716e4f'),(1736,'d','子类一定比父类有更多的成员方法','a6690bb3880e41558793cefcd4716e4f'),(1737,'a','类不一定要显式定义构造函数 ','46cb8790d15541388561e5a973369732'),(1738,'b','构造函数的返回类型是void ','46cb8790d15541388561e5a973369732'),(1739,'c','如果构造函数不带任何参数，那么构造函数的名称和类名可以不同 ','46cb8790d15541388561e5a973369732'),(1740,'d','一个类可以定义多个构造函数','46cb8790d15541388561e5a973369732'),(1741,'a','持久化是将程序中数据在瞬时状态和持久状态间转换的机制','9931855ba5654b229d0823ad9ab8a5da'),(1742,'b','瞬时状态是指程序数据保存在内存中，程序退出时，数据就不存在了','9931855ba5654b229d0823ad9ab8a5da'),(1743,'c','把关系数据库中的数据读出来不属于持久化','9931855ba5654b229d0823ad9ab8a5da'),(1744,'d','程序数据直接保存成文本文件属于持久化','9931855ba5654b229d0823ad9ab8a5da'),(1745,'a','Jsp ','cecc2419ee64492592296b98fa88784a'),(1746,'b','javabean','cecc2419ee64492592296b98fa88784a'),(1747,'c','pojo','cecc2419ee64492592296b98fa88784a'),(1748,'b','DAO ','cecc2419ee64492592296b98fa88784a'),(1749,'a','String getParameter(String name)','97b4113429124586817a723573f559b8'),(1750,'b','String[] getParameter(String name)','97b4113429124586817a723573f559b8'),(1751,'c','String getParameterValues(String name)','97b4113429124586817a723573f559b8'),(1752,'d','String[] getParameterValues(String name)','97b4113429124586817a723573f559b8'),(1753,'a','page','93d48f2c919543ceb58c404f9bb5868d'),(1754,'b','request','93d48f2c919543ceb58c404f9bb5868d'),(1755,'c','session','93d48f2c919543ceb58c404f9bb5868d'),(1756,'d','application','93d48f2c919543ceb58c404f9bb5868d'),(1757,'a','DAO','dcb5310dacc147ec8502d1638f4b4d54'),(1758,'b','ValueObject','dcb5310dacc147ec8502d1638f4b4d54'),(1759,'c','MVC','dcb5310dacc147ec8502d1638f4b4d54'),(1760,'d','Proxy','dcb5310dacc147ec8502d1638f4b4d54'),(1761,'a','<filter>','dfbbcccbd989440cb266c90f99ab6870'),(1762,'b','<filter-mapping>','dfbbcccbd989440cb266c90f99ab6870'),(1763,'c','<servlet>','dfbbcccbd989440cb266c90f99ab6870'),(1764,'d','<servlet-mapping>','dfbbcccbd989440cb266c90f99ab6870'),(1765,'a','Applet','350e9a62ce3b46138cf0079d4b879410'),(1766,'b','JSP','350e9a62ce3b46138cf0079d4b879410'),(1767,'c','Servlet','350e9a62ce3b46138cf0079d4b879410'),(1768,'d','JavaBean','350e9a62ce3b46138cf0079d4b879410'),(1769,'a','HttpServletRequest、getContextPath()','37bdadaa708c4406802ef093a48b1c05'),(1770,'b','HttpServletRequest、getPathInfo()','37bdadaa708c4406802ef093a48b1c05'),(1771,'c','ServlettContext、getContextPath()','37bdadaa708c4406802ef093a48b1c05'),(1772,'d','ServlettContext、getPathInfo()','37bdadaa708c4406802ef093a48b1c05'),(1773,'a','URL重写','c4abbe5d6be8402b8dab1852218a8096'),(1774,'b','Cookie','c4abbe5d6be8402b8dab1852218a8096'),(1775,'c','隐藏表单域','c4abbe5d6be8402b8dab1852218a8096'),(1776,'d','有状态HTTP协议','c4abbe5d6be8402b8dab1852218a8096'),(1777,'a','<jsp:getParam name=\"location\">','003da51b8a8a4e2baa66fc56083c55e1'),(1778,'b','<jsp:getParameter name=\"location\">','003da51b8a8a4e2baa66fc56083c55e1'),(1779,'c','<%=request.getAttribute(\"location\")%>','003da51b8a8a4e2baa66fc56083c55e1'),(1780,'d','<%=request.getParameter(\"location\")%>','003da51b8a8a4e2baa66fc56083c55e1'),(1781,'a','POP3 SMTP','dc9c9b3815014439a5918f6abf99a57c'),(1782,'b','POP3 TCP','dc9c9b3815014439a5918f6abf99a57c'),(1783,'c','SMTP TCP','dc9c9b3815014439a5918f6abf99a57c'),(1784,'d','SMTP POP3','dc9c9b3815014439a5918f6abf99a57c'),(1785,'a','2+3','0027848a71ef4fd6b32e26231d57fad8'),(1786,'b','5.0','0027848a71ef4fd6b32e26231d57fad8'),(1787,'c','23.0','0027848a71ef4fd6b32e26231d57fad8'),(1788,'d','不会输出，因为表达式是错误的','0027848a71ef4fd6b32e26231d57fad8'),(1789,'a','forward','17a4e16983bd4b56bbd5a1f2a9136bfb'),(1790,'b','include','17a4e16983bd4b56bbd5a1f2a9136bfb'),(1791,'c','useBean','17a4e16983bd4b56bbd5a1f2a9136bfb'),(1792,'d','setProperty','17a4e16983bd4b56bbd5a1f2a9136bfb'),(1793,'a','TLD文件','2400bc5f55dc4de4bf4010b096a363b7'),(1794,'b','DTD文件','2400bc5f55dc4de4bf4010b096a363b7'),(1795,'c','WAR文件','2400bc5f55dc4de4bf4010b096a363b7'),(1796,'d','EAR文件','2400bc5f55dc4de4bf4010b096a363b7'),(1797,'a','<jsp:getProperty>','692fa2e4a02240d4ae67db4b43738846'),(1798,'b','<Bean:getProperty>','692fa2e4a02240d4ae67db4b43738846'),(1799,'c','<jsp:getAttrib>','692fa2e4a02240d4ae67db4b43738846'),(1800,'d','<JavaBean:getProperty>','692fa2e4a02240d4ae67db4b43738846'),(1801,'a','WEB-INF','08b43969104a49748831686fe64ca7f5'),(1802,'b','APP-INF','08b43969104a49748831686fe64ca7f5'),(1803,'c','META-INF','08b43969104a49748831686fe64ca7f5'),(1804,'d','WEB-INF\\lib','08b43969104a49748831686fe64ca7f5'),(1805,'a','Requestdispatcher','a0740e1949324df8967947674f78a8ad'),(1806,'b','Responsedispatcher','a0740e1949324df8967947674f78a8ad'),(1807,'c','Servletdispatcher','a0740e1949324df8967947674f78a8ad'),(1808,'d','includedispatcher','a0740e1949324df8967947674f78a8ad'),(1809,'a','Request.getParameter(“ID”)','4fca9d0f4e4c4cf0bf42759d5bae04f9'),(1810,'b','Reponse.getParameter(“ID”)','4fca9d0f4e4c4cf0bf42759d5bae04f9'),(1811,'c','Request.getAttribute(“ID”)','4fca9d0f4e4c4cf0bf42759d5bae04f9'),(1812,'d','Reponse.getAttribute(“ID”)','4fca9d0f4e4c4cf0bf42759d5bae04f9'),(1813,'a','SMTP','aa1cfc50092d417abe01f2f721ef7e18'),(1814,'b','POP3','aa1cfc50092d417abe01f2f721ef7e18'),(1815,'c','IMAP','aa1cfc50092d417abe01f2f721ef7e18'),(1816,'d','MIME','aa1cfc50092d417abe01f2f721ef7e18'),(1817,'a','sleep是线程类（Thread）的方法，wait是Object类的方法','e6ca12ed6b73477c8acacde5b107aa3d'),(1818,'b','sleep是线程类（Thread）的方法，wait是Object类的方法','e6ca12ed6b73477c8acacde5b107aa3d'),(1819,'c','sleep暂停线程、但监控状态仍然保持，结束后会自动恢复','e6ca12ed6b73477c8acacde5b107aa3d'),(1820,'d','wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。','e6ca12ed6b73477c8acacde5b107aa3d'),(1821,'a','<jsp:getProperty name=\"bean\" property=\"message\"> ','ac3fb13976ff4aceb878cf7bf34bea9a'),(1822,'b','${requestScope.bean.message} ','ac3fb13976ff4aceb878cf7bf34bea9a'),(1823,'c','<%= request.getBean().getMessage() %> ','ac3fb13976ff4aceb878cf7bf34bea9a'),(1824,'d','${bean.message} ','ac3fb13976ff4aceb878cf7bf34bea9a'),(1825,'a','应用服务器','a8153429f5ff44d2913150981e776622'),(1826,'b','虚拟机','a8153429f5ff44d2913150981e776622'),(1827,'c','垃圾回收器','a8153429f5ff44d2913150981e776622'),(1828,'d','编译器','a8153429f5ff44d2913150981e776622'),(1829,'a','一旦一个线程被创建，它就立即开始运行','d6a48ad41ca84fc4815d11e72356c5ff'),(1830,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行','d6a48ad41ca84fc4815d11e72356c5ff'),(1831,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面','d6a48ad41ca84fc4815d11e72356c5ff'),(1832,'d','一个线程可能因为不同的原因停止并进入就绪状态','d6a48ad41ca84fc4815d11e72356c5ff'),(1833,'a','OutputStream用于写操作','2d7e4b98be4447198cb6f7080b602579'),(1834,'b','InputStream用于写操作','2d7e4b98be4447198cb6f7080b602579'),(1835,'c','I/O库不支持对文件可读可写API','2d7e4b98be4447198cb6f7080b602579'),(1836,'d','I/O用于多线程','2d7e4b98be4447198cb6f7080b602579'),(1837,'a','switch 不能够作用在String类型上','18794fa8e8284c849c02f627d9b0a0c4'),(1838,'b',' List， Set， Map都继承自Collection接口','18794fa8e8284c849c02f627d9b0a0c4'),(1839,'c','Java语言支持goto语句','18794fa8e8284c849c02f627d9b0a0c4'),(1840,'d',' GC是垃圾收集器，程序员不用担心内存管理','18794fa8e8284c849c02f627d9b0a0c4'),(1841,'a','线程对象必须实现Runnable接口','cac67d440e664fccbbe459011c0745a4'),(1842,'b','启动一个线程直接调用线程对象的run()方法','cac67d440e664fccbbe459011c0745a4'),(1843,'c','Java提供对多线程同步提供语言级的支持','cac67d440e664fccbbe459011c0745a4'),(1844,'d','一个线程可以包含多个进程','cac67d440e664fccbbe459011c0745a4'),(1845,'a','ArrayList myList = new Object();','6acf1fb6a2d24cf99bf5fb8e7e985e49'),(1846,'b','List myList = new ArrayList();','6acf1fb6a2d24cf99bf5fb8e7e985e49'),(1847,'c','ArraylList myList = new List();','6acf1fb6a2d24cf99bf5fb8e7e985e49'),(1848,'d','List myList = new List();','6acf1fb6a2d24cf99bf5fb8e7e985e49'),(1849,'a','线程对象必须实现Runnable接口','7fd1904f5e54463a8f74200a9467c5a8'),(1850,'b','启动一个线程直接调用线程对象的run()方法','7fd1904f5e54463a8f74200a9467c5a8'),(1851,'c','Java提供对多线程同步提供语言级的支持','7fd1904f5e54463a8f74200a9467c5a8'),(1852,'d',' 一个线程可以包含多个进程','7fd1904f5e54463a8f74200a9467c5a8'),(1853,'a','telnet','ed7970d17171416c88057ae5ad29de22'),(1854,'b','netstat','ed7970d17171416c88057ae5ad29de22'),(1855,'c','ping','ed7970d17171416c88057ae5ad29de22'),(1856,'d','ftp','ed7970d17171416c88057ae5ad29de22'),(1857,'a','Java网络编程API建立在Socket基础之上','2d7b877ae08340de919a5d60692c40eb'),(1858,'b','Java网络接口只支持TCP以及其上层协议','2d7b877ae08340de919a5d60692c40eb'),(1859,'c','Java网络接口只支持UDP以及其上层协议','2d7b877ae08340de919a5d60692c40eb'),(1860,'d','Java网络接口支持IP以上的所有高层协议','2d7b877ae08340de919a5d60692c40eb'),(1861,'a','JSP','f354fa95401c47ab813f0fb32eb643ad'),(1862,'b','JAVA','f354fa95401c47ab813f0fb32eb643ad'),(1863,'c','Servlet','f354fa95401c47ab813f0fb32eb643ad'),(1864,'d','WebService','f354fa95401c47ab813f0fb32eb643ad'),(1865,'a','通过Http','565143c36d0e432c9355fb096ecd7768'),(1866,'b','通过ftp','565143c36d0e432c9355fb096ecd7768'),(1867,'c','JNDI','565143c36d0e432c9355fb096ecd7768'),(1868,'d','通过Connection对象','565143c36d0e432c9355fb096ecd7768'),(1869,'a','JSP会先解释成Servlet源文件，然后编译成Servlet类文件','2b171df85b4548e8bc6f46a0046e496e'),(1870,'b','每当用户端运行JSP时，jspInit()方法都会运行一次','2b171df85b4548e8bc6f46a0046e496e'),(1871,'c','每当用户端运行JSP时，_jspService()方法都会运行一次','2b171df85b4548e8bc6f46a0046e496e'),(1872,'d','每当用户端运行JSP时，jspDestroy()方法都会运行一次','2b171df85b4548e8bc6f46a0046e496e'),(1873,'a','Model','8cef7b5b21a44874ac7af50a1d5a3382'),(1874,'b','View','8cef7b5b21a44874ac7af50a1d5a3382'),(1875,'c','Collection','8cef7b5b21a44874ac7af50a1d5a3382'),(1876,'d','Controller','8cef7b5b21a44874ac7af50a1d5a3382'),(1877,'a','<c:out>','4d4a848543b74a708fd5df2230be027f'),(1878,'b','<c:if>','4d4a848543b74a708fd5df2230be027f'),(1879,'c','<c:url>','4d4a848543b74a708fd5df2230be027f'),(1880,'d','<c:catch>','4d4a848543b74a708fd5df2230be027f'),(1881,'a','类可以让我们用程序模拟现实世界中的实体','2192b2013e7549b69fec9b9ff923bbed'),(1882,'b','有多少个实体就要创建多少个类 ','2192b2013e7549b69fec9b9ff923bbed'),(1883,'c','对象的行为和属性被封装在类中，外界通过调用类的方法来获得，但是要知道类的 内部是如何实现 ','2192b2013e7549b69fec9b9ff923bbed'),(1884,'d','现实世界中的某些实体不能用类来描述','2192b2013e7549b69fec9b9ff923bbed'),(1885,'a','抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承。但是一 个类却可以实现多个接口。','13f5212a4f674d9bb151196a1025b471'),(1886,'b','在抽象类中可以没有抽象方法 ','13f5212a4f674d9bb151196a1025b471'),(1887,'c','实现抽象类和接口的类必须实现其中的所有方法，除非它也是抽象类。接口中的方 法都不能被实现 ','13f5212a4f674d9bb151196a1025b471'),(1888,'d','接口中的方法都必须加上public关键字。','13f5212a4f674d9bb151196a1025b471'),(1889,'a',' Frame','1b1cce5c6d044599b308511fc9a3597f'),(1890,'b','Checkbox','1b1cce5c6d044599b308511fc9a3597f'),(1891,'c',' Panel','1b1cce5c6d044599b308511fc9a3597f'),(1892,'d','TextField','1b1cce5c6d044599b308511fc9a3597f'),(1893,'a',' BorderLayout是边框布局，它是窗体的默认布局 ','830161e7efa54937bdcc92bacb9c5872'),(1894,'b',' null是空布局，它是面板的默认布局 ','830161e7efa54937bdcc92bacb9c5872'),(1895,'c','FlowLayout是流布局，这种布局将其中的组件按照加入的先后顺序从左向右排列，  一行排满之后就转到下一行继续从左至右排列 ','830161e7efa54937bdcc92bacb9c5872'),(1896,'d','GridLayout是网格布局，它以矩形网格形式对容器的组件进行布置。容器被分成大 小相等的矩形，一个矩形中放置一个组件 ','830161e7efa54937bdcc92bacb9c5872'),(1897,'a','bookTypeList.add(\"小说\"); ','71be85c182a743448e1dc392bb039ce9'),(1898,'b','bookTypeList.get(\"小说\"); ','71be85c182a743448e1dc392bb039ce9'),(1899,'c','bookTypeList.contains(\"小说\");','71be85c182a743448e1dc392bb039ce9'),(1900,'d',' bookTypeList.remove(\"小说\"); ','71be85c182a743448e1dc392bb039ce9'),(1901,'a',' this关键字是在对象内部指代自身的引用','3f49c7cd34bc4f0e9e9a18e4a26e455b'),(1902,'b',' this关键字可以在类中的任何位置使用 ','3f49c7cd34bc4f0e9e9a18e4a26e455b'),(1903,'c','this关键字和类关联，而不是和特定的对象关联 ','3f49c7cd34bc4f0e9e9a18e4a26e455b'),(1904,'d','同一个类的不同对象共用一个this','3f49c7cd34bc4f0e9e9a18e4a26e455b'),(1905,'a','Output is null.             ','27c717cb8a19469e882a2922a6c5ea52'),(1906,'b','Output is 0 ','27c717cb8a19469e882a2922a6c5ea52'),(1907,'c','编译时报错 ','27c717cb8a19469e882a2922a6c5ea52'),(1908,'d','运行时报错','27c717cb8a19469e882a2922a6c5ea52'),(1909,'a',' C不仅继承了B中的成员，同样也继承了A中的成员 ','b69a22c014584bcb9fff5fb141adb006'),(1910,'b','C只继承了B中的成员','b69a22c014584bcb9fff5fb141adb006'),(1911,'c','C只继承了A中的成员 ','b69a22c014584bcb9fff5fb141adb006'),(1912,'d',' C不能继承A或B中的成员','b69a22c014584bcb9fff5fb141adb006'),(1913,'a','封装就是将属性私有化，提供共有的方法访问私有属性','52f1b9db3e734f44b3743bd780ed0857'),(1914,'b','属性的访问方法包括setter方法和getter方法','52f1b9db3e734f44b3743bd780ed0857'),(1915,'c','setter方法用于赋值，getter方法用于取值','52f1b9db3e734f44b3743bd780ed0857'),(1916,'d','包含属性的类都必须封装属性，否则无法通过编译 ','52f1b9db3e734f44b3743bd780ed0857'),(1917,'a','equals(Object obj) ','bfb3410b1a8c4929bd2a01237b55913f'),(1918,'b','getClass()','bfb3410b1a8c4929bd2a01237b55913f'),(1919,'c',' toString()   ','bfb3410b1a8c4929bd2a01237b55913f'),(1920,'d','trim() ','bfb3410b1a8c4929bd2a01237b55913f'),(1921,'a',' try','40d9c0a463fc40a69a807c2eb3ad6463'),(1922,'b','catch','40d9c0a463fc40a69a807c2eb3ad6463'),(1923,'c','throw ','40d9c0a463fc40a69a807c2eb3ad6463'),(1924,'d','throws ','40d9c0a463fc40a69a807c2eb3ad6463'),(1925,'a',' public void aMethod(); ','c0d7f49739dd4e849e7bdac0055c1a48'),(1926,'b','void aMethod();','c0d7f49739dd4e849e7bdac0055c1a48'),(1927,'c',' protected void aMethod();','c0d7f49739dd4e849e7bdac0055c1a48'),(1928,'d','private void aMethod(); ','c0d7f49739dd4e849e7bdac0055c1a48'),(1929,'a','super关键字是在子类对象内部指代其父类对象的引用','14cca6e3ef854bb397efb0aadfa31d63'),(1930,'b',' super关键字不仅可以指代子类的直接父类，还可以指代父类的父类','14cca6e3ef854bb397efb0aadfa31d63'),(1931,'c',' 子类通过super关键字只能调用父类的方法，而不能调用父类的属性','14cca6e3ef854bb397efb0aadfa31d63'),(1932,'d','子类通过super关键字只能调用父类的属性，而不能调用父类的方法','14cca6e3ef854bb397efb0aadfa31d63'),(1933,'a',' 一个类可以继承多个父类','165a378ebfc2416e8a266ab7b018e38a'),(1934,'b','一个类可以具有多个子类','165a378ebfc2416e8a266ab7b018e38a'),(1935,'c','子类可以使用父类的所有方法','165a378ebfc2416e8a266ab7b018e38a'),(1936,'d','子类一定比父类有更多的成员方法','165a378ebfc2416e8a266ab7b018e38a'),(1937,'a','类不一定要显式定义构造函数 ','f48e3a6fc8c14a648b1ccf860b763de5'),(1938,'b','构造函数的返回类型是void ','f48e3a6fc8c14a648b1ccf860b763de5'),(1939,'c','如果构造函数不带任何参数，那么构造函数的名称和类名可以不同 ','f48e3a6fc8c14a648b1ccf860b763de5'),(1940,'d','一个类可以定义多个构造函数','f48e3a6fc8c14a648b1ccf860b763de5'),(1941,'a','持久化是将程序中数据在瞬时状态和持久状态间转换的机制','ac4bd20ee9304f189869a40ff0cefcc1'),(1942,'b','瞬时状态是指程序数据保存在内存中，程序退出时，数据就不存在了','ac4bd20ee9304f189869a40ff0cefcc1'),(1943,'c','把关系数据库中的数据读出来不属于持久化','ac4bd20ee9304f189869a40ff0cefcc1'),(1944,'d','程序数据直接保存成文本文件属于持久化','ac4bd20ee9304f189869a40ff0cefcc1'),(1945,'a','Jsp ','4ff77a9c28be4d87a040673fcd90093e'),(1946,'b','javabean','4ff77a9c28be4d87a040673fcd90093e'),(1947,'c','pojo','4ff77a9c28be4d87a040673fcd90093e'),(1948,'b','DAO ','4ff77a9c28be4d87a040673fcd90093e'),(1949,'a','String getParameter(String name)','c6418c4b353e493bb8d55f67780021aa'),(1950,'b','String[] getParameter(String name)','c6418c4b353e493bb8d55f67780021aa'),(1951,'c','String getParameterValues(String name)','c6418c4b353e493bb8d55f67780021aa'),(1952,'d','String[] getParameterValues(String name)','c6418c4b353e493bb8d55f67780021aa'),(1953,'a','page','e64ba6758d30412d9215cec1b30a7b54'),(1954,'b','request','e64ba6758d30412d9215cec1b30a7b54'),(1955,'c','session','e64ba6758d30412d9215cec1b30a7b54'),(1956,'d','application','e64ba6758d30412d9215cec1b30a7b54'),(1957,'a','DAO','cf95fb31e0564b258377783cb70616bf'),(1958,'b','ValueObject','cf95fb31e0564b258377783cb70616bf'),(1959,'c','MVC','cf95fb31e0564b258377783cb70616bf'),(1960,'d','Proxy','cf95fb31e0564b258377783cb70616bf'),(1961,'a','<filter>','d9b2686b63344450ab2a1ef25f804b3a'),(1962,'b','<filter-mapping>','d9b2686b63344450ab2a1ef25f804b3a'),(1963,'c','<servlet>','d9b2686b63344450ab2a1ef25f804b3a'),(1964,'d','<servlet-mapping>','d9b2686b63344450ab2a1ef25f804b3a'),(1965,'a','Applet','56ac150c7fe9491f8f97c155e1e7435d'),(1966,'b','JSP','56ac150c7fe9491f8f97c155e1e7435d'),(1967,'c','Servlet','56ac150c7fe9491f8f97c155e1e7435d'),(1968,'d','JavaBean','56ac150c7fe9491f8f97c155e1e7435d'),(1969,'a','HttpServletRequest、getContextPath()','d43078beda5a41d8b59bea9ac51fde20'),(1970,'b','HttpServletRequest、getPathInfo()','d43078beda5a41d8b59bea9ac51fde20'),(1971,'c','ServlettContext、getContextPath()','d43078beda5a41d8b59bea9ac51fde20'),(1972,'d','ServlettContext、getPathInfo()','d43078beda5a41d8b59bea9ac51fde20'),(1973,'a','URL重写','35eef0aa148a4aaabe115630208f097f'),(1974,'b','Cookie','35eef0aa148a4aaabe115630208f097f'),(1975,'c','隐藏表单域','35eef0aa148a4aaabe115630208f097f'),(1976,'d','有状态HTTP协议','35eef0aa148a4aaabe115630208f097f'),(1977,'a','<jsp:getParam name=\"location\">','d4deecb7a92445a2bad722ceebd734db'),(1978,'b','<jsp:getParameter name=\"location\">','d4deecb7a92445a2bad722ceebd734db'),(1979,'c','<%=request.getAttribute(\"location\")%>','d4deecb7a92445a2bad722ceebd734db'),(1980,'d','<%=request.getParameter(\"location\")%>','d4deecb7a92445a2bad722ceebd734db'),(1981,'a','POP3 SMTP','8659e8558057407d916ac46c076ddeb6'),(1982,'b','POP3 TCP','8659e8558057407d916ac46c076ddeb6'),(1983,'c','SMTP TCP','8659e8558057407d916ac46c076ddeb6'),(1984,'d','SMTP POP3','8659e8558057407d916ac46c076ddeb6'),(1985,'a','2+3','12a8af5c01bc48a9984ffe9f4ba1dd9d'),(1986,'b','5.0','12a8af5c01bc48a9984ffe9f4ba1dd9d'),(1987,'c','23.0','12a8af5c01bc48a9984ffe9f4ba1dd9d'),(1988,'d','不会输出，因为表达式是错误的','12a8af5c01bc48a9984ffe9f4ba1dd9d'),(1989,'a','forward','f5278b6690224ca8ba8451a1d42e4f50'),(1990,'b','include','f5278b6690224ca8ba8451a1d42e4f50'),(1991,'c','useBean','f5278b6690224ca8ba8451a1d42e4f50'),(1992,'d','setProperty','f5278b6690224ca8ba8451a1d42e4f50'),(1993,'a','TLD文件','749c0a104669457aa2450dc93c950956'),(1994,'b','DTD文件','749c0a104669457aa2450dc93c950956'),(1995,'c','WAR文件','749c0a104669457aa2450dc93c950956'),(1996,'d','EAR文件','749c0a104669457aa2450dc93c950956'),(1997,'a','<jsp:getProperty>','5cef17afc56a4eae9c7d97da884a7bca'),(1998,'b','<Bean:getProperty>','5cef17afc56a4eae9c7d97da884a7bca'),(1999,'c','<jsp:getAttrib>','5cef17afc56a4eae9c7d97da884a7bca'),(2000,'d','<JavaBean:getProperty>','5cef17afc56a4eae9c7d97da884a7bca'),(2001,'a','WEB-INF','52f0938d4e4041a39392ddae83dadbb7'),(2002,'b','APP-INF','52f0938d4e4041a39392ddae83dadbb7'),(2003,'c','META-INF','52f0938d4e4041a39392ddae83dadbb7'),(2004,'d','WEB-INF\\lib','52f0938d4e4041a39392ddae83dadbb7'),(2005,'a','Requestdispatcher','d737d9ef20c1446984d3fe682ba1c0b5'),(2006,'b','Responsedispatcher','d737d9ef20c1446984d3fe682ba1c0b5'),(2007,'c','Servletdispatcher','d737d9ef20c1446984d3fe682ba1c0b5'),(2008,'d','includedispatcher','d737d9ef20c1446984d3fe682ba1c0b5'),(2009,'a','Request.getParameter(“ID”)','33fb760f316141f495bb943994f95b55'),(2010,'b','Reponse.getParameter(“ID”)','33fb760f316141f495bb943994f95b55'),(2011,'c','Request.getAttribute(“ID”)','33fb760f316141f495bb943994f95b55'),(2012,'d','Reponse.getAttribute(“ID”)','33fb760f316141f495bb943994f95b55'),(2013,'a','SMTP','19d9fcd308024a9180cc1d9d609bfaef'),(2014,'b','POP3','19d9fcd308024a9180cc1d9d609bfaef'),(2015,'c','IMAP','19d9fcd308024a9180cc1d9d609bfaef'),(2016,'d','MIME','19d9fcd308024a9180cc1d9d609bfaef'),(2017,'a','sleep是线程类（Thread）的方法，wait是Object类的方法','01556a776dec4646a19fdb1c64e55ae7'),(2018,'b','sleep是线程类（Thread）的方法，wait是Object类的方法','01556a776dec4646a19fdb1c64e55ae7'),(2019,'c','sleep暂停线程、但监控状态仍然保持，结束后会自动恢复','01556a776dec4646a19fdb1c64e55ae7'),(2020,'d','wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。','01556a776dec4646a19fdb1c64e55ae7'),(2021,'a','<jsp:getProperty name=\"bean\" property=\"message\"> ','6fd9c534cbf5458f88d17c3929e17f1a'),(2022,'b','${requestScope.bean.message} ','6fd9c534cbf5458f88d17c3929e17f1a'),(2023,'c','<%= request.getBean().getMessage() %> ','6fd9c534cbf5458f88d17c3929e17f1a'),(2024,'d','${bean.message} ','6fd9c534cbf5458f88d17c3929e17f1a'),(2025,'a','应用服务器','f19e6b62a94b4f9aafcd60145297e9e7'),(2026,'b','虚拟机','f19e6b62a94b4f9aafcd60145297e9e7'),(2027,'c','垃圾回收器','f19e6b62a94b4f9aafcd60145297e9e7'),(2028,'d','编译器','f19e6b62a94b4f9aafcd60145297e9e7'),(2029,'a','一旦一个线程被创建，它就立即开始运行','265d006e5daa4440800685aab785c0c0'),(2030,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行','265d006e5daa4440800685aab785c0c0'),(2031,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面','265d006e5daa4440800685aab785c0c0'),(2032,'d','一个线程可能因为不同的原因停止并进入就绪状态','265d006e5daa4440800685aab785c0c0'),(2033,'a','OutputStream用于写操作','4e1f1f6dcba9443091927b560c6f4f0e'),(2034,'b','InputStream用于写操作','4e1f1f6dcba9443091927b560c6f4f0e'),(2035,'c','I/O库不支持对文件可读可写API','4e1f1f6dcba9443091927b560c6f4f0e'),(2036,'d','I/O用于多线程','4e1f1f6dcba9443091927b560c6f4f0e'),(2037,'a','switch 不能够作用在String类型上','6214b31fd5df4d2686b2e12e705795bb'),(2038,'b',' List， Set， Map都继承自Collection接口','6214b31fd5df4d2686b2e12e705795bb'),(2039,'c','Java语言支持goto语句','6214b31fd5df4d2686b2e12e705795bb'),(2040,'d',' GC是垃圾收集器，程序员不用担心内存管理','6214b31fd5df4d2686b2e12e705795bb'),(2041,'a','线程对象必须实现Runnable接口','32ef4289799a4ed39203b2d66108fbc6'),(2042,'b','启动一个线程直接调用线程对象的run()方法','32ef4289799a4ed39203b2d66108fbc6'),(2043,'c','Java提供对多线程同步提供语言级的支持','32ef4289799a4ed39203b2d66108fbc6'),(2044,'d','一个线程可以包含多个进程','32ef4289799a4ed39203b2d66108fbc6'),(2045,'a','ArrayList myList = new Object();','d2210e77b3214dd29100626b79a5dc1a'),(2046,'b','List myList = new ArrayList();','d2210e77b3214dd29100626b79a5dc1a'),(2047,'c','ArraylList myList = new List();','d2210e77b3214dd29100626b79a5dc1a'),(2048,'d','List myList = new List();','d2210e77b3214dd29100626b79a5dc1a'),(2049,'a','线程对象必须实现Runnable接口','fb0710342c554d65803f72dbb2e6a66f'),(2050,'b','启动一个线程直接调用线程对象的run()方法','fb0710342c554d65803f72dbb2e6a66f'),(2051,'c','Java提供对多线程同步提供语言级的支持','fb0710342c554d65803f72dbb2e6a66f'),(2052,'d',' 一个线程可以包含多个进程','fb0710342c554d65803f72dbb2e6a66f'),(2053,'a','telnet','0499715fdfe642a79268a904d2ac3a97'),(2054,'b','netstat','0499715fdfe642a79268a904d2ac3a97'),(2055,'c','ping','0499715fdfe642a79268a904d2ac3a97'),(2056,'d','ftp','0499715fdfe642a79268a904d2ac3a97'),(2057,'a','Java网络编程API建立在Socket基础之上','6754cad30abd4c40a38424cd0fe79c2f'),(2058,'b','Java网络接口只支持TCP以及其上层协议','6754cad30abd4c40a38424cd0fe79c2f'),(2059,'c','Java网络接口只支持UDP以及其上层协议','6754cad30abd4c40a38424cd0fe79c2f'),(2060,'d','Java网络接口支持IP以上的所有高层协议','6754cad30abd4c40a38424cd0fe79c2f'),(2061,'a','JSP','1450df9964fd47a68c02488519c85338'),(2062,'b','JAVA','1450df9964fd47a68c02488519c85338'),(2063,'c','Servlet','1450df9964fd47a68c02488519c85338'),(2064,'d','WebService','1450df9964fd47a68c02488519c85338'),(2065,'a','通过Http','f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(2066,'b','通过ftp','f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(2067,'c','JNDI','f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(2068,'d','通过Connection对象','f4cf42e3e2f04e7ba4f0e21868ac4fc0'),(2069,'a','JSP会先解释成Servlet源文件，然后编译成Servlet类文件','81d0fb9e895c45468c3031afacb1e19b'),(2070,'b','每当用户端运行JSP时，jspInit()方法都会运行一次','81d0fb9e895c45468c3031afacb1e19b'),(2071,'c','每当用户端运行JSP时，_jspService()方法都会运行一次','81d0fb9e895c45468c3031afacb1e19b'),(2072,'d','每当用户端运行JSP时，jspDestroy()方法都会运行一次','81d0fb9e895c45468c3031afacb1e19b'),(2073,'a','Model','cb9865c857a341d9a38b9005310e9d04'),(2074,'b','View','cb9865c857a341d9a38b9005310e9d04'),(2075,'c','Collection','cb9865c857a341d9a38b9005310e9d04'),(2076,'d','Controller','cb9865c857a341d9a38b9005310e9d04'),(2077,'a','<c:out>','56fb35cb35364282929fbb24c5bf453a'),(2078,'b','<c:if>','56fb35cb35364282929fbb24c5bf453a'),(2079,'c','<c:url>','56fb35cb35364282929fbb24c5bf453a'),(2080,'d','<c:catch>','56fb35cb35364282929fbb24c5bf453a');

/*Table structure for table `Questions_type` */

DROP TABLE IF EXISTS `Questions_type`;

CREATE TABLE `Questions_type` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `Questions_type` */

insert  into `Questions_type`(`id`,`name`) values (1,'阶段考试'),(2,'模拟考试'),(3,'入学');

/*Table structure for table `class_level` */

DROP TABLE IF EXISTS `class_level`;

CREATE TABLE `class_level` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `type_id` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

/*Data for the table `class_level` */

insert  into `class_level`(`id`,`name`,`type_id`) values (1,'第一阶段',1),(2,'第二阶段',1),(3,'第三阶段',1),(4,'第四阶段',1);

/*Table structure for table `class_message` */

DROP TABLE IF EXISTS `class_message`;

CREATE TABLE `class_message` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) NOT NULL COMMENT '课程名称',
  `user_id` int(10) DEFAULT NULL COMMENT '任课老师',
  `class_type` int(1) NOT NULL COMMENT '课程类型',
  `class_level` int(1) NOT NULL COMMENT '课程阶段',
  `total_score` int(3) NOT NULL COMMENT '总分',
  `passing_grade` int(3) NOT NULL COMMENT '及格',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '修改时间',
  `cycle` int(10) DEFAULT NULL COMMENT '课程周期',
  `is_delete` int(1) NOT NULL DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='课程信息';

/*Data for the table `class_message` */

insert  into `class_message`(`id`,`name`,`user_id`,`class_type`,`class_level`,`total_score`,`passing_grade`,`create_time`,`update_time`,`cycle`,`is_delete`) values (1,'java01',7,1,1,100,60,'2018-01-12 11:04:07','2018-01-12 11:04:07',150,0);

/*Table structure for table `class_type` */

DROP TABLE IF EXISTS `class_type`;

CREATE TABLE `class_type` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `class_type` */

insert  into `class_type`(`id`,`name`) values (1,'JAVA'),(2,'UI'),(3,'DT');

/*Table structure for table `examination_Questions_answer` */

DROP TABLE IF EXISTS `examination_Questions_answer`;

CREATE TABLE `examination_Questions_answer` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `Questions_option_lable` varchar(10) NOT NULL COMMENT '正确答案选项标签',
  `uid` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3392 DEFAULT CHARSET=utf8 COMMENT='题干答案';

/*Data for the table `examination_Questions_answer` */

insert  into `examination_Questions_answer`(`id`,`Questions_option_lable`,`uid`) values (928,'C','33847C7E645E4F72A74B7D74FCA50B28'),(929,'D','33847C7E645E4F72A74B7D74FCA50B28'),(930,'A','AD156DB8C99E4AC09AC2870B6ACC6512'),(931,'B','AD156DB8C99E4AC09AC2870B6ACC6512'),(932,'A','307FCB1526514497B5A1EDF2B4413AC2'),(933,'D','307FCB1526514497B5A1EDF2B4413AC2'),(934,'A','023A8F0EEE8A4552B143D2D773B952F5'),(935,'D','023A8F0EEE8A4552B143D2D773B952F5'),(936,'B','A9E66B343EAE4716B90668BE26223209'),(937,'B','66691F2761F14AE4B31822ABC6A588DF'),(938,'B','E98381DA38084E33B2AC280BE51E25C3'),(939,'D','AEB40BDD245549C889983956D76B98E0'),(940,'A','AF7F21667F024A35A631E78513D74D5B'),(941,'D','AF7F21667F024A35A631E78513D74D5B'),(942,'B','89DE9D102BF641A4B36CE8D8A5A4DC17'),(943,'C','89DE9D102BF641A4B36CE8D8A5A4DC17'),(944,'D','89DE9D102BF641A4B36CE8D8A5A4DC17'),(945,'C','1286976612114A438FAFA1909E70080D'),(946,'A','3E7831B46614477DAEC02CC0D257D409'),(947,'D','3E7831B46614477DAEC02CC0D257D409'),(948,'B','535F1A92CCCF419484CC809BA76CBF10'),(949,'D','01AF89EADF3F4CB3863843F3872176EE'),(950,'A','0628E41F7BE042D1B02DE5A1FDCB182D'),(951,'C','1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(952,'D','411CF3440F544A0E885A7CA9C635A0A3'),(953,'C','D55DF333DF5148198D0AB00B8A1318A1'),(954,'D','1B77DA2116C2458AB79D9036DFA44FE1'),(955,'C','37A1227DFC7C4A9EBF7673E08144E125'),(956,'D','37A1227DFC7C4A9EBF7673E08144E125'),(957,'A','05F7786BF78E4CC3B86A8BACB6CA2137'),(958,'D','05F7786BF78E4CC3B86A8BACB6CA2137'),(959,'B','359E5B13D49A43AA80BAAB943ABF82AE'),(960,'D','359E5B13D49A43AA80BAAB943ABF82AE'),(961,'B','96DE5D38ECA042A592E24FF659623260'),(962,'C','595FEC504F08464EAA982C6DB610AFB7'),(963,'B','BF55B02584644008817483E1885FC428'),(964,'C','BF55B02584644008817483E1885FC428'),(965,'D','BF55B02584644008817483E1885FC428'),(966,'c','DEB8E00B47984B408E214125C97F561E'),(967,'B','6E054FFAE3584AD088B6ECC7B4965322'),(968,'C','9DB691B963F5461AAC3E754346F22282'),(969,'A','CC6F88C11377484D9B49E839BFBD8D48'),(970,'C','572E53DB246E40E2B8DF655AA8D74114'),(971,'D','D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(972,'c','9E71E08F01E44C8CBDE27DF7C8C2EA36'),(973,'C','C27B38E93804484BA4C20A017DC36AD3'),(974,'C','E81CA77AA7114CEE940B2017685315F8'),(975,'C','D6FEB574878D45FDA87E87D21B2FECE6'),(976,'B','D0EAD34BC874489F9D4C666BDFEEB456'),(977,'D','080AC05A00A0463F8DA60212FE66F7FA'),(978,'B','9588534660054E15B07269C3B0E61B60'),(979,'C','709BD0672D6246459F23A361BB4FD037'),(980,'A','F1DF5A8ECA484D85913D9057559B6E20'),(981,'D','F1DF5A8ECA484D85913D9057559B6E20'),(982,'c','9025A20BA72843C1B7B245810369EA9C'),(983,'C','7560F2D221EB4068A112AEE2DD7594F0'),(984,'D','07061192BFEA41D385A1B82AB1899900'),(985,'B','0E800B19ACD3493B8392AA1E745FC526'),(986,'B','99501CBC0F964897B5FABA2BD033EBE4'),(987,'B','1833AFC55CC8402FAF7AC5371C0CAE19'),(988,'A','76E152C8AD4146CEAF75A4D879F5FD00'),(989,'D','76E152C8AD4146CEAF75A4D879F5FD00'),(990,'A','B652A6A0A12549AB8652E4432135948B'),(991,'C','CB38E30E01274C4B8FCE0C4D4A324FE4'),(992,'D','9432EC995CB04163B0118BE98A5A1735'),(993,'a','E47C27479C9C4D4293C08DC6B15EABB9'),(994,'A','6BE96985E07A45B5902184756CC7266F'),(995,'B','6BE96985E07A45B5902184756CC7266F'),(996,'A','DBC7179BEB2443CC8B79C226A868B53A'),(997,'B','DBC7179BEB2443CC8B79C226A868B53A'),(998,'c','5DDC385AA08440F380130A53C0808333'),(999,'b','24FE7079EB4B46E49CCFDD956F6FF753'),(1000,'D','C58B91FF03EB4334B2CDAE9270CBC56A'),(1001,'C','9931269B85B3407CAD2538474F0D86C0'),(1002,'C','F8F723F3F63C441C845141DE446D6DAD'),(1003,'B','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(1004,'D','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(1005,'a','CEC688299710476A867EDB0BD774B3AB'),(1006,'D','1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(1007,'C','FF3EE10F7F8A40C0A22C946BA66A43DB'),(1008,'D','A6D21D1AE5664320945F8F3B8EF61563'),(1009,'D','50006AB4956F4EECA09BEA06EFDD47BA'),(1010,'b','809FD1A230F2447591B7DFCAFE9ADEDD'),(1011,'C','C27AFF79C3DB4160AF2366D618D1B0C0'),(1012,'C','CCBE640AD2764BDF99BF4AF323DDE8A6'),(1013,'a','935C9CFE7F9D49ADA0B1D4D230836B7E'),(1014,'C','8D128BCBEF114A8A9F21E4C12B89265A'),(1015,'D','8D128BCBEF114A8A9F21E4C12B89265A'),(1016,'c','FC918759DD134FC7B8808340796A6E10'),(1017,'C','8A3DF44930B2411781E644DBAF6EC0BA'),(1018,'D','6FDA82C6B47547B3B4B8464495BE9319'),(1019,'c','F97BB081144A4CF0A5BB1CAEDE3661E3'),(1020,'A','D297C90E79CD409899CA6CFE31AA3965'),(1021,'D','D297C90E79CD409899CA6CFE31AA3965'),(1022,'C','1E46898D9E2A47BB844F2BB778BC1819'),(1023,'c','CFB948206CFE4664B8455AE662BF2D84'),(1024,'D','CB3D1028B169461EBBC0B8C70621BB12'),(1025,'C','9EE5241B598D47AB8291C178572148D9'),(1026,'c','9DC5993EE56F4782A01CBAD4B501A62F'),(1027,'b','553BE7DBFF814162A26D7362C58061A7'),(1028,'D','5E09FBD6E7FE402889DA86D12E0BC2AA'),(1029,'D','C3E126C77AE64823BA806EDE323714D0'),(1030,'C','C281AF83C3D048A388B1D8DB558B98BF'),(1031,'D','8B82035BE89647F29421B21DD985658A'),(1032,'B','5A003EF15715480D9670339F3E861B98'),(1033,'C','5A003EF15715480D9670339F3E861B98'),(1034,'D','5A003EF15715480D9670339F3E861B98'),(1035,'C','37B3BD3890E547EE99A0DF7BE6993FFE'),(1036,'C','A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(1037,'A','4425428C58B74D67A2B044FC2C25A34F'),(1038,'A','2D7CEED6F7764D548D89AB16C69227E1'),(1039,'D','2D7CEED6F7764D548D89AB16C69227E1'),(1040,'D','043B129719A042B98CBF2E28227F4177'),(1041,'C','62CE818D71ED44FA90386382838B4D9A'),(1042,'D','3B80D26280B748858E3D6945B2E5383A'),(1043,'D','501A71A732D04BBC842D3A2C0E6C7E81'),(1044,'B','E7B5E813FB8E484BBAB82C802B6DDCCD'),(1045,'D','E7B5E813FB8E484BBAB82C802B6DDCCD'),(1046,'D','3C59EF7A55BF42D7A2386303168B41E6'),(1047,'B','B0B5DF79A7FF49A59190A71F79FCD3C7'),(1048,'C','7A10C5C4166C4D369CB7B13BA1282FEE'),(1049,'D','7A10C5C4166C4D369CB7B13BA1282FEE'),(1050,'A','531E9499C4404A4F87124A0477A832B7'),(1051,'B','531E9499C4404A4F87124A0477A832B7'),(1052,'b','09F1FC33E50542ECBAADE31A65D25524'),(1053,'D','BBE5511E95214082A7658FB057F3AC60'),(1054,'C','56CD45D13F9F4BA88DF8C3426D569005'),(1055,'D','56CD45D13F9F4BA88DF8C3426D569005'),(1056,'c','4CE8A739509C4747B07BC9ACBA549F30'),(1057,'a','4556DC3D22534DAC84EB30BD05C652A0'),(1058,'A','05E31A91164341BFB413D7AC211EF002'),(1059,'c','6D93DD9548E24AB28D4E8B0EE1E3A30E'),(1060,'B','7D5E514B84964350935BC2D25193E537'),(1061,'C','96B0D01FA63E4FE8B11FB177C7791749'),(1062,'C','DCB01C2CD2EB435586A57D7CDF47E5BC'),(1063,'C','D6A555FE1080443DAC5CA287C256761D'),(1064,'b','80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(1065,'C','9CB027C6BCE7460CA30F124B1B63D1BF'),(1066,'B','0D490C469B2A4213BCA13EB31217E7A8'),(1067,'C','0D490C469B2A4213BCA13EB31217E7A8'),(1068,'D','0D490C469B2A4213BCA13EB31217E7A8'),(1069,'B','00174112FD76452F8AA4B2E380BB419A'),(1070,'D','ED58D69EDDD34197962E7AB32D685DE9'),(1071,'D','1812208044334BFEB52FFC01DA63AE83'),(1072,'C','3F8AF57D6A074EC996DF83FB0705C478'),(1073,'A','1950C8AB7B7541BF86293EFCC3DE11BA'),(1074,'B','1950C8AB7B7541BF86293EFCC3DE11BA'),(1075,'A','EDA3CE4666164096B884AA77AE49FD8F'),(1076,'D','EDA3CE4666164096B884AA77AE49FD8F'),(1077,'D','DE8CB3D4EF7040D0A1C5550BF8AE0343'),(1078,'A','5320AE5158BD4505BF94595E0706B221'),(1079,'D','5320AE5158BD4505BF94595E0706B221'),(1080,'c','908A8F4C1C7843ED811DA1E7DA28A8E6'),(1081,'A','7C7BAB6646FA41E78D14165E562042B8'),(1082,'D','7C7BAB6646FA41E78D14165E562042B8'),(1083,'A','004FED8329A048698E81106D4FB1714C'),(1084,'D','004FED8329A048698E81106D4FB1714C'),(1085,'C','437DF6589C0B4094B8CDCC9320837C5D'),(1086,'B','294B40B018DC459FB45D3B729EA40F51'),(1087,'D','1F7AFF2D6849427C85B7179BC91EE999'),(1088,'C','D01CD39ADA0643BB8BBD8799CFBBABFA'),(1089,'D','D01CD39ADA0643BB8BBD8799CFBBABFA'),(1090,'B','65FB4E1B0D1D4DA88FD86813EE408BE6'),(1091,'D','65FB4E1B0D1D4DA88FD86813EE408BE6'),(1092,'C','5C632E6002924066A4DC0837103B09C1'),(1093,'D','1882D20B302B4905ACE92D9EEA0C68BF'),(1094,'c','5BDDAB0369814D12BDB77D5D166AE312'),(1095,'B','6B0AC3609AAA45DB8AACE89DECE8BA9A'),(1096,'D','158A3DC7F8A64598A55B5E535AAA4E33'),(1097,'b','C52630B669114C938E4C6CFD83237612'),(1098,'D','732BFC140FC449FDA43E0A8565B91BC4'),(1099,'c','1245D10B827A4C8BA46938B91F3FE7B8'),(1100,'C','3C2E5BABF1EE49048BA0442B71508B38'),(1101,'B','554C0EF546B644DC819DAB3C0601C8E7'),(1102,'C','554C0EF546B644DC819DAB3C0601C8E7'),(1103,'D','554C0EF546B644DC819DAB3C0601C8E7'),(1104,'A','8BCF6A6DAE2647D5B218B61197C4F4FD'),(1105,'D','8BCF6A6DAE2647D5B218B61197C4F4FD'),(1106,'C','B7A26F4577054BF484B2AB4DE8FDE5D3'),(1107,'C','3DD7907201814B189FB7196E351C2D97'),(1108,'A','6507CAEDB7734678B37E5935C114BC40'),(1109,'c','BCF551CB959B448B92F110D6E3A6CEB2'),(1110,'c','D617B0ACF0EE4679874E27E5AF6B60D2'),(1111,'B','3B323001322F48679D600AD4FE9E7905'),(1112,'A','55F32060A4724CCDB907F2721E946A4E'),(1113,'D','55F32060A4724CCDB907F2721E946A4E'),(1114,'B','828485D006AA456189A68DF541346251'),(1115,'c','5E0E5A153608468B952193473D436141'),(1116,'A','8B64E9A279134DD4B915C45B06338079'),(1117,'D','8B64E9A279134DD4B915C45B06338079'),(1118,'B','0EA3C2EF5615434CBE9193C7401B4CD9'),(1119,'B','93039D2860D74E9D834EBCB32C9C1866'),(1120,'C','27C3A86660FE474AAC6D4BE318DE79A7'),(1121,'a','F99150C327694362A7C726135D43A43A'),(1122,'B','181DC739D0564E7284A1CBD8086907A1'),(1123,'D','181DC739D0564E7284A1CBD8086907A1'),(1124,'C','2F7173F3FB624EFF87A6962C823F2D2D'),(1125,'D','D824EA6F59D44636BD5AC90BD9F900CF'),(1126,'B','6AFFA7CA9F7C409CA051443BCDF70E2C'),(1127,'c','B14F2F5F954B4FACA0E545D8EF431A93'),(1128,'a','8EBFD285D0854CB693A012A34D031D16'),(1129,'D','9FA48EFABC674BBB9FBE6B4F8A2AE221'),(1130,'D','38224DC43C514D3BB68F81BF29735E85'),(1131,'A','F954012773EC4DB293D8CF1F17575C80'),(1132,'B','F954012773EC4DB293D8CF1F17575C80'),(1133,'C','B142E8B7E0C04FEE9CB7BB19BAB731FF'),(1134,'B','D3F1C927CA474084948B2CF27870D957'),(1135,'B','7074E3BF6A124D3E992167C6BD58E767'),(1136,'C','7074E3BF6A124D3E992167C6BD58E767'),(1137,'D','7074E3BF6A124D3E992167C6BD58E767'),(1138,'D','C02B55F3CE6442628F670783207C5362'),(1139,'A','DEA25DFDECC24608A62174A5A0E0EDE4'),(1140,'D','DEA25DFDECC24608A62174A5A0E0EDE4'),(1141,'c','2C1F6ED6BBBA45E2A45655583F2385CD'),(1142,'C','B48647378F8E400FBA08CAD34666019C'),(1143,'C','908A80EC085E4AB0AEC7092992848387'),(1144,'D','908A80EC085E4AB0AEC7092992848387'),(1145,'D','C7DCF27B756D4CC18CC2DEAF6DEBC532'),(1146,'B','62F28AE7A3664CB79BED79E730FA1D77'),(1147,'B','8256DAB3DBE14B98A7C537FC28D76E5F'),(1148,'C','8256DAB3DBE14B98A7C537FC28D76E5F'),(1149,'D','8256DAB3DBE14B98A7C537FC28D76E5F'),(1150,'D','9EF38305650842FB85394DA6D1A46EA0'),(1151,'B','852F76DA2073465C847D5693152356FA'),(1152,'D','852F76DA2073465C847D5693152356FA'),(1153,'D','A6E4413B7CBF44B2A5D2A50F5FA27076'),(1154,'A','CE05EB019C8A4EC0A8CF188BB9DCB648'),(1155,'C','4C5E0A40957A48C39CB85958577E4994'),(1156,'C','757AD1D494B94519BC03443347011325'),(1157,'D','757AD1D494B94519BC03443347011325'),(1158,'D','024CE98B628C4D3D881C30D98196982C'),(1159,'A','C5F7E3D877BD492AB2BC86817A9B77CD'),(1160,'D','C5F7E3D877BD492AB2BC86817A9B77CD'),(1161,'A','0504A7BB1F134AD286FD8CA7CA31759E'),(1162,'D','0504A7BB1F134AD286FD8CA7CA31759E'),(1163,'B','5879DC37332E44919C45BCB889E580FC'),(1164,'C','04A4028A95844785935C780C9DB74A53'),(1165,'c','6CDFE8F6B700401AA8745C3B0DC272EF'),(1166,'C','1E9BF6CCC36648C9962463A1C1B2B09F'),(1167,'D','6FA02E0CD577441595BC5412F065817C'),(1168,'A','BAC57760D094472299A1A521C2C0C298'),(1169,'a','02EC582ABC144C839AE1A5962726A7D2'),(1170,'B','57EF3BE1298845C588A767D5FAEEAFBD'),(1171,'a','A32AEE8A60FD474EA251E4D233FBE12E'),(1172,'B','1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(1173,'D','54DFAD28A6E04C439CEE332C7FF3E75C'),(1174,'D','71AB3318078E49FAA5554D2F12FFEE48'),(1175,'D','C79378050CBC42CDA37AAB7972E2CD9D'),(1176,'B','D537C851221A46D98DB6776091F8E571'),(1177,'C','7D0474B3E4FD4E809AD9238C64F1EE62'),(1178,'C','EA6813301FCC43538DF356CB5A1B8A6F'),(1179,'D','EA6813301FCC43538DF356CB5A1B8A6F'),(1180,'A','0E1C9D489C774D03863E069C49F81CE5'),(1181,'B','0E1C9D489C774D03863E069C49F81CE5'),(1182,'A','63CBB2E07E3244678AF540F65F466919'),(1183,'D','63CBB2E07E3244678AF540F65F466919'),(1184,'A','B5BBF42AF8214339B290FC03DC28EBAA'),(1185,'D','B5BBF42AF8214339B290FC03DC28EBAA'),(1186,'B','CBF94654BCE8403483579FC6C6307BCB'),(1187,'D','CBF94654BCE8403483579FC6C6307BCB'),(1188,'c','078FFB388D2247C782BAB0AC771092A9'),(1189,'D','47C4BDDA23B748D7B0823483717163D4'),(1190,'c','4C84A3529A1C42AD9B7314722E90FB45'),(1191,'C','4D4E4BE3FB2D40B3AD56D685772D76BF'),(1192,'C','B0B6F2FE273C4D3D86B5A30D1A6EF076'),(1193,'C','540A6A5C87CC4EC99C7CDC30D629EC23'),(1194,'C','96EC57D4BFEB47769A2C09507F2ABFC5'),(1195,'C','5DDF9F25890D4FF392644BBC735DCD7A'),(1196,'A','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(1197,'B','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(1198,'c','D6609FA578754C77BF08E5C5158C3C55'),(1199,'c','568D4745298047DBB255B73E61B7EB73'),(1200,'C','AC7E0D0B358245DBAE503B16DB7CCA98'),(1201,'D','63FBAAA7188B4B8EABA1657645A73FE1'),(1202,'D','B42101106B1A4427ABD5830DE2862C73'),(1203,'c','B05B38C6A9314D59BD85EB40E2D0B4CF'),(1204,'A','A4FD8B6880C44CE38651469A23EED233'),(1205,'D','A4FD8B6880C44CE38651469A23EED233'),(1206,'C','F97283AD17A94F358B7BA73FBACF95CE'),(1207,'C','045D8C8628C742018180B2C2092000F5'),(1208,'B','5087D7A57CF64EFFA049F4BEDDEFA162'),(1209,'D','AED7FF5036E94F89A3601D15F1C29959'),(1210,'c','8A8142C34AD24DE4B6358FC6AC18938F'),(1211,'A','1F3FBE72591F475AB969A4F8EF4E2C60'),(1212,'D','1F3FBE72591F475AB969A4F8EF4E2C60'),(1213,'a','A54F2711DFE34E4E9CA401134288C91D'),(1214,'A','653AF4E8D2A14A5D9BEC74C434E4D68B'),(1215,'B','653AF4E8D2A14A5D9BEC74C434E4D68B'),(1216,'A','87BEB1C026074995862847610484E7AF'),(1217,'D','87BEB1C026074995862847610484E7AF'),(1218,'D','7076C9D204BF49FBB92AAA7277B38ED0'),(1219,'D','81E6E99EC5A24830A2C530F91C38ABAC'),(1220,'D','15C50F987BAA495F8881A71259A22E2A'),(1221,'D','7B9A73BE7B9E417EAC73DA069CD728C5'),(1222,'b','BF71E4E2100443888F7017A215D0EDDD'),(1223,'B','19D0E4AB948F454185705481CF21931D'),(1224,'B','B9389C4D870D4434B9B4A5EFB28D845A'),(1225,'C','D5BC53403A504EE087798448704A8D3D'),(1226,'C','4DA5EB8FAF7B486888DE6396DAA20F10'),(1227,'D','15E1CB05FC584DBBB285870255A56FE7'),(1228,'B','B81C34972A854BA0A3DFC01452426EC7'),(1229,'C','B81C34972A854BA0A3DFC01452426EC7'),(1230,'D','B81C34972A854BA0A3DFC01452426EC7'),(1231,'B','D4BE8BDA77FE4847AC14112E841C5A8F'),(1232,'b','B4CACB1D109C492BA9A9D9896893BECE'),(1233,'b','DF346032A4BA45CB84F751E6B8C520B1'),(1234,'C','CE213BFD587341DBB6BE9E3CC48C622C'),(1235,'C','841C28A31A474814A7274D551B88E105'),(1236,'C','458514E21CEA46949A398E823F66A43D'),(1237,'A','42EF937022E541409542B7DB395AAAA0'),(1238,'B','EAB90D4E56C840A5A3F04D416F26AED7'),(1239,'C','0CA93240428A402C9144B742CAAE165D'),(1240,'D','AF4F177B66164781B6408D303F86810C'),(1241,'D','57F009EAB72D4617870D4E86CB898E61'),(1242,'B','EEAA379F31DC470C979F6559DBE4E49D'),(1243,'B','264C3E77D7C74A65A54D7AE14D8ABEB5'),(1244,'A','07CFADE87C7D4A93BF61D3F2D1AB0435'),(1245,'D','AF6F0E141EC142B9A89238371A01088E'),(1246,'C','A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(1247,'B','8ADC4E8C77704976AF6D5FDF24DCEFDC'),(1248,'B','18AAF3C9FD7A409B95537D0B00CA04FD'),(1249,'C','18AAF3C9FD7A409B95537D0B00CA04FD'),(1250,'D','18AAF3C9FD7A409B95537D0B00CA04FD'),(1251,'c','538F95F7DB924A9C83F6A406B11A0C88'),(1252,'C','C322AC8EE90B462B8F7CBC30475A63A4'),(1253,'B','5D2D3F19A2D7417F851101DB6C69EA50'),(1254,'B','FF328EB4F05344059CD477D79A3F3756'),(1255,'D','984F4DB6953E4901B44D41F4B237219B'),(1256,'B','A11DDB9986C1462A8F88DF4025A813F8'),(1257,'C','CF688CC154204D41AF8B7BE2E9325206'),(1258,'B','2D3350F3DC2F49BC91842BF028CEB6BD'),(1259,'C','2D3350F3DC2F49BC91842BF028CEB6BD'),(1260,'D','2D3350F3DC2F49BC91842BF028CEB6BD'),(1261,'a','30F8BB727A8A4A03A41CC55C34CC4A34'),(1262,'c','C5A72355D986431998AFAB25C24A1BC7'),(1263,'c','6399DD9F92C243B19CB9630D77CE4E57'),(1264,'C','8DEF217850E7425E8F63CDEA64E965BB'),(1265,'D','2C902492655A4D45ADBF1414F2F22A69'),(1266,'A','7C2B55E5DDC443389212B3ED4D1982D9'),(1267,'D','7C2B55E5DDC443389212B3ED4D1982D9'),(1268,'c','9E565542D2C4426F9C93BDD402FF9B7C'),(1269,'D','501B24E92D88480C9BD8DA17FDCAA073'),(1270,'C','995A1117E9E84428A976E20C3701002A'),(1271,'C','DD84DD927AEA4E7497D2112A1238F726'),(1272,'C','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(1273,'D','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(1274,'B','45BCA083FBEE417C85D9A8FCB72D3218'),(1275,'A','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(1276,'D','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(1277,'C','2EB316C6176A43F9AAB28179E2D102E3'),(1278,'D','2EB316C6176A43F9AAB28179E2D102E3'),(1279,'A','D0A1111E66FA40CF83F38723C1F2E243'),(1280,'D','D0A1111E66FA40CF83F38723C1F2E243'),(1281,'D','E6074C379FC64361BF5E26FC42DE09B8'),(1282,'B','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(1283,'D','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(1284,'D','5583044BC4BE4658BDBCDFB09F4888D8'),(1285,'C','9FA981DED83B4AC494357F78CBE8D82A'),(1286,'D','97A24EFBAA8043708AA7E3196C8DD36C'),(1287,'C','09A4554A2A894F67AB29EC161ED0AD94'),(1288,'D','8193D4AE48644B4FBDF8A9CA36244CEA'),(1289,'A','713912F5E46346328118DC9E610F552E'),(1290,'D','713912F5E46346328118DC9E610F552E'),(1291,'D','85369AE2C3894B0DBA0A8CF1BF9696AC'),(1292,'C','F82A50997800481EBF83F8841EA0966A'),(1293,'C','876C19BA1A644AE09B59FF21D3D0BF20'),(1294,'c','CB375B3254C24F86940623F97D4964C7'),(1295,'C','428316A7473843298FBD06B2451F7960'),(1296,'C','63C38F3C6C8743358657ED4F97DAAC92'),(1297,'B','AA5086CF642A47FF835942F0B91B2E96'),(1298,'D','AA5086CF642A47FF835942F0B91B2E96'),(1299,'A','B23EF313E63946E2BBBD12223102C69A'),(1300,'B','B23EF313E63946E2BBBD12223102C69A'),(1301,'c','6106E40EF34841518AC57C37111CED16'),(1302,'B','2FF97CAE7008449CAB06D72F3203CBBD'),(1303,'C','2FF97CAE7008449CAB06D72F3203CBBD'),(1304,'D','2FF97CAE7008449CAB06D72F3203CBBD'),(1305,'B','A56FE711FAFD42F687F7965CCB5E9E1D'),(1306,'b','D351981F52454075B38A8BBD17130695'),(1307,'c','B1D4185AEDBB46DBA02C56353547049B'),(1308,'A','6698F9521A344EC0964FFFDDD42EC889'),(1309,'D','6698F9521A344EC0964FFFDDD42EC889'),(1310,'A','34756F5E0EE640A7A5F24B1C035831B5'),(1311,'D','34756F5E0EE640A7A5F24B1C035831B5'),(1312,'A','1D660E6E977B41D887BAA72BA7D82329'),(1313,'B','1D660E6E977B41D887BAA72BA7D82329'),(1314,'a','E3A90239DF874BD883EBC1D805A03DAC'),(1315,'D','764A8B7CDA5848EDAA5863C0FDD9B179'),(1316,'D','C9588B688CA445078A926C8D252487AF'),(1317,'D','6D27985CDB994BCEB691CAD52D8DFF95'),(1318,'B','7512F0CBEAC945EFB5F0123F97F54D88'),(1319,'C','BDF349BCA1394593B1851DD7F624D3B0'),(1320,'D','BDF349BCA1394593B1851DD7F624D3B0'),(1321,'C','2248B08C238F4318AFC4D31A13568876'),(1322,'D','9D4B6C71FF364B1382B511C5A0CD05CB'),(1323,'C','4D2A4EAD46104AC798BBDC5D0B3E4698'),(1324,'A','312A61C4E17740EAA9C7D2DAD637858B'),(1325,'D','312A61C4E17740EAA9C7D2DAD637858B'),(1326,'D','A65B0F53E4B04E91BF77E0C4A945686A'),(1327,'C','7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(1328,'A','7D2A7A91D8E849828F8A26BA90A2F3DF'),(1329,'D','D9264BD53FC5479CA3621E774007C4D6'),(1330,'A','63AB8F5ECAA44DA98E349BDB678F0F37'),(1331,'D','63AB8F5ECAA44DA98E349BDB678F0F37'),(1332,'c','8D543E1694A74A9FBE6FC5998FB9915E'),(1333,'A','5B2756250E7447BA92124C11C1B48534'),(1334,'D','5B2756250E7447BA92124C11C1B48534'),(1335,'C','8E3A0710EDBA4065929590F25D6EE32A'),(1336,'b','6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(1337,'C','D9DD8C5678FF469089B52CC20AA2AC43'),(1338,'C','56F7E21CF56E4836B0E6DF0BB955C5FE'),(1339,'D','57E84310FD9A4D4EB9A1CBF867EAC295'),(1340,'A','91FF9D799B564C9F95B189C0FFF6E0A9'),(1341,'D','91FF9D799B564C9F95B189C0FFF6E0A9'),(1342,'C','830B4A82C02C44C0A6E2372C1F5B8BB3'),(1343,'D','921B6660CAE0477595E7A5BE9EE25E6F'),(1344,'b','2FDA6B3787244961AF6001F574545E64'),(1345,'D','8E5934A4316C43A0818300E54F770628'),(1346,'c','59C78793EE824224AE8075755AF9896C'),(1347,'A','B69E338B93B144749C51624C22853441'),(1348,'D','B69E338B93B144749C51624C22853441'),(1349,'B','4745AB44A1E84A4DAD8399FC7210CE6C'),(1350,'C','4745AB44A1E84A4DAD8399FC7210CE6C'),(1351,'D','4745AB44A1E84A4DAD8399FC7210CE6C'),(1352,'B','42503013F61240109E2FC90D689E6137'),(1353,'C','E82FEAD8687A449697A0EA04D1593815'),(1354,'b','F618DFEDE50E4833914C16E557D4DE80'),(1355,'C','125D8E65A6664A2284CAEAA0EFF7D56B'),(1356,'c','07B64BF8C1BC43D5BD1C0DFA7B80D523'),(1357,'C','7E97CC25138F41F3930150DEAAA7F718'),(1358,'B','5237406AF0E64A1B87AFA78C97521742'),(1359,'C','5237406AF0E64A1B87AFA78C97521742'),(1360,'D','5237406AF0E64A1B87AFA78C97521742'),(1361,'c','95FAEC7CD2004FE38565189C8153D58B'),(1362,'A','0EAA9324F9F04EFCAA69F5B6E732503A'),(1363,'B','0EAA9324F9F04EFCAA69F5B6E732503A'),(1364,'D','0C211E5F953F4DE3BBC66268ACDFDC00'),(1365,'D','0F0BB2075E6A440DBD6277011E29DF2D'),(1366,'B','5BDCB6173CD24C00A54D76CC75DD7D21'),(1367,'C','D979ECDC0C434C238ACB528CEA9996E0'),(1368,'D','D979ECDC0C434C238ACB528CEA9996E0'),(1369,'B','FE9B4DA45A7A4EA3870A3D448A5A27ED'),(1370,'A','2DD703ADD11048D291BE7A9D6C33D77A'),(1371,'B','0D3E23B1871040EB83BA3E43F31C7249'),(1372,'C','2B2A1FC2DDB84E38911106F21A45266D'),(1373,'C','848B4A69E2534C10AD366D2805124925'),(1374,'c','588B398B2C2E43CE828BFD0B0E174CCE'),(1375,'C','2F33726699C144E48CB7C76A856256EA'),(1376,'B','F341A225A1B84DAD8C38EDE74F65CA7A'),(1377,'C','F341A225A1B84DAD8C38EDE74F65CA7A'),(1378,'D','F341A225A1B84DAD8C38EDE74F65CA7A'),(1379,'C','507CFBA7AD0F4BDBB09406719D56DC3C'),(1380,'C','2FA9DDEBB8D84DBA876E5B559C3A6F43'),(1381,'a','BA0623754560439BB0F402CE83AE52F4'),(1382,'C','6FF9DA87D8854B6087901269F82BB8C3'),(1383,'D','6FF9DA87D8854B6087901269F82BB8C3'),(1384,'A','32808EFF6EBD40A7ADE6EA42932D76AD'),(1385,'D','32808EFF6EBD40A7ADE6EA42932D76AD'),(1386,'c','EC1652EC2A37468391FCB4F7A12CA465'),(1387,'C','85381E73235347BABA8FE2C7D6AA8575'),(1388,'A','EB3CF51FAA444DDAA10DF6B2DF898FBE'),(1389,'B','992C1621A1AD4390B7948389B822B379'),(1390,'B','8889C1666DA5478B9BBE4EE0CB27C752'),(1391,'D','8889C1666DA5478B9BBE4EE0CB27C752'),(1392,'D','FACE3F397BDD400DBCD8A65D48D4B34D'),(1393,'D','DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(1394,'b','C9ED16F8AFCA48B58D30C465AA251572'),(1395,'B','50EA8CAD9F1C457797794D09A18E574E'),(1396,'D','BBE54DA41275455A97BE8AA214F44FE1'),(1397,'C','21AC3DAD00964F8F9A199136F07C35E8'),(1398,'C','64DB87B316BB4CA7A4B466B9F3860978'),(1399,'A','E6E31C640E584486A7CEF620BC9D3320'),(1400,'D','E6E31C640E584486A7CEF620BC9D3320'),(1401,'C','F2E94965759944C5AC98BB548476DEC9'),(1402,'B','67121C4B66C0486ABDBDE2C88BFAD0F8'),(1403,'C','3EBF6814453340B2A2B61CA8DD0E4463'),(1404,'c','96B053B715C2420893AE229AA76D611E'),(1405,'D','CD50264C40BB436CA9074CB0B8EC6259'),(1406,'A','9AFF39DB01CE451984A72F03FAAD0D2E'),(1407,'D','8EB75F2B747347EC8B02E1D5AF61D47B'),(1408,'D','948F7B7A3FCE4EF98E72049FB08F9B3D'),(1409,'D','813DFF9649A7465FB621A7A5D2682467'),(1410,'a','47AD197D959C4A16AD817FBE3DDDA7F5'),(1411,'B','14EC3A99C1C84B0D8139501430EA6AFD'),(1412,'D','B046E932274B4F4DBEDAD15BBABEF4AE'),(1413,'c','C93DAFA1ADAA4735A05AE9F95241EDC6'),(1414,'A','BFE462F80A874FE1A7F5819C26A5A140'),(1415,'D','BFE462F80A874FE1A7F5819C26A5A140'),(1416,'B','9C154B1EF7BF4A078CCA3656BB158699'),(1417,'c','5EC69CE7407948D3805A8999B4CAC654'),(1418,'A','587C362DCCC14B5BA46D1A7A893479FE'),(1419,'D','587C362DCCC14B5BA46D1A7A893479FE'),(1420,'A','25F3FBA293764D94A9394C2729C79972'),(1421,'D','25F3FBA293764D94A9394C2729C79972'),(1422,'a','97D7CA30B1E344869E8619DEABD156F4'),(1423,'c','C1381A4661A64CBAAEE49D6BD7D049DF'),(1424,'C','AD684B6DEE7148FDA9468A12E44EF9E9'),(1425,'C','C0B87C72595E4299B1C68A0B63865C06'),(1426,'C','09365560EE224D558C2BE30364DC9051'),(1427,'A','14249FAA35E343A49C0835A82CC9773F'),(1428,'D','14249FAA35E343A49C0835A82CC9773F'),(1429,'A','F477C34F8ADD4FDDBC100BE6F1009C9F'),(1430,'B','F477C34F8ADD4FDDBC100BE6F1009C9F'),(1431,'B','A29048802E814634AA73AB5D72E69447'),(1432,'D','A29048802E814634AA73AB5D72E69447'),(1433,'B','F57FE2EB0EA542AB9472778821BAD7A3'),(1434,'C','2D99730DF6CD407A9718DA57BC5ECE2C'),(1435,'D','2D99730DF6CD407A9718DA57BC5ECE2C'),(1436,'C','45504D0AAFC84F2FB878934036685865'),(1437,'D','149386A467344D2A8B43AED0EF7C089E'),(1438,'D','F3B2EE9EDD4749109584A5C9D68414AD'),(1439,'B','B0FA93EE9B63405CB5D268C2AC54F94A'),(1440,'D','B0FA93EE9B63405CB5D268C2AC54F94A'),(1441,'C','45FDBE15934249F1BB9BAD516FBEE325'),(1442,'A','FEEDF1B3BF504333B4FFF0680D2B03C1'),(1443,'D','FEEDF1B3BF504333B4FFF0680D2B03C1'),(1444,'a','A84749A9745C4F948392595C675C019B'),(1445,'B','E9A3A125A0404FDFB6011742DB6DB6B9'),(1446,'D','9B29B0874B4C4AE08E514C328B2187CD'),(1447,'B','E3F3949B95CD43599E1E7B3AD55E4F4D'),(1448,'D','E3F3949B95CD43599E1E7B3AD55E4F4D'),(1449,'C','A8C86230C4DF425887ECCAAEB5CC02C6'),(1450,'B','F01DAA2BBFD2443FAE096B23884C24AE'),(1451,'b','2E262AAD34AC48829568882086D7202F'),(1452,'C','6BB2AD5611C542409938D024EC097EE7'),(1453,'C','DB99F657D4E44E369C3A9E4A0A46791A'),(1454,'D','54596B78F8E14FB790FCA3624ADBA8C7'),(1455,'A','EAC5B4E23C194EA28FD27E9880D8E20A'),(1456,'D','EAC5B4E23C194EA28FD27E9880D8E20A'),(1457,'A','1030CC74D14B4403918928BAB6809B31'),(1458,'D','1030CC74D14B4403918928BAB6809B31'),(1459,'A','D6F6401553564E08A4E581FF84397848'),(1460,'D','D6F6401553564E08A4E581FF84397848'),(1461,'B','BD896FBFACFC4B36AF0FE24DECEBDC19'),(1462,'C','BD896FBFACFC4B36AF0FE24DECEBDC19'),(1463,'D','BD896FBFACFC4B36AF0FE24DECEBDC19'),(1464,'C','F65F5369D2AC474689AAE38FFF7C932B'),(1465,'c','15E755B3282C4516811D36F9B0545C22'),(1466,'B','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(1467,'C','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(1468,'D','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(1469,'D','5D8E662FC59B439B8A68D3D318B47F80'),(1470,'D','2DD6A8444DD84E3C81DFD05EED3DC320'),(1471,'A','5A0CE621D2F64D7E90B7ACDD84782F0D'),(1472,'c','8F87953473BE47C59C6CBA463610D189'),(1473,'C','37DF54D7E16343ED847816BB63989CC5'),(1474,'C','A0BBAE12E8C149038CB4C140C9BA58B3'),(1475,'c','0D11249964FD4A75BC97E2010A771B4A'),(1476,'C','F9436FC4DBEA4FDBA5200454D7C5327A'),(1477,'B','56838134CD794ACAA44586DBF5F3B959'),(1478,'A','384941E85F064F08A4083AEA6B0D8817'),(1479,'B','384941E85F064F08A4083AEA6B0D8817'),(1480,'D','5A9716CE20D1462680A593B6C5B89CEB'),(1481,'D','A1CD728328734A96A8655BB21E7B378A'),(1482,'D','0AA606B630FD45FD842E0407601799B3'),(1483,'B','52A6E4E1F52447D1B4E94DFBAFFE4500'),(1484,'B','A6B8AFDB00714456914F07751B3FB1A0'),(1485,'C','1C100AA2C8024D98897499F8209C5AF4'),(1486,'B','4C6F72C4C8B14C7ABC4199A389B65481'),(1487,'B','F0DB9D7F36304DA5A6461A92E257B375'),(1488,'D','F0DB9D7F36304DA5A6461A92E257B375'),(1489,'c','3D1A14ECFFA0406584B905BA2F690773'),(1490,'c','739E8ABCE7C64F2C83E502206109DFDB'),(1491,'D','E38F2EBDBC434FB1918C4828583DB36A'),(1492,'D','191292A230724D4EB6F19FEAEABC3278'),(1493,'D','4844E0394ED7459292ABAE08E6EF78CD'),(1494,'C','34C5617C9A8B46A9AB391DBA635EE335'),(1495,'D','34C5617C9A8B46A9AB391DBA635EE335'),(1496,'B','6D16485C782647E6BAD95B07B3ADFC17'),(1497,'D','1D0190BAE74B4ADB9BB11A2EE0B76055'),(1498,'A','A75A32CCEE03492E90F11BF8C9B64057'),(1499,'B','A75A32CCEE03492E90F11BF8C9B64057'),(1500,'D','CB673174F5CA450290C914D6BD2F851E'),(1501,'D','D95BDD7369DE4DF4AF0CA6665ABC1B06'),(1502,'A','AC30E75DE43745BC85CBCDD915D9F1B8'),(1503,'D','AC30E75DE43745BC85CBCDD915D9F1B8'),(1504,'D','CB75519CBDEE40A787C87C7166B8052D'),(1505,'C','D439C38591184F2983CAD78714385D7B'),(1506,'c','F1530F13F5A14DEA9F91746A872DD4C6'),(1507,'C','F5254E1EB9FA40C0A33494D306C600D1'),(1508,'A','DEDFE4A171E141459A1430AF359CC194'),(1509,'C','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(1510,'D','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(1511,'D','DE65B6DBF034456A9C46D143E0C594DA'),(1512,'C','BC43E962D27248CFA70EDE6E1DC6E0AF'),(1513,'C','9E1D56FA615D42BA8734B31FACFD32DF'),(1514,'A','3D5B2245D815422DAB789D69EBA0F590'),(1515,'D','3D5B2245D815422DAB789D69EBA0F590'),(1516,'C','1061C923799E4CD68CB4D7DDE2C92FFF'),(1517,'D','DA984EA888EB4427A3F91FD8658FC24A'),(1518,'C','F6BFE1D6183344C5B76596F9A0F5594E'),(1519,'b','DCABE90E97B24CC09AA85C70D6999F4D'),(1520,'A','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(1521,'B','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(1522,'B','9E2CEBB34C624D5A986A93F7805F2615'),(1523,'c','8E628AAEE22341B7BE46FD612B8A19CC'),(1524,'B','47B51A629F9A4C13895B84F3788801F9'),(1525,'A','C0E1D38F453048669840CC9C1F7C7BCB'),(1526,'D','C0E1D38F453048669840CC9C1F7C7BCB'),(1527,'C','0C3B3A0A7F484C81B514BE6594A93479'),(1528,'C','A17D3EF310BA41A49665FA0D873E9C27'),(1529,'D','A17D3EF310BA41A49665FA0D873E9C27'),(1530,'a','346501B7F0034B7DBAA2884AB5E658C0'),(1531,'C','75557D048F23453692EE5E12B2BF12C2'),(1532,'C','EF97015C5FF4418DBF4C60636754774D'),(1533,'C','CB9A2970FDEC4B3DB457B7DD10E217E5'),(1534,'C','D3894E7D8A2946B693456DAA0C3C20D6'),(1535,'a','8C7A9B90249941579E5DD04FA1BB81CE'),(1536,'B','221F3BC52966430F8EADA646C3655437'),(1537,'A','56BD5CEF222246169FF1BD500FF1663D'),(1538,'D','56BD5CEF222246169FF1BD500FF1663D'),(1539,'B','976867BEC19E4ED1B01104CCCA6C021A'),(1540,'B','73A0A1A36EF544889F7D0FAE6B1303C6'),(1541,'D','1A8AD3DD69614D70A8828207DC42A4A3'),(1542,'D','F55B96C279084E78BE760C277A7C277C'),(1543,'c','729421F8CA9343018D5E1ECB53AE7CEB'),(1544,'D','4A7E5B92AA2B48259664DBA8DC424C96'),(1545,'A','A1C803209B8546C1A33B31943018ED7C'),(1546,'B','A1C803209B8546C1A33B31943018ED7C'),(1547,'C','012BACAA617C40A2A4517011CEB40162'),(1548,'C','3DFBBBFF5CFD4E199A30E323001804D8'),(1549,'A','D53236B8A89043B7AD78EBED3EDF7082'),(1550,'A','651CA25F1CC74C74BA88D50F92FCD370'),(1551,'B','651CA25F1CC74C74BA88D50F92FCD370'),(1552,'D','7B09CBC415AA4D048D3E843210CDA105'),(1553,'C','8AACE908A00A4802B59C6B36BB9337A5'),(1554,'B','698FA9F0F43F434094BA4681A58667ED'),(1555,'D','698FA9F0F43F434094BA4681A58667ED'),(1556,'B','B3D28145006843BC8660825F4EFDC0FD'),(1557,'C','B3D28145006843BC8660825F4EFDC0FD'),(1558,'D','B3D28145006843BC8660825F4EFDC0FD'),(1559,'B','E7812629EC4C4DAE879ED824F4582BC6'),(1560,'C','8403CD89494B4B51A66E35F0949DFC51'),(1561,'a','EB10B321FAE0463494F8B91973F66BFC'),(1562,'D','06B62452BFDA488F8277E2377225094E'),(1563,'D','7689021DD2A24554B3BAC8AA4953DED4'),(1564,'A','2820C6BC8B3F424FB97315663FD8C1A5'),(1565,'c','ABCE4CAA7ED044F590B67CA7844D4FEA'),(1566,'A','294E033CD952474D9A32D06EF34617D3'),(1567,'D','294E033CD952474D9A32D06EF34617D3'),(1568,'D','5D6D0FD2CB5A455F8C76A0A11532CF66'),(1569,'a','897BD3412267477AB1935B5DD3F4DFCA'),(1570,'C','7A07815398B14618990E1043254B8682'),(1571,'A','3D408F5678ED46029E6D7AD970BB6F76'),(1572,'D','3D408F5678ED46029E6D7AD970BB6F76'),(1573,'C','583614F7F5E24075950DFF8D840677A7'),(1574,'a','10F9B5A04C0C4511B15ACF8EE633E7EF'),(1575,'C','ED392F1DB8AF42629A1AC48B77852BA4'),(1576,'C','D2094108BBD742918B7192DFE388C362'),(1577,'B','CA06ADDDE87149E589A31571DDAACE58'),(1578,'B','A0165EE57DC146FFB022C4842AF19FD7'),(1579,'B','C7FE7511D00141BD92F7EEF608D2540E'),(1580,'D','443E423B23044DC79F1E5F9129931BBA'),(1581,'B','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(1582,'C','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(1583,'D','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(1584,'C','5642346732C54350A6709F11A6877E04'),(1585,'B','7B896485FF384634BCF54E74AAB236F3'),(1586,'D','F926C0ECC64F43C4AA43CC5686AD96AB'),(1587,'A','56B14E4D8D754A16923B7B38661874E7'),(1588,'D','56B14E4D8D754A16923B7B38661874E7'),(1589,'c','4ED97386374A4CB399BAE75B3B7F04A5'),(1590,'D','34A4550373814A4583565D0D27D12DA9'),(1591,'C','AFD5C03FAF6E461E993EF0AA6D30AFA6'),(1592,'B','FEECD17C25834D1EBE40E0AB8D27A0D1'),(1593,'C','261E0E19DD0D4B92AD9E25A10E6EA246'),(1594,'A','D75DC562C2F843269B5C45EB350FA3AD'),(1595,'D','D75DC562C2F843269B5C45EB350FA3AD'),(1596,'C','B430246C092F424BABB7E12F228C94AD'),(1597,'B','585205C658C8488C986B6C7C0B4FB646'),(1598,'A','C34688C8BAB54B9F99110787BDD9A0CC'),(1599,'B','C34688C8BAB54B9F99110787BDD9A0CC'),(1600,'B','FC77DDEB56204E76A5B9003B14839238'),(1601,'D','FC77DDEB56204E76A5B9003B14839238'),(1602,'b','6E1833096598439F8115640B1764BC22'),(1603,'A','2E49CB6268D949F5A077E9250E6A8296'),(1604,'D','2E49CB6268D949F5A077E9250E6A8296'),(1605,'c','95F8508EB1314785809D067307E311ED'),(1606,'A','83CD58B0C68446B19CC3E52C7191D5DB'),(1607,'D','83CD58B0C68446B19CC3E52C7191D5DB'),(1608,'B','BA09CF4A268E46719BB1562C1071BFAC'),(1609,'B','82D854D78657472481799FA7E7C4AF6C'),(1610,'A','57EFE093388D41A48EEEE53F4B337170'),(1611,'D','57EFE093388D41A48EEEE53F4B337170'),(1612,'B','4A04D4A64C06440B9B79FA621B91F0CF'),(1613,'C','4A04D4A64C06440B9B79FA621B91F0CF'),(1614,'D','4A04D4A64C06440B9B79FA621B91F0CF'),(1615,'D','1A26D4793DA74C28B14AD677DC2EEC36'),(1616,'B','D09CC07D43CB4D46A02088AB1F1BD8BF'),(1617,'D','D09CC07D43CB4D46A02088AB1F1BD8BF'),(1618,'C','4836E60430AC414E8D592776A6628EB6'),(1619,'D','4836E60430AC414E8D592776A6628EB6'),(1620,'C','1387D86A022F454C906DBFACB326C66A'),(1621,'A','E8C8A99699984B05A25F923CFB885B66'),(1622,'D','E8C8A99699984B05A25F923CFB885B66'),(1623,'C','28B6C727DAB3400787950070F088466E'),(1624,'c','72A22DC3F9F74DE5B18628DAF6B9F341'),(1625,'c','1495AAC7C1DD4327BA0243A778D35D8F'),(1626,'C','0E9EABFC29204285B9C562A3829CCF11'),(1627,'b','5DF6019386464D37B91B2EC4EADE0604'),(1628,'B','E2F9BB39BD5B47D39E83A9CD402E56C3'),(1629,'c','6FF6706083574A9DB15B3B7C01E34881'),(1630,'D','6D4C6A0FE592413FA97FA276C0F115EC'),(1631,'C','01042551428C4DDDB6EEF28FA03C0265'),(1632,'D','AF09572A8BAA4C18BC025531D80D273E'),(1633,'c','A26F14ABB5124E538467296224508BE5'),(1634,'D','0925C1723A33472F91223278E8B86B05'),(1635,'B','94169FE7526547CBA0CFD18D8C5F0841'),(1636,'B','2248D33C794B45459FCEF31A441DECD3'),(1637,'D','8BE9C72252AD42CF9FB5D07A1FA88788'),(1638,'D','04CA32B16C3F4074A078E704BE185388'),(1639,'A','0202B878BE8347B2811E18F7C5596545'),(1640,'D','087E23C1034B45FEBF489BD434B07054'),(1641,'D','506F8FA7123841098B8FDCC2FE8FE00E'),(1642,'c','B00059FA439C476BABB293289CA95AFC'),(1643,'C','558F1A8771AE4633A142D8850103D03F'),(1644,'D','558F1A8771AE4633A142D8850103D03F'),(1645,'c','CACAFE264F0643D9B6E99D0ED77070DA'),(1646,'C','C35CCB1EC4BA43A4AD7157257EC0DED5'),(1647,'A','6F94F5D84BA24BAC96DD876A3849723A'),(1648,'D','6F94F5D84BA24BAC96DD876A3849723A'),(1649,'A','F82D40C9241943A4A641B2F79FD305B2'),(1650,'D','F82D40C9241943A4A641B2F79FD305B2'),(1651,'B','374D4F7CDC744C4D90CE84744B3567B5'),(1652,'D','374D4F7CDC744C4D90CE84744B3567B5'),(1653,'C','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(1654,'D','B1F4913EE82648BBA0787DD3C482182D'),(1655,'C','D5A0908485B749ECA806CA6349688D71'),(1656,'c','1A3C99581202446399CD4D2957E435FF'),(1657,'c','7DE0E15458D34E5A94E38537AAAF592A'),(1658,'C','19C81852939949A5A45CCEFB5D8EFEED'),(1659,'A','3A37AC4828F14215A0196E91E7D39A48'),(1660,'D','3A37AC4828F14215A0196E91E7D39A48'),(1661,'D','BC1E11BE74D645639232359365B6E158'),(1662,'C','FF47D51182DB4DA09F0E83566DC0E918'),(1663,'B','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(1664,'C','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(1665,'D','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(1666,'A','68020EC47CAD48DFB7E609CD38B9E169'),(1667,'B','493537BAD3CB4F5B942B5813F5B181BE'),(1668,'C','D7131517D818414FA7A4C2AE1993D434'),(1669,'a','D4E1CE0317934DDAA243CDC34E772950'),(1670,'C','26F585B875EC42F2B59C6ACFEC9B3BFB'),(1671,'B','D7BD79657ADD434C98CA8D245C2031DE'),(1672,'D','D7BD79657ADD434C98CA8D245C2031DE'),(1673,'B','3B3296C71C7A43C497E6FD21EA862F38'),(1674,'B','035E83A54A1D4068A96A9BF266B6EB1E'),(1675,'c','CD719FD7E39848019EB8E25641ECFFBD'),(1676,'A','7F08D3C1323143E88C769FB49574361C'),(1677,'B','7F08D3C1323143E88C769FB49574361C'),(1678,'C','075C9025AE5B4D998414DFFEC663F5A1'),(1679,'C','F2547990B70E47D3A8331AF838FB71A4'),(1680,'B','AB5DBF5978DF43A1BEB13239407A5D16'),(1681,'C','A2CB6CD3363643F8A9DF27F8887991CC'),(1682,'D','A2CB6CD3363643F8A9DF27F8887991CC'),(1683,'D','E55BF76712E1438A9FAB1BAC7B0ED7C7'),(1684,'c','DCF07752DC654BE49752599D5F308BCD'),(1685,'D','ABAEAD1EE0BA46BC86A2BE85F5800C47'),(1686,'B','BC80BD86538641309E6AA25A867B22F1'),(1687,'A','D1E215794BBF46F28A0C37B9D3936242'),(1688,'D','D1E215794BBF46F28A0C37B9D3936242'),(1689,'B','F7317260A183428BA88C3E40C88180D8'),(1690,'c','85E8B6F7914F4BCE8533F5A58F74684B'),(1691,'D','6CE2540FA0FF437696713F7EA11C1A6A'),(1692,'C','CE5C2FD456664E0F9159518082DD8484'),(1693,'D','CE5C2FD456664E0F9159518082DD8484'),(1694,'C','2EEF8A1EF8744402837A20A933F8EA7A'),(1695,'B','E06953EB666843B8A1B4665A926F596E'),(1696,'C','E06953EB666843B8A1B4665A926F596E'),(1697,'D','E06953EB666843B8A1B4665A926F596E'),(1698,'c','19BC2D554F7A4B45BD8FF2C68BB40CDA'),(1699,'D','69BD435D4F7D446097303BB071AAA4E9'),(1700,'D','80F46AA531964C008FCDBAEEC9E8DCD9'),(1701,'C','DE5425318C5045208BB13A5234B80FDD'),(1702,'a','817049F422604226B0C4102943B7B8F5'),(1703,'A','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(1704,'D','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(1705,'D','B0CE4518E47743608AFFBE6B452176B6'),(1706,'B','F3D99320CB124B48B4947E01FE4ECC12'),(1707,'C','F3D99320CB124B48B4947E01FE4ECC12'),(1708,'D','F3D99320CB124B48B4947E01FE4ECC12'),(1709,'B','296252C5A1BC4A4D8C816331F23A4B25'),(1710,'B','B177A1C773934FA5B207F8E87D81E6B5'),(1711,'b','A96CA27F7064453F905BE81905593D6C'),(1712,'C','D4F5374AED9E4AA89819D39DB81BBFDE'),(1713,'C','8B30A274598E4C27891E28DB917E5FB0'),(1714,'C','04E829B1189A4237BEB30337CC370725'),(1715,'D','CBB12FB1F0C24107B58F4546E590AE28'),(1716,'D','A0FC3A6B57C946A3BBB0E1469E42D17C'),(1717,'A','19A7323061AB48E0BF088E343C0C93CC'),(1718,'D','19A7323061AB48E0BF088E343C0C93CC'),(1719,'C','FAC96053479B458FBE6A152567A52F09'),(1720,'D','FAC96053479B458FBE6A152567A52F09'),(1721,'D','C2BB7761C0234DC6B13417AB8FCBDCF1'),(1722,'c','6203C30573BE454ABB2F60144A74C92E'),(1723,'D','82A4BFB14D3247A19D05AA6CBE401745'),(1724,'D','7248FC8E09944933B0A43E5CFDB3FA9D'),(1725,'C','E2C457D841D44B499069F934506C1334'),(1726,'C','5E80109810C04E04A82927858B301F59'),(1727,'C','61ACC3A755E24A49B5CD75DC007F4706'),(1728,'C','262CA6B665C443ED977EA506B45378C4'),(1729,'A','248D0E879F744F14BE80586A80AB7816'),(1730,'A','30A1DBE2993F47D08EB77F4043E4E3B8'),(1731,'D','30A1DBE2993F47D08EB77F4043E4E3B8'),(1732,'A','54542AF7631D4091B12EFE77D5CBA830'),(1733,'B','54542AF7631D4091B12EFE77D5CBA830'),(1734,'A','C072CCD1D67E4C4EA755FD7B859866E4'),(1735,'D','C072CCD1D67E4C4EA755FD7B859866E4'),(1736,'c','40AC7C9E0EA94B9DBA1EE7B053B8D577'),(1737,'A','FE67B4B0C78147CB80BAEAB317F51039'),(1738,'B','FE67B4B0C78147CB80BAEAB317F51039'),(1739,'b','D9B19D53C90245B88013FB25E4D80A2E'),(1740,'C','8A03CE5AEA1F42C188E09A9FCA13C5F5'),(1741,'c','DD9843C56183451EB8C70C3FAE3FF4F0'),(1742,'B','929F5A6FC2114769933E3E1F59A7895E'),(1743,'D','929F5A6FC2114769933E3E1F59A7895E'),(1744,'A','869C550DC2A943029172A31A836FB137'),(1745,'D','869C550DC2A943029172A31A836FB137'),(1746,'b','655548DA367440DF9DA3BE3BE74700A7'),(1747,'B','3B010524C5E448B7AAE23D60DE30E34D'),(1748,'a','29FE99226B6F4AAABC53A72B30AEF2D5'),(1749,'C','0D4DDF47D69D495681AA7B8AEAA23189'),(1750,'C','89F655A2BBB743FA8690F03A2355F362'),(1751,'C','B8F11DD9DAC64244B577E877BEBFB5FF'),(1752,'D','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(1753,'C','0DA6181FD23F495184AE9128881AB30D'),(1754,'D','0DA6181FD23F495184AE9128881AB30D'),(1755,'c','6911530B0B124AEAA00145929D3BBFD7'),(1756,'D','2A4F6DA50AE74CC7A337594A78157C01'),(1757,'b','B986D98802E6468485A59C0524946414'),(1758,'A','070536DBD34B45968D6C066D501C7D81'),(1759,'D','070536DBD34B45968D6C066D501C7D81'),(1760,'C','8EFB860529714AC2AB98D0A4791354E2'),(1761,'C','C8E37F55ED3B44E3B266094FE7362AA5'),(1762,'A','4B9E29A3F0AC42038F5494CD94FDE71F'),(1763,'D','4B9E29A3F0AC42038F5494CD94FDE71F'),(1764,'D','286D0E3555594C8AA239BE1606877D20'),(1765,'b','5B1A8371922F4B26B6667A058ACB23BE'),(1766,'D','9AFA3223D3674E9AB5794DE660951F02'),(1767,'B','693CE405916248D89973A458EF74B047'),(1768,'B','7696C808CF7D435A846FC77A69848D86'),(1769,'c','A80C6B0EFD98408D905CA3B3BF89A8BB'),(1770,'D','E917096B193346AB8F41C9491B4C8A17'),(1771,'D','1BFB46B8EBB249489CEBA93AA518F88D'),(1772,'B','0640B865AC5B46CB9121C984E2D62017'),(1773,'D','0640B865AC5B46CB9121C984E2D62017'),(1774,'D','C29A0DE351E4496BA407B0641D1234CA'),(1775,'B','9138094802F2467EBB1DE62EEC2A1DB2'),(1776,'D','9138094802F2467EBB1DE62EEC2A1DB2'),(1777,'c','299E83AE459C4D658A527DF258E063AC'),(1778,'A','6561E43E97654FABBF141C7E15F0B49F'),(1779,'B','6561E43E97654FABBF141C7E15F0B49F'),(1780,'C','BDEFDAB949C24702A40106A5251ADE2B'),(1781,'A','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(1782,'B','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(1783,'C','74ADF931B41C41428AD755CE6EBB94EA'),(1784,'B','8AB7AB739A124F77958C6AA2E8D0F70D'),(1785,'c','99A6C7CAA93549AB834FAE50C5EECF05'),(1786,'C','2ED5734A673E4C339FD0B1438DD73B76'),(1787,'B','93FD18AB5C7C41FABD46B4F985C25C16'),(1788,'A','EFEF4800716C4E788A54F08A9008C76B'),(1789,'B','EFEF4800716C4E788A54F08A9008C76B'),(1790,'C','F70A348516C44BD595D2CD4B6381FE55'),(1791,'D','F70A348516C44BD595D2CD4B6381FE55'),(1792,'D','EFC117396B744D1680DEA4C229793E4E'),(1793,'C','96ECB3FE612E4FCC83210C5A18943BE6'),(1794,'a','CB644C9EE5B845138FCA065C4FBD168F'),(1795,'D','0867D52E1F0746ED83B62A04A4A00D98'),(1796,'A','C0AFDB5D127540A1A3E8937982AA9780'),(1797,'D','C0AFDB5D127540A1A3E8937982AA9780'),(1798,'C','C1DD9BE59F9A47A5B2C610BEF8F88141'),(1799,'A','84979A08FBAC4584AE4D61E43B2BA585'),(1800,'D','84979A08FBAC4584AE4D61E43B2BA585'),(1801,'c','5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(1802,'C','1A2645D1AEE54168B6B253C3DD0CA998'),(1803,'A','213431AF11204FD69CCF18F8439522B5'),(1804,'A','0FCBBA0E48CA43AAA7E30796D30F9CB1'),(1805,'C','FFA54377478E42D7A01E7D71E3BBA729'),(1806,'c','0413E90435FC4D4FB1FEE23601F9FE7A'),(1807,'D','E8952C853EFF4BFF87F05D414D4ED78E'),(1808,'B','D203B21A22A341059D50FF51D820BA1A'),(1809,'B','7301865F1FD946079509C0AFF72F804B'),(1810,'D','B0AB1A23B3104B4BAF40A190A0CE2597'),(1811,'c','4A0A7795EA85408093FD320E246F3839'),(1812,'A','6BEBF5BF0802488AA946FB02AE7F6A8F'),(1813,'D','6BEBF5BF0802488AA946FB02AE7F6A8F'),(1814,'B','12542706BD1B47119195DC25D9FBE82F'),(1815,'D','CF84EF1519B44EA391DFEB1D7669C4FD'),(1816,'B','1F908DE55FC44B5DABA7F325B741FABE'),(1817,'C','1F908DE55FC44B5DABA7F325B741FABE'),(1818,'D','1F908DE55FC44B5DABA7F325B741FABE'),(1819,'C','BD9451FDDC5344B2ADF9B2071536DCBE'),(1820,'D','9BD5843563AB40E582D75AE781066C2A'),(1821,'A','AE0268E517A74B4E8C0674B98BA4937B'),(1822,'D','AE0268E517A74B4E8C0674B98BA4937B'),(1823,'D','1EF1C021F1664F89B606141F9944285B'),(1824,'C','595F46030B864B5AA7A2514C5FD01530'),(1825,'D','D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(1826,'a','0A4B1D2AF0084D7B895035B5EE77D8E6'),(1827,'C','CFA4D63725C642A48F7FF82A23D6DF68'),(1828,'B','09CBFACD70A14F2F9745A645E465E922'),(1829,'D','09CBFACD70A14F2F9745A645E465E922'),(1830,'C','61F3E2D3FA414A7C982585BCC73FFA87'),(1831,'B','9222CF3B26344D5ABF02A74B4D16EB26'),(1832,'a','0AC17E06E97042EFBEA37DFCDD508C66'),(1833,'B','64C581C57611435FA96D0C207F770D40'),(1834,'A','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(1835,'D','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(1836,'C','AA64AE2B1CFA45B58FF91578C0C692E9'),(1837,'C','C67CA358B09B49B082703D8FB5487FC7'),(1838,'D','D7F585C00576434F9E229D2B28AE5B94'),(1839,'C','4980664FEEE74094BE1EF5C56E0CF621'),(1840,'D','4980664FEEE74094BE1EF5C56E0CF621'),(1841,'b','F6CA9C10199B422A97C874A6E8014FEF'),(1842,'B','65AAEF852B1241298EF0DD8CE15CF55F'),(1843,'C','65AAEF852B1241298EF0DD8CE15CF55F'),(1844,'D','65AAEF852B1241298EF0DD8CE15CF55F'),(1845,'D','2DBB8289CE3848ED8436AC61EC34CEB8'),(1846,'B','0EBBB7F18A16459393FF93CE72EFADE6'),(1847,'B','3D1895E837B5483CBE893C45DF5AD110'),(1848,'A','BCE8E2EB961046C4865CFDD088105D7E'),(1849,'c','55A3E48D36974DAAB0070567857162EB'),(1850,'A','25FA8D11E9AB40B48B33145A15B64EFB'),(1851,'D','25FA8D11E9AB40B48B33145A15B64EFB'),(1852,'C','74345EFDF9CE487B92EA4DF6D9A26F3A'),(1853,'B','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(1854,'B','60BB608E6E6E4C32BD2D4FECCD02E707'),(1855,'b','8636C2FA7EB948A2A4F6C0A081D24DB8'),(1856,'A','632D0490B4F7404D91A9DB9D4862358C'),(1857,'D','632D0490B4F7404D91A9DB9D4862358C'),(1858,'D','09428B0CFC0D4C92A64BA390292D8FBA'),(1859,'C','8A7D182C8E044B17AB5EDC822114E7EB'),(1860,'a','22AC3BDE7E5D44039BA2D0B3691A6E97'),(1861,'C','C989535D3DA2465397237A0DF7D4A1ED'),(1862,'D','C989535D3DA2465397237A0DF7D4A1ED'),(1863,'a','83D4F9BEFC574F7FB720DFA04F6F8D9C'),(1864,'c','FB35A591A3CC4B799FAA2CB19F0F3337'),(1865,'A','D652C6EA73224BD0AA68641FE2FF8953'),(1866,'D','D652C6EA73224BD0AA68641FE2FF8953'),(1867,'D','435DFF33FBBF4C8BBF22B18E4D6FCB66'),(1868,'A','274E7BEA6110417882F2ECAE1D5E2701'),(1869,'D','274E7BEA6110417882F2ECAE1D5E2701'),(1870,'D','CD86DC85642E4EC4807A6AF1D59CE34F'),(1871,'A','CD337A4012E84D54BE512743FCAD3652'),(1872,'D','CD337A4012E84D54BE512743FCAD3652'),(1873,'c','81E97EC6AB6D42F9AB7694E0964B9FEF'),(1874,'B','855F8249B7FC4718A6B81DEFA9876E57'),(1875,'C','855F8249B7FC4718A6B81DEFA9876E57'),(1876,'D','855F8249B7FC4718A6B81DEFA9876E57'),(1877,'C','8B1C032B2EDC4B96AE3B1B2564F4F20C'),(1878,'c','A90B7EB988B94928891FE56B40027C73'),(1879,'B','63321AF40BF541E19D74646BB674A19F'),(1880,'C','5B06C53FDDB54E7FA921FA7A5073A57E'),(1881,'B','97DDA73A5682439DB14849C80DD0084A'),(1882,'D','F877409A392345589C51F43EE52FB5A7'),(1883,'A','EDE23230BBA4443A807812268B2BF4BB'),(1884,'B','EDE23230BBA4443A807812268B2BF4BB'),(1885,'a','555CE6702DB64A73966AE59F3E576DC1'),(1886,'B','4396F09A6AA84E1B864D2C63A6337752'),(1887,'D','4396F09A6AA84E1B864D2C63A6337752'),(1888,'D','53381A42A43340FEA4767E580690F62E'),(1889,'c','436D43A3765A462C822FF1A0DE416D15'),(1890,'D','23F2E8A0873849D5875F9B7DA8B217F6'),(1891,'D','825D7955FBB04834A4D1D6441C4480B4'),(1892,'C','9ADE4D63B86A4EA9895E5ECEBDF919D7'),(1893,'D','4B733A8DEE6D4739AA5417D62A9AEC50'),(1894,'D','7540390049DD4A7F9D190C9F10BA33FC'),(1895,'c','EDF65AC0A4484B0B820A06E9D8FC2EE0'),(1896,'C','F06B1A470DC2487491F6A83E30E5DBC9'),(1897,'C','CF803CA8E4BF4930BA818B704B11BDB4'),(1898,'c','0E2A5BD27E394B1090CA3124092283E7'),(1899,'B','EDE0E139CEC3451C8E9854861259C3D1'),(1900,'A','938DB3CC18C64FC18699CFE62E181DE9'),(1901,'D','938DB3CC18C64FC18699CFE62E181DE9'),(1902,'D','DC7D5F74C96E415AB785C71833AB8D2C'),(1903,'D','9049E39730144C6C8739DB31557F6633'),(1904,'B','15C5ACD252D645E1A8084BDCB22BD1F6'),(1905,'D','15C5ACD252D645E1A8084BDCB22BD1F6'),(1906,'C','24B4F2D7F305451F87EF5643A6D0C828'),(1907,'B','0543D8D393FE4F82A89CDD251772D061'),(1908,'B','EDC1A3552D814E34ACAED9520D61A2D1'),(1909,'D','EDC1A3552D814E34ACAED9520D61A2D1'),(1910,'B','E410C06B1C1048CFA0B99B4B28D44B3C'),(1911,'B','7B8E1CD00AE149FA80B507FD9164290F'),(1912,'C','7B8E1CD00AE149FA80B507FD9164290F'),(1913,'D','7B8E1CD00AE149FA80B507FD9164290F'),(1914,'A','8298338D4AE4437194D940338B7A3CFE'),(1915,'D','8298338D4AE4437194D940338B7A3CFE'),(1916,'C','5CB23EC66E6B4B2DABEC0E239C86D451'),(1917,'C','F989D5B7E01948D4A88173210106E6CC'),(1918,'D','F989D5B7E01948D4A88173210106E6CC'),(1919,'C','ED10214CC95241C1A21839DFB6712B59'),(1920,'B','81DDD64B5091404E903A638A3275BB87'),(1921,'A','4776E09F1DBA4192BB1C38A4544C45FF'),(1922,'D','BF9E794FB6204B4DA28344838DB36967'),(1923,'A','E1AD6D445318499694C6435F2D5F074C'),(1924,'D','D84A574885B249F5AEB13A59A3601AA4'),(1925,'C','7CBE3D12E4224139B9EB06C786ED28FD'),(1926,'c','03BC69A2D63B49AC97A4356D8FB0A380'),(1927,'B','09C53C15B56941238EF4E2F8B00A9F95'),(1928,'b','78E4D599990449DD9FA65CDDFBE61CA2'),(1929,'c','FC741D0D99DD4FE093AA5766536AF46C'),(1930,'B','58D055FB14FE43ED919859CCCF067B97'),(1931,'C','58D055FB14FE43ED919859CCCF067B97'),(1932,'D','58D055FB14FE43ED919859CCCF067B97'),(1933,'C','F190C2F69AE34F4B91E74A208A069C7D'),(1934,'D','F190C2F69AE34F4B91E74A208A069C7D'),(1935,'A','329706FC45284D01B254145C2FDC6FF5'),(1936,'D','329706FC45284D01B254145C2FDC6FF5'),(1937,'D','A0A9C16F6CDD4C0C9C5B0DA460076A29'),(1938,'C','808A0BD91EA549508B3EDF9312B85848'),(1939,'D','3D05015A6C164D7783F984AB539C3358'),(1940,'C','33E22D18B1A548E68947E03AA501A447'),(1941,'C','81F52435CD614AEA92585458280A090F'),(1942,'A','FC35A8164F4849C7B9DF535EC15B79E6'),(1943,'B','FC35A8164F4849C7B9DF535EC15B79E6'),(1944,'C','F972C82759434FC7AAF61E0C14AC217C'),(1945,'b','1D15934771994B7FA18EE7C70DB61D1C'),(1946,'B','79C4369D5C084B009ECAB86185455F68'),(1947,'B','521F8738D95F4360BA4257A38DD65584'),(1948,'c','F43017E7D7994F1FB738CB11F4046AB8'),(1949,'D','9F13AA53017F456CBCD746891E672C3E'),(1950,'C','295DD721E257458DA40B3B17E8599AA5'),(1951,'A','16A6BF18CE014E06AFF9A5BE86AE13E3'),(1952,'C','6898DE2C981C41A198058EAF9EEE16A9'),(1953,'C','32C34E0881AD47F49BE0B4D549D50988'),(1954,'C','DD9C53E5FB494381ADA04E4638EC428C'),(1955,'B','2615D6CD0F1C43978448245BDF843B5B'),(1956,'D','2615D6CD0F1C43978448245BDF843B5B'),(1957,'D','19B517D3B52F40578347905C3D044486'),(1958,'b','F9FA720A32EB4F969E6A5104E0C8E8DB'),(1959,'D','E70032CFDD22460C966839D6828B3D84'),(1960,'D','1BF333CF63E64126A30DD17110FB01AA'),(1961,'B','D660E09215B34A70BDC91F490EA27A06'),(1962,'D','66A765BB58C54E408F8B8A597438D34B'),(1963,'B','E0E5CC9B9DFB46D585F1547C00361D74'),(1964,'A','4D21A34788D84C99B33234D0632DA411'),(1965,'C','3CC7679ED20943A8AB106E2B229CE269'),(1966,'C','375B9BBAE57B4CF3A9A85DF58C603211'),(1967,'D','F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(1968,'A','2D92B3A0EFD24E698D9B7907B5338C11'),(1969,'B','2D92B3A0EFD24E698D9B7907B5338C11'),(1970,'D','2FE0D8ECEB2341F28F9A298B99DBE435'),(1971,'C','003A3CE42BBF4289B57F500920DA5DE3'),(1972,'c','119E5EF740FA44EABD71DFAD54A61393'),(1973,'B','C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(1974,'D','E6BED81C3B174E708FC985C1CC16F948'),(1975,'b','EC95DFD2A860487891780D49A0816759'),(1976,'C','F47CE03E84ED4C78AE2B01EFB0BD9982'),(1977,'B','B5F2F5237A8C4C5D9498F5598C177300'),(1978,'C','B5F2F5237A8C4C5D9498F5598C177300'),(1979,'D','B5F2F5237A8C4C5D9498F5598C177300'),(1980,'C','99629B14E46243759AAA9D372F54F79B'),(1981,'a','AC6471EC5B974392934D74BB93F9433A'),(1982,'A','7B5788DE261E4F0B831E2E5DFF8B48F3'),(1983,'D','7B5788DE261E4F0B831E2E5DFF8B48F3'),(1984,'A','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(1985,'D','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(1986,'C','2CD78964FDB04D3286C934F576DD6AA2'),(1987,'D','2CD78964FDB04D3286C934F576DD6AA2'),(1988,'B','6BBE419AF2B74821923AE428CD594584'),(1989,'A','91ACB31317C14810AB7FA8D25F474A31'),(1990,'D','91ACB31317C14810AB7FA8D25F474A31'),(1991,'D','F547BF7A1E9640B8B7E819EF06D18141'),(1992,'C','B4F0B52F92B14322932F9F3468E64390'),(1993,'D','B4F0B52F92B14322932F9F3468E64390'),(1994,'c','3E75ACCA16C14F7191BE8EBDA6C3AC32'),(1995,'D','80A64B51289C40FE93FDE1BBA74D0022'),(1996,'C','C0EEE70D6F6F4968B8296E2D52E2F1B8'),(1997,'a','5A651F4832374D32A049DB3B119167A6'),(1998,'D','533E7E73FE0348D0935D07BF4C5D8860'),(1999,'D','50E80301AF3A4036A1CC737159EE46CA'),(2000,'B','76B3C03EB0C04229974EF7B08BAB3404'),(2001,'b','40AF6A85DE0D44C3AF6F2122C99033D1'),(2002,'A','B9494DA7CA294715BCE7BDAA3446C82B'),(2003,'D','B9494DA7CA294715BCE7BDAA3446C82B'),(2004,'a','EB20C87468C647FD95CA00663E89E733'),(2005,'B','87FA9065EDAC4039A085CC9DBD15063C'),(2006,'B','3CEEDA7CD02B46F3BF0F5CFA32D45399'),(2007,'B','0E08E66A8AB645159BCE242D26B62202'),(2008,'D','9EE93CF38D344B13BDE4CED1D5358251'),(2009,'A','1A5266262367427C8637D993FE966F21'),(2010,'D','1A5266262367427C8637D993FE966F21'),(2011,'C','48CA108F7CF14766B4066F3298186FE3'),(2012,'A','2039E97D0941437E8774BD4D4C9CC5A5'),(2013,'D','2039E97D0941437E8774BD4D4C9CC5A5'),(2014,'B','E54F7561D1A54BCFB5BCE654A9B939E1'),(2015,'B','E0BCA8C7EA704D44B25AD8D9FBBC9049'),(2016,'c','6A4B6D306E954A58AF67FE2B0918A52A'),(2017,'D','9ABDBBE373C945ADAB6AECD62691B2EC'),(2018,'B','A96CAB20630C46FE98F12F3F9E4EDBC3'),(2019,'D','E34607B970B847F5833C3EE91DBE260A'),(2020,'c','592045A682C143F1B5F73AB2BC49EA39'),(2021,'B','15AF822681384E0C8116298B275F4E5F'),(2022,'B','154A8F749A014BB89B6559B2ED663231'),(2023,'C','154A8F749A014BB89B6559B2ED663231'),(2024,'D','154A8F749A014BB89B6559B2ED663231'),(2025,'C','B381A76FE262452B9E6C9478034D7294'),(2026,'C','E0EBC82ADAA04CB6A525D33648826673'),(2027,'C','DAA6D7CA54404D2ABD317D6E34B54068'),(2028,'D','9B0FDE2C2E8140E5A112E7196C143B96'),(2029,'B','867759DE356A4AF4A9506844D56D3CBD'),(2030,'D','867759DE356A4AF4A9506844D56D3CBD'),(2031,'C','9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(2032,'D','06817551644C4775813A63475CD22F5C'),(2033,'C','B647C898BB624E8B9C169FA8ED71DB11'),(2034,'A','8254D1C937494DC1BDE603DFBB7DBA20'),(2035,'A','494A6ADC1C424B0990FF898174DEA3BF'),(2036,'B','494A6ADC1C424B0990FF898174DEA3BF'),(2037,'D','CB798645904E4DFBAE124FC361420EDE'),(2038,'A','0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(2039,'C','F1A5E74880D34C7CBCFD7ED24D062263'),(2040,'B','6D2079CAACF54FD1996EB3B034058787'),(2041,'C','6D2079CAACF54FD1996EB3B034058787'),(2042,'D','6D2079CAACF54FD1996EB3B034058787'),(2043,'C','7BA353CD6E6146AA9BD40C103F8F0B25'),(2044,'c','A086187FDE3E411DA803CCA6FD4A260B'),(2045,'A','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(2046,'D','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(2047,'c','95BB57D10490464CACCB836D1987B76C'),(2048,'C','A14341A6F3284C5CA55170871D4A4FA1'),(2049,'c','1B60F1B1E9E9432AABA1E787C9867C5B'),(2050,'c','AA5A5FB2ACCC4BE7894B8E1280C50B53'),(2051,'C','CFDF209AC9C147ADAA00CE3B89365063'),(2052,'c','7ED13A90A5E34B73A766B23C1F0C11AA'),(2053,'C','33826A86CBF94E76B700F60AD89095BF'),(2054,'D','0299E16829EB473F86EE48E22507392A'),(2055,'C','489788BA73894390B508732C250373F3'),(2056,'B','167C1305788C46FCABD8D296563274AA'),(2057,'D','167C1305788C46FCABD8D296563274AA'),(2058,'C','AEAA6705843A42FE9B935AA76736D75E'),(2059,'C','A8C158F95DEF44FF87D4805613DCCA05'),(2060,'D','A8C158F95DEF44FF87D4805613DCCA05'),(2061,'B','BC40F65384954721B7F35CE058DC2070'),(2062,'B','E8A9CABCE48F44FDB8660AF66F9CD579'),(2063,'c','A7CD4554B61F45AE8C3CB6EF8F1E859F'),(2064,'D','7736CC6C00C747D9A3B37296533358F8'),(2065,'B','9E43F442CC244D75B12236BE6ED302B7'),(2066,'B','6A7CBD3CF9DD4923A736F30B26C0F341'),(2067,'c','7A1067BE51724D56AD76B9A2DBFED6CD'),(2068,'C','E843E01A778B4E529EE11876783B61D6'),(2069,'a','63DE80D28D9E4134AB8122CDD21F3A27'),(2070,'A','D4A41C347A0C4A92B7BB84DDA41ADC40'),(2071,'D','D4A41C347A0C4A92B7BB84DDA41ADC40'),(2072,'A','DA658CDFA0EA4008A43FF6B5C8F18337'),(2073,'b','96EF4A0B490C4290914DDAC8D05AF71A'),(2074,'D','5A66BF0CE99F45AA86BCA1699BB63B71'),(2075,'B','40885C34DB05481FB4269E64A982B194'),(2076,'C','40885C34DB05481FB4269E64A982B194'),(2077,'D','40885C34DB05481FB4269E64A982B194'),(2078,'B','195C9E8E3A51477687A7D71BB2EB1F84'),(2079,'C','F64E7F4C040C4863ADE8A76716B5069F'),(2080,'c','A2BDA62415F3495DA7BF416B26FACF04'),(2081,'B','C2E31B5A2299479EB316899E28AAC73C'),(2082,'C','AAB10F8D7C7940EC9B91ED5C07E7FD57'),(2083,'B','FF9F91C6DE7C4F70B25A30900DB69D3E'),(2084,'D','FF9F91C6DE7C4F70B25A30900DB69D3E'),(2085,'A','5904376E0FEB4D19962CDC61B5E83D00'),(2086,'D','5904376E0FEB4D19962CDC61B5E83D00'),(2087,'C','254C0048C836445AAC8CF2F05E896957'),(2088,'D','7C9BB443AC7D41B7A3049CB978D5F984'),(2089,'D','44967D1672CB49C2ACB62C2A9E264DA4'),(2090,'C','014E8A798851424C9F8EB15B1D3EF004'),(2091,'C','789AA087285040E8A654170258E693CA'),(2092,'A','BEC05EC41F6D423F8F42BA058CAFE4A6'),(2093,'D','BEC05EC41F6D423F8F42BA058CAFE4A6'),(2094,'a','988A4504583D463B954CB26D7AB138DA'),(2095,'A','B241A08F2AC948449075C5E5C0E818CB'),(2096,'B','B241A08F2AC948449075C5E5C0E818CB'),(2097,'C','4D0C6E8D8EFA468BB0CD1C4274576553'),(2098,'C','A77262B0AF5740DB87C9A51FE4911E16'),(2099,'B','61D69936A43F41FAB8796932AC9D115D'),(2100,'C','C427D5723A7A43D9A9C11B98994CA1A6'),(2101,'D','1DAB54B841644A20BD0CE37C7024FF1E'),(2102,'D','8E5BBA0B691048C683966FF703BA6E07'),(2103,'B','9731F99B9C4A4110B8F5829407E29481'),(2104,'D','D9E8856D46EA40F58B247109E2BEB758'),(2105,'c','E020D6EFC3B5417684331BD792869938'),(2106,'C','094EC8B8D038495EA86724EA0CFBC8E6'),(2107,'A','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(2108,'D','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(2109,'A','281B19C9F69D47C59305436EB36A633C'),(2110,'B','281B19C9F69D47C59305436EB36A633C'),(2111,'D','66B11088551247C1924DF310A1641786'),(2112,'D','709B464AAA3647358F69D68D509EA8E3'),(2113,'B','58552B603604403A958B9DA4495C11D8'),(2114,'B','EA9CC06D7373460D9678ECA2894E64AA'),(2115,'c','2D9BE9797C2245D7B1DB8E09C6ACEB53'),(2116,'C','DFAEAD70CF24459AA6F0C3223111B42B'),(2117,'C','73E3DD9CD09C437AB61941BAE111767E'),(2118,'D','D909313558454382A29345276AAB284E'),(2119,'B','66684A524E94456C967B1DE167DC0CFB'),(2120,'D','66684A524E94456C967B1DE167DC0CFB'),(2121,'D','B8A918ABED9F444A844BE17CBB2C8639'),(2122,'c','E9D73490F69F4DF6B653181BEC8E8F24'),(2123,'B','3E6945401C5D485F8323E8CDFE5E9493'),(2124,'C','4A88DE2F3B1946A489889028214E14D0'),(2125,'A','01A46533ED594CE49940A246AF19B1A6'),(2126,'C','866AA7190E484BEAAF35BFA62177E6E9'),(2127,'D','866AA7190E484BEAAF35BFA62177E6E9'),(2128,'D','B2D5668D6F094EC196253CA62154F829'),(2129,'B','D387242B65A14D22B43371C16F8C9411'),(2130,'A','18632F73C2844543B0C18A4322CA8339'),(2131,'D','18632F73C2844543B0C18A4322CA8339'),(2132,'D','5740D06016464C47B7E7C107A30B7CB0'),(2133,'D','09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(2134,'C','AAF89D30DF4143DEB7F23A931682BBC1'),(2135,'A','40EFD49AB39747948D5F83176DCECCDA'),(2136,'D','2AE08401C159412CA3D1740681579A50'),(2137,'B','A6F99C70A86343DAB7670CA79FCCA63A'),(2138,'C','A6F99C70A86343DAB7670CA79FCCA63A'),(2139,'D','A6F99C70A86343DAB7670CA79FCCA63A'),(2140,'A','98EF0AFE64F345369A76B641C32486F0'),(2141,'D','98EF0AFE64F345369A76B641C32486F0'),(2142,'C','379B0496E3A9438D8B7F6C9422666D51'),(2143,'C','0B721D7D16F04592AA6F42749580D033'),(2144,'c','EE1A413F380D4309BBFFF711A8648157'),(2145,'a','B7A3FD0A53D44C839EFA0E045283B7D2'),(2146,'A','157D8F6E86244589ABCE190C55E9E206'),(2147,'B','157D8F6E86244589ABCE190C55E9E206'),(2148,'C','5A4370DBC11A467F8F2B7DD7B12A02A8'),(2149,'A','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(2150,'D','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(2151,'C','8FB8A3B925264124ADC086FE3BCCF07C'),(2152,'A','C1B926935A27482F8BDFD800A0E134E4'),(2153,'D','C1B926935A27482F8BDFD800A0E134E4'),(2154,'C','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(2155,'D','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(2156,'D','36328B1A27024DF5BF53EE86B0AFE395'),(2157,'b','4E3F5523794448A682A9E45F720D337C'),(2158,'b','AB86306982F64A30A843B32CC551A395'),(2159,'D','0DEC67667703418A9D500A6AA492ECB5'),(2160,'C','DE9FE12BDBE2439390748073206FD7A5'),(2161,'B','B6A9FDC67237424789850CDC62960F6F'),(2162,'D','B6A9FDC67237424789850CDC62960F6F'),(2163,'D','749BB2EA756F45EA81C7DF86DF55C4CE'),(2164,'D','39E6BC067CAE4D17AFC56F575DB28D62'),(2165,'b','5A7BC33966824788AAF68E077BF4B593'),(2166,'A','2C9E2DD1F915459EA056A5A349137FD6'),(2167,'D','2C9E2DD1F915459EA056A5A349137FD6'),(2168,'B','45CD38F7BB2C4E00B47734F25466E71D'),(2169,'C','45CD38F7BB2C4E00B47734F25466E71D'),(2170,'D','45CD38F7BB2C4E00B47734F25466E71D'),(2171,'C','9688B22F8FD44D63980AEAC3A2F89B7F'),(2172,'D','D172597C84C341F0866B539C4483B2E5'),(2173,'c','00E6391CB1EE4A6BACCF7F7B72AB410E'),(2174,'B','568BDC18AB1045E8813E099558FD496E'),(2175,'C','568BDC18AB1045E8813E099558FD496E'),(2176,'D','568BDC18AB1045E8813E099558FD496E'),(2177,'C','C6B500BD927C41C88DB9D00BFD7AF0FE'),(2178,'C','0788717DF9EE497C8BADC2D9A7E9D19F'),(2179,'D','0788717DF9EE497C8BADC2D9A7E9D19F'),(2180,'c','6D63BDFF890D4ABDB9024BB9BA454AF9'),(2181,'D','EAA46BF912CE4CCBA52FFCB463793446'),(2182,'C','06C4FDDABB98445A81483DB9CEE1AFEE'),(2183,'D','1A96EAC9928141F094CB921ADBD1B6AB'),(2184,'B','53160599A2B34D3FBD1302AB2F9C6CF0'),(2185,'C','53077725492E4C7ABA5D53A5CDADD450'),(2186,'D','EF2C064FF3864D3388B7B8DFEB930BF8'),(2187,'C','8F66DA2C47EA4C2385210F2F81178064'),(2188,'B','43603D2B89624DC99830BD1EE69C3730'),(2189,'D','81630083A38F49D0BE960AD6F062ACBD'),(2190,'A','29A867228E2A435EB5B098E83FAB5889'),(2191,'D','29A867228E2A435EB5B098E83FAB5889'),(2192,'D','BF0E49DD27164962897E2AB31605477D'),(2193,'B','F2046F13400747ADB57821BA597C86A1'),(2194,'C','C1619AB6ABCA428BBE2DB67FCA8A3232'),(2195,'A','266DAC8CF357407E9EF594744D49414E'),(2196,'B','266DAC8CF357407E9EF594744D49414E'),(2197,'a','9BE869101F7A4AEA9A75C927C78A984D'),(2198,'D','FBE4320644EB4B7C9635A397DFA6D74A'),(2199,'c','6561C61E1AC646EB88C22636AA6A1E0A'),(2200,'A','2F841EE0DFBF4C82A8D2AFF4619B6912'),(2201,'D','2F841EE0DFBF4C82A8D2AFF4619B6912'),(2202,'c','FAB2F9E3E32A40A9BC43857BD6B97C00'),(2203,'C','E26645938F3545CCBD41E8C1CB3B6093'),(2204,'b','2EF993C3309E41BCAF1ECA02A88AE421'),(2205,'D','54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(2206,'C','B4FD0B66F64345DFB23A25256028E2A2'),(2207,'D','B4FD0B66F64345DFB23A25256028E2A2'),(2208,'B','1C0CF566310C45FF8F76F7FFDE05B2E8'),(2209,'A','04192177F3B2401589AB65735D756D55'),(2210,'D','04192177F3B2401589AB65735D756D55'),(2211,'B','FAB1E10EC3C048BAB84520D159612BAA'),(2212,'B','0D4F2426ECB14C88831F56D9FFBDA19B'),(2213,'D','0D4F2426ECB14C88831F56D9FFBDA19B'),(2214,'B','4483E7EBDD2945E88054262B69920F76'),(2215,'D','44A7015B0C9E4DE7BFC397C4F88D158F'),(2216,'C','3227122F1D3B4253937F3AC8BA98F55D'),(2217,'A','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(2218,'D','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(2219,'A','346488CE8EEF4D8D8E0041EA1657521F'),(2220,'B','F3E2C829CD3E40D6BD08ABCB539DA5B5'),(2221,'A','D47B6D432BF74D69A2FF1B9059BCB0D4'),(2222,'B','D47B6D432BF74D69A2FF1B9059BCB0D4'),(2223,'A','AC40FAC9FCD94D05ACF7502468A369B6'),(2224,'D','AC40FAC9FCD94D05ACF7502468A369B6'),(2225,'C','66D0990F809C448EBDEF19B59496FFEC'),(2226,'B','AAB7B4F0DCAF44B5A25602423671A4A0'),(2227,'D','AAB7B4F0DCAF44B5A25602423671A4A0'),(2228,'C','6EC20CEF47054C1C80902F92550C91B1'),(2229,'D','62CFC755832E43CC8636AC529CA8CC44'),(2230,'B','8510596130264C7FAC98B914569D3B27'),(2231,'C','8510596130264C7FAC98B914569D3B27'),(2232,'D','8510596130264C7FAC98B914569D3B27'),(2233,'c','49C7A54A42514EE8972F343F37F799E2'),(2234,'a','A6B4F5F0C65442A69501AD63A919AC9A'),(2235,'C','69441DA83D0748B38D7B1C1CD3AFBDFB'),(2236,'C','1C7FA981148C41C89AF466BDC06FF914'),(2237,'C','CBA03C9AFACB47BA99F5C37C46AF980C'),(2238,'D','58B9E9AB34CE4DE3B726DD52DCE3548E'),(2239,'C','0103F17EE62E497285EC7437477AF307'),(2240,'B','92107D02C994441BA78D6475FC3054A1'),(2241,'b','BF0A5E73F82745769147CDD7F322FB2C'),(2242,'C','F8FB56A58FDB4169AA60FEC42FA09383'),(2243,'D','E9952F11B8C3415BA1609A2C27A1F61A'),(2244,'C','D5A4347BEE0C495C8AD0AD9E2DAA2722'),(2245,'A','7039626842984703B880F302A6610165'),(2246,'c','BBD768F6849C4F7BBD3DF8D44014696C'),(2247,'C','C238FC3B475B4B1B9BBCD1523BEEA0A9'),(2248,'C','B5FE489BDF6B4D42932C9A01C977D569'),(2249,'D','C1ED1AE40D7043F19E7D333333FA6952'),(2250,'D','DF8E33F93C30440A840D498AF2E4F56C'),(2251,'C','10CB3A260EC24B4F9A73F5C6E73E30F0'),(2252,'D','10CB3A260EC24B4F9A73F5C6E73E30F0'),(2253,'C','A15C848F87C54EA9A608CED45093462F'),(2254,'c','C17AA689F2424E9A9AFEB8190FA43458'),(2255,'B','2972A4EFD72741BEA09835CFCF7252B1'),(2256,'B','5285DA94409A45D6BE4433A67D94AE72'),(2257,'a','F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(2258,'A','22AA7B46E9CC4FF9A52C0D91F2531BA7'),(2259,'A','7096A670872842DF935B5B2A7602156A'),(2260,'B','7096A670872842DF935B5B2A7602156A'),(2261,'c','0758F9F59E1946E3B274047C62015ADB'),(2262,'B','233169FAA7A244BCA1C4F30FEEAFD4BE'),(2263,'C','17AD95CD9BC54FEA8CF08604C1EF8715'),(2264,'A','CF614B35CCE44E79A1259A752F6DE2FA'),(2265,'D','CF614B35CCE44E79A1259A752F6DE2FA'),(2266,'A','DCE44BE62D9A47EF8052023CA5CEA01A'),(2267,'c','CFC744FF351F46DCB24368F04E696D44'),(2268,'B','6BD84423199644FC957A96F9D476DD42'),(2269,'D','6BD84423199644FC957A96F9D476DD42'),(2270,'b','334F5C50917D4A3F9B535A64900CD18D'),(2271,'B','3788075215A14C04B495EB95BB4EADA2'),(2272,'C','E00157DEA9A04A18872B46BE84F13D94'),(2273,'C','CE7677332D704CCFAAF1860B7B396296'),(2274,'D','1C3D9B50490F42B8A878F3B2DE1D45E2'),(2275,'D','0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(2276,'c','BA073725DF8C439D801FB1901636DD57'),(2277,'B','3A65C6D9B6AD43189E49E5ED6AC319CB'),(2278,'C','005802D091E542519BFC003D0E2D2E39'),(2279,'D','005802D091E542519BFC003D0E2D2E39'),(2280,'D','BAEBC257AB0045FC946236CD71F8AB3A'),(2281,'C','393D2E8FD028481E98AFE3DBB036177C'),(2282,'A','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(2283,'B','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(2284,'B','99A265F02E1B4F238F1171485A4E7DFA'),(2285,'B','0819BE7291624D0C8A8F0DF701EFBBA6'),(2286,'A','BB543D312AF84975AFB0615D833A236E'),(2287,'D','BB543D312AF84975AFB0615D833A236E'),(2288,'a','5E98C9F825FF4370BFA8FADE88BAD2DA'),(2289,'D','E81064F468FC4E27A2393FD79F7E9503'),(2290,'B','2A2AD3907EE647BFBB0F60B90A9F1FED'),(2291,'B','A6B39AED85044B269AD6D4610A5E594E'),(2292,'C','1F751F03125F4385B745F6B2A50D4B75'),(2293,'B','209D4121BDD74D738EEFF4243D813872'),(2294,'B','0A09594770674B909158E12AC60DCDD6'),(2295,'D','0A09594770674B909158E12AC60DCDD6'),(2296,'D','19F96C702E0F44BBBD84E8A3554949D2'),(2297,'C','957A3EE7FC7042F2BC267DBA2205A448'),(2298,'C','87A936136CF04C099C2577BDBBF2BE5E'),(2299,'D','8F17415408FB486488BC09A48902016E'),(2300,'D','6942988593844717A912588376F9CCFB'),(2301,'D','5530964D6602461F8FE56F45791A3455'),(2302,'D','CF5A8EA158EE4D82BC2DC7CE0084C03D'),(2303,'C','D98520CFD5CE47AAAB11563B4F87C1C7'),(2304,'D','4D71AB4F57A1439285F72C8F606054A8'),(2305,'A','9D8493807AC946228A02780FD7FC48B6'),(2306,'D','9D8493807AC946228A02780FD7FC48B6'),(2307,'A','4C96E244ECFA49BD9CE06FF1DF394B06'),(2308,'B','4C96E244ECFA49BD9CE06FF1DF394B06'),(2309,'c','C20394955A17428495CE9F8CE8ECD17B'),(2310,'B','83CA050675FB4356BA1E6AA1FEB6610A'),(2311,'D','83CA050675FB4356BA1E6AA1FEB6610A'),(2312,'b','2F0A0E2658D6413F8F964E96F766C6A8'),(2313,'D','7E2DD2FC2C3B43C1AF53250B313D439D'),(2314,'c','E53714C0994746ADB2F291736C1EB2E8'),(2315,'C','B755D9D1A6DE4D39A470D994B9992D0B'),(2316,'C','93AEBD5A03DE40A081FAC479B064AA6A'),(2317,'B','31565EE2E3AB45B58F4C9032DE5F92A0'),(2318,'C','31565EE2E3AB45B58F4C9032DE5F92A0'),(2319,'D','31565EE2E3AB45B58F4C9032DE5F92A0'),(2320,'c','CC3BA4021D4844C997650D81BAC9CDF5'),(2321,'A','F7ACC12522434C32982E69D7CB36BB7D'),(2322,'B','F7ACC12522434C32982E69D7CB36BB7D'),(2323,'C','D393233A19904F8E8C05E08B03A6E065'),(2324,'B','068F92537E9A4B6688FC5468D0F4488E'),(2325,'B','5D9F07B342374D72BF0CA911D3BE6EF9'),(2326,'A','1280DA32B07C4297BAAB3859C642CE1C'),(2327,'D','1280DA32B07C4297BAAB3859C642CE1C'),(2328,'C','7F35566F68F442FE9FA50A03874BC5BC'),(2329,'C','5EA296E0B2394366992630E5E7EBAC92'),(2330,'D','5EA296E0B2394366992630E5E7EBAC92'),(2331,'c','54A24ECB2F044D4995E456CBC98C34A9'),(2332,'B','DF8196C18EE9474F8F99C73E78C4882F'),(2333,'C','DF8196C18EE9474F8F99C73E78C4882F'),(2334,'D','DF8196C18EE9474F8F99C73E78C4882F'),(2335,'D','FB80C4CC2B504CCB98837EA5F79261E7'),(2336,'A','3B126CEAD90A4CE5B172771566B43E58'),(2337,'C','0C521B1F840C4F3EA961FA58D9BE1FEE'),(2338,'A','A5739E94DBF34F1687AF7D70AF300FD4'),(2339,'c','16AD3C14ABC342EEAC474B7FA17118B1'),(2340,'B','CF630409634242BBA9DEAE4E621B083E'),(2341,'D','1F1B3B43C1804FE288C77D3B11B7B92C'),(2342,'a','724408989A4A4E898D0DF3DDB3685C9E'),(2343,'D','7038A9A5FBA74724BD51F48683E07478'),(2344,'A','B64F2E0D5EB843709E2FF88F3B53D8B0'),(2345,'D','B64F2E0D5EB843709E2FF88F3B53D8B0'),(2346,'B','5063318F9F8948B98596AA89E3AD5C2E'),(2347,'C','F205F4C97EF64B339A620EF65BFEB3B7'),(2348,'A','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(2349,'D','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(2350,'C','8F01E94DAF54499DAE4383F918C5F9B3'),(2351,'C','91ACD865B67246608C32C964E6830CE5'),(2352,'D','91ACD865B67246608C32C964E6830CE5'),(2353,'A','6CCFE1E7A6AC4235A3D92E639F540F10'),(2354,'D','6CCFE1E7A6AC4235A3D92E639F540F10'),(2355,'A','F868F017613D4F7B82A520CA53820A88'),(2356,'D','F868F017613D4F7B82A520CA53820A88'),(2357,'D','A5E650650953487BAD3C330A032F013C'),(2358,'c','9FB90ADD96C7406B851262044667F7CF'),(2359,'C','16223046B41E426CB0C993521EEFA891'),(2360,'D','6990A7987D8245AD9F11ED484497DCBA'),(2361,'D','A1268745F6DA4A9FAB5AD49B88B5125E'),(2362,'C','B06E364A021E40EDB1C2BB2B1A47DCC1'),(2363,'C','0340DBD2C12B4670B78BC4661DEAE63B'),(2364,'B','5F5257B93B4F44D58F3630AF24FD7F2C'),(2365,'C','E5BC17E83BA54CA48A67B6BF02FBDF36'),(2366,'B','A49E51747A864D47860F7F94CA02F7F5'),(2367,'B','67D91679E8D740CE8D23131E986B98B9'),(2368,'c','43E198E4A1C845DA86D244E3D03A6F32'),(2369,'D','57B805FE40BA43D689079E43CEF8EA11'),(2370,'C','935D4D7675F04902AD85B724B07097B6'),(2371,'b','86F86AFFF4D84448820F07C4313BC748'),(2372,'B','2717E466A2DF45788B5E66BD6C064443'),(2373,'A','0B21F6AD31E4484A9532654AEAE0B778'),(2374,'D','0B21F6AD31E4484A9532654AEAE0B778'),(2375,'C','E4938E9343C948E6A4BAE41860A7AAB3'),(2376,'A','14A688A6B6924406AD3C30D2DA0B21B4'),(2377,'D','14A688A6B6924406AD3C30D2DA0B21B4'),(2378,'B','194F09FB279F4DBE83B9782DAB269FB3'),(2379,'D','DC0044090AE5417ABAEE336169AEC828'),(2380,'c','CD53D7573E50468395B5634A9710DC63'),(2381,'B','61909EC7D40B420CB526B272E195196C'),(2382,'A','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(2383,'D','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(2384,'D','D5CAEB569C2C495BACCDC433DCC14F43'),(2385,'D','928098EB84FD4F3ABA57355652DA4A84'),(2386,'c','4B5DE4AFC03C4199B95EA38BDF6A578E'),(2387,'B','761196840F5D4476B24D89CD4A269D5F'),(2388,'D','761196840F5D4476B24D89CD4A269D5F'),(2389,'C','36A9EB0D94274D47A4EF19BFDDAEC728'),(2390,'D','79B26A457F714842A53357F13DF013B5'),(2391,'A','BE9C100157444468B567804E26A76964'),(2392,'D','BE9C100157444468B567804E26A76964'),(2393,'D','E5F99D16E49B469BA578889CFCADF356'),(2394,'C','EC5F649DAA6748B49457A45A601FA813'),(2395,'D','EC5F649DAA6748B49457A45A601FA813'),(2396,'D','3AE6B81417D6476EBF61BC82076D5698'),(2397,'c','29746DC6045D496E972A7B96F4107EB6'),(2398,'c','7F0C627CA34948A2B8942AD79D22CF32'),(2399,'D','69F7B368E6BE41C38AA333C2E74AD035'),(2400,'C','A4D1DB4FC1D641F293D5CC464C3A608C'),(2401,'A','0D16818191AD453F83FDAB28311E034F'),(2402,'B','0D16818191AD453F83FDAB28311E034F'),(2403,'a','5586B0C5CB3F41779879421F4CE69399'),(2404,'b','EA0F993F3CA54470BC757FF6F559BEA3'),(2405,'B','751A2B0AC1BE4919996CEA697AB29521'),(2406,'C','E6AD178C63D44DA198487A72EED38CD7'),(2407,'C','66E71A5906264466B87447349155B456'),(2408,'D','E4CFC7BF9B57444CB207F9F36A2F6ACB'),(2409,'D','74480B5FF4484EC09487846A4FA60717'),(2410,'c','C2423B5C7C33457ABEB5D0A439C82F88'),(2411,'C','6140A62F4AAE45A7ABACA83DB637257C'),(2412,'C','99EF76E7F10E4CE68AD0A1711B37EC55'),(2413,'B','A0E1E56613CC4668A0FE03B27E9C14E8'),(2414,'c','FC0C5DA4DB8F4141ADA9830A215C057A'),(2415,'A','6BE177BBFF0E4ABEABA97BC51777CB83'),(2416,'D','6BE177BBFF0E4ABEABA97BC51777CB83'),(2417,'A','5B5044D1711646F393AA34C88E289DB8'),(2418,'D','5B5044D1711646F393AA34C88E289DB8'),(2419,'B','6FA04AFEC120404C8B84708512AEE940'),(2420,'D','6FA04AFEC120404C8B84708512AEE940'),(2421,'D','4B00617DA3424C7B99336C0321831570'),(2422,'D','8080D48D9EBE464FB7B73E956E6DB304'),(2423,'C','2B31095C9C1C4E2DAA4172FC7F6ACA44'),(2424,'B','09D480AD5FF04337906A6E7D7A658245'),(2425,'D','62051AC20C474638A6CA94B1FBA93403'),(2426,'B','0482AC0B2895429ABD8E9CB09D015E65'),(2427,'C','0482AC0B2895429ABD8E9CB09D015E65'),(2428,'D','0482AC0B2895429ABD8E9CB09D015E65'),(2429,'A','D66FA56B06B04BE9B32DEA5E58E2FED4'),(2430,'D','D66FA56B06B04BE9B32DEA5E58E2FED4'),(2431,'B','555BA336AA0B4412BC7272BE86302EAD'),(2432,'C','555BA336AA0B4412BC7272BE86302EAD'),(2433,'D','555BA336AA0B4412BC7272BE86302EAD'),(2434,'a','D23940DF31ED4F84A2899E935A23A47B'),(2435,'C','1E8E933476994B3E8C31EF93422AFEA0'),(2436,'C','E5A0C168BE6A44EAB8889AFBB8DE39AF'),(2437,'A','D2B6F35A17FD413B97CF9B108CF38544'),(2438,'D','D2B6F35A17FD413B97CF9B108CF38544'),(2439,'C','2A7DB67EDB684928BE0C454EEE85359A'),(2440,'A','B305E418F4344DF681BC6C41E396E194'),(2441,'B','A8F3A84FB9D24DBA9F3CCD662FB83276'),(2442,'C','BD59E94A4A124D91B9DB53A687048736'),(2443,'D','BD59E94A4A124D91B9DB53A687048736'),(2444,'A','70C9693B2A83415CA15636E86F65F20E'),(2445,'B','70C9693B2A83415CA15636E86F65F20E'),(2446,'A','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(2447,'B','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(2448,'b','5A50AF5167B34895BA1BF4013B63E747'),(2449,'c','C66DB560147540D99E9D2C5B6F0BC376'),(2450,'C','82E0210594EC46A5848C1B362B536CE5'),(2451,'C','37586978D0294F0DAA4231CE74C06683'),(2452,'A','F5426AE44A5C4860A30479E132E46E18'),(2453,'D','F5426AE44A5C4860A30479E132E46E18'),(2454,'a','490DA59D0137492A861B57122BA8DA6F'),(2455,'C','1E7C2D0B63784F88931528EE277F602D'),(2456,'C','E06613DB0F054BBBB004FB1AAABFEEE8'),(2457,'C','A9C7552E2D7D4C45B9B77575AD986857'),(2458,'D','24963641377D4F89B083907A7F343AFF'),(2459,'C','615A69A631C24BE2AC9947A98C6F1C7E'),(2460,'B','7AE249ACF24446D5872457CE801B0355'),(2461,'B','58C23496BB8843B69A883398E0666360'),(2462,'C','58C23496BB8843B69A883398E0666360'),(2463,'D','58C23496BB8843B69A883398E0666360'),(2464,'D','B9D38B1692174AAE911A2663EBA55B3E'),(2465,'A','2808DF9DACC946E5B69D29FC50C9AE06'),(2466,'C','ED1902732A55443387CD472B2244A72E'),(2467,'c','58CCA5BD668A45A38AA01FC7E3B34650'),(2468,'a','5B51CC93D8374AEDAE510DF336B2986C'),(2469,'C','9DAB033452A947F69CB8F7B8C724EFBD'),(2470,'C','0162C6B4758F4301957E58DB6299C09E'),(2471,'D','0162C6B4758F4301957E58DB6299C09E'),(2472,'C','431AFF560A084AC3AADDAF4D839F3E47'),(2473,'C','30D3D89650C147FFAFCEDD4522C7EC8E'),(2474,'c','3B18185C2E9640F499788DCA1EF71D57'),(2475,'D','D12253BBE2B84571838E5E6A8EF6BC3E'),(2476,'B','73DE660E898B4424868C66C4E4688BDE'),(2477,'C','73DE660E898B4424868C66C4E4688BDE'),(2478,'D','73DE660E898B4424868C66C4E4688BDE'),(2479,'C','BA7D1A7853BC4A22ABE081E19E6371D2'),(2480,'B','F427B9E419114FACBA2D06B270A68270'),(2481,'D','F6BB47DE9483475BA440CF9DB19F8F2B'),(2482,'D','4BC7C14FAA004D69A8EF08AE37534177'),(2483,'B','4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(2484,'D','6479075EA97B4130B1003BF9DD4E1BDF'),(2485,'c','4C5C9360A6FB442E8AF629BA3BC4A3F6'),(2486,'B','7D253EA3C6E14AC2931F9D45D998156B'),(2487,'C','98C95E20A931459A92A89055D66DAA19'),(2488,'A','E89FC25CC66E49BAB7F8CC07F67E2B91'),(2489,'D','E89FC25CC66E49BAB7F8CC07F67E2B91'),(2490,'B','8244B24B35CF4DD9937649E6ED85B4C7'),(2491,'D','F6B9D863339A4C8E88EAD26D013B3A7D'),(2492,'A','0574B3F614CE42618BB2349DC59194C0'),(2493,'D','0574B3F614CE42618BB2349DC59194C0'),(2494,'D','B85CE9E7145F421CA73FB1A532AEA310'),(2495,'D','6F5F15FED99C43C8BF9ECFA906C5B75E'),(2496,'C','A1A4355FD0414AA0A12F505A830220C7'),(2497,'B','F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(2498,'C','525D29DF70614DDB84BDF6F37921D8FD'),(2499,'C','53BB7CA57C7243A5BE54B14738A2C030'),(2500,'D','53BB7CA57C7243A5BE54B14738A2C030'),(2501,'D','6937E3F700C64B789B08B27395A063A2'),(2502,'A','89A2D2E6BD1047B28CD40481E8FC98CB'),(2503,'D','89A2D2E6BD1047B28CD40481E8FC98CB'),(2504,'D','2B749F30FF0848ACBD1B1C0CA3FF6032'),(2505,'A','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(2506,'D','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(2507,'A','922059CBD4C241039447BC256F0E9FF8'),(2508,'C','FEB88DB5421546299B9FF7F0DE93BD95'),(2509,'C','F937F52ABA8B47F08B5E6B8A7F05D777'),(2510,'C','6148A72E4C69455782527585ED19543F'),(2511,'C','9FE4B37819814AF8AFECADE4680F335E'),(2512,'C','826CBDB7A0374BCB84CC553D72491909'),(2513,'B','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(2514,'C','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(2515,'D','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(2516,'D','BFFAC648C5384E74960708396A4835EE'),(2517,'c','AE18609B5906462A8668A9E28387B319'),(2518,'C','4723D32BA83547BEA3D79ED8247C854F'),(2519,'B','EEC6D19D21CB4732BFE0707749861851'),(2520,'C','3A8265F8E32E498C89567B74996CEBE1'),(2521,'C','B46844E54A2147DC894F3A2F23223534'),(2522,'b','A844893EC77E42EEBA0D6A315CF5A1A8'),(2523,'C','95061B5665CB4E1A8C0BB901AFA78146'),(2524,'C','79E40BEC55DB42219CF0E315810464D4'),(2525,'C','1A40D359F56745CDB555C14820545EFC'),(2526,'A','400DB2E46156492385A1317A5FCA549F'),(2527,'B','297A9757DDF349BFBB5C483640BB7696'),(2528,'D','297A9757DDF349BFBB5C483640BB7696'),(2529,'c','076CEFB0BC0F4A7481FFDECEA04F491D'),(2530,'A','81CBC08D8E5241BCA53AF8A7C46548BC'),(2531,'D','81CBC08D8E5241BCA53AF8A7C46548BC'),(2532,'A','44DF84B88590415EBF1268A084313CB7'),(2533,'D','44DF84B88590415EBF1268A084313CB7'),(2534,'A','1FD5ECCB2E04424F918D815922BE8B16'),(2535,'D','1FD5ECCB2E04424F918D815922BE8B16'),(2536,'a','3D623D9B0DFD44AEA19510A6D05EF7A1'),(2537,'D','AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(2538,'A','156E8B5E7C93431FB792453C2D6E9D58'),(2539,'B','156E8B5E7C93431FB792453C2D6E9D58'),(2540,'B','6DD3628513804EB78FB74DB67E45D1C5'),(2541,'D','60463487E503402F90BCB9AEDDC5D99F'),(2542,'B','9056957ADD494F589B146903CC394E98'),(2543,'c','F1C398E465994CE79819D3F1B1C5D711'),(2544,'B','F6A089E2962B4732914FD841EEA27C7B'),(2545,'D','BD2A0DB0A458476282B9FC3F1ED7DB8B'),(2546,'B','7664BCD2D103432D9C558937F7F5D191'),(2547,'A','DCB623C8A76E41DC816C8BAD2BB2CD59'),(2548,'B','DCB623C8A76E41DC816C8BAD2BB2CD59'),(2549,'C','7D36760CBC1440D69A36DF89FD013338'),(2550,'A','98D182F413794EBA91A9FD3F82687B21'),(2551,'D','98D182F413794EBA91A9FD3F82687B21'),(2552,'B','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(2553,'D','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(2554,'A','13FF147C440340DA91F44B48100BE441'),(2555,'c','9BE7926A8D324EECAA919855688CFB7E'),(2556,'A','986C403E14304F7681AFEC508B7D22ED'),(2557,'B','986C403E14304F7681AFEC508B7D22ED'),(2558,'D','D748D3A247074CB8A7A9CB435DCD7B8D'),(2559,'b','AB8D8CDCCF734AC4A27E9A32322A5496'),(2560,'C','D4F8F230BA3A4E2F8A56A91524D59A2B'),(2561,'D','D4F8F230BA3A4E2F8A56A91524D59A2B'),(2562,'b','5233EDE8FDF745DE834CD083CC59E1E3'),(2563,'A','3BC8A89BCE1746088FEABCD2902DD7B4'),(2564,'D','3BC8A89BCE1746088FEABCD2902DD7B4'),(2565,'c','CB4517418A7D4638A670C424823870F6'),(2566,'B','2492AFAA298E4BA4AD1F3075065F87CF'),(2567,'D','2492AFAA298E4BA4AD1F3075065F87CF'),(2568,'D','821254307B414DA98D8E60D2B0D0F1EF'),(2569,'C','FBEA8FADE35345F3AF5F5F0574DA5002'),(2570,'c','DDF25A56E5C14B95B5BF19E91728E051'),(2571,'D','4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(2572,'D','D81102D7D14241F8B371716B0FD4859A'),(2573,'A','794BCCC1DBEB45518A8D0363904E0C4B'),(2574,'B','C705F7FABB504D9BBAF826DA3D21E59C'),(2575,'C','C705F7FABB504D9BBAF826DA3D21E59C'),(2576,'D','C705F7FABB504D9BBAF826DA3D21E59C'),(2577,'C','41DE0D476F494701B834BBE012FAFD78'),(2578,'D','41742C6B9CF94E5781F45D0F061055C7'),(2579,'C','C575292F078447AD9941B6E6E42F0806'),(2580,'D','C575292F078447AD9941B6E6E42F0806'),(2581,'D','C99E82801F1E45F086DE9F96D80C993B'),(2582,'a','B4EF7856980E43748E7B9859F808E67B'),(2583,'c','E2AFBF3B95694022BEFE20EC4C7B747C'),(2584,'b','74260B92A33447CF9FDA8BA2E2A685BA'),(2585,'b','3CA7D367EB0F4607A7DC39B5DE62EFAA'),(2586,'D','37AD758E189C4B4CBDE223B1FB7D61AB'),(2587,'D','0752EF6EDDDE455CA6C49863140CB513'),(2588,'A','94D6EAFD46BE4F4A9118805424CEAE15'),(2589,'B','94D6EAFD46BE4F4A9118805424CEAE15'),(2590,'C','554F8738DEC2458DB09FB66BA804C373'),(2591,'B','55503C2075384150A0659E86B2B4D051'),(2592,'A','82E933EC76DB4F0CBD957CAE393EC4CB'),(2593,'B','82E933EC76DB4F0CBD957CAE393EC4CB'),(2594,'B','E8271D4DD51A47F194BBFFED7C32E7EF'),(2595,'c','FDEAEEFB35D24043BB41228EFDB76CC6'),(2596,'B','2D439F41FCCF4CFD91ED5028D3A3F38D'),(2597,'D','2D439F41FCCF4CFD91ED5028D3A3F38D'),(2598,'C','264C6D0D5C0E4EE99174003E5DFD1518'),(2599,'B','542393BDDF05480EB13913316E281D9E'),(2600,'B','B5A0BD7BB821475EA9EBACF96B2BDAEE'),(2601,'c','3A42BE66869346008A79E67FFD6DAFFA'),(2602,'D','A17978990F384C2A8561854648E23BA3'),(2603,'A','6B969D3F35E54FF7AE3FF917E75B43C3'),(2604,'D','6B969D3F35E54FF7AE3FF917E75B43C3'),(2605,'D','D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(2606,'C','574E332F6CE849C38EB921C4BD14EDE4'),(2607,'B','08CEF9E8D3794A60B0E2BA898B4D0372'),(2608,'C','F94B004065BE4789BE003DDBA9E5A7E1'),(2609,'B','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(2610,'C','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(2611,'D','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(2612,'B','77E24907FDE74C0EB6352655D741202E'),(2613,'D','77E24907FDE74C0EB6352655D741202E'),(2614,'C','32F637F4383F4B4D9F732FFDFEAE0241'),(2615,'A','2123A75041FD4CA497B8EBBCCE055F3C'),(2616,'B','2123A75041FD4CA497B8EBBCCE055F3C'),(2617,'A','689F9322E20C4CA9B8F9CFCD95B4CEED'),(2618,'D','689F9322E20C4CA9B8F9CFCD95B4CEED'),(2619,'c','F682AE42507E4309BECEFD302C366344'),(2620,'a','7A1F95C5B0624DF699C792459FFA8EA5'),(2621,'C','98F3972BF354428297A1CC43A6285CE5'),(2622,'D','98F3972BF354428297A1CC43A6285CE5'),(2623,'A','D21C46A2C9DA4A79ACEC1076F926122A'),(2624,'D','AE336B519BE94C9EA807AEBEB2FE34A2'),(2625,'B','52B2DA7003194018B637440BB6D5117C'),(2626,'C','52B2DA7003194018B637440BB6D5117C'),(2627,'D','52B2DA7003194018B637440BB6D5117C'),(2628,'A','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(2629,'D','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(2630,'C','BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(2631,'D','6C821B72A9E34DA3B8EC452A28BA8DD1'),(2632,'B','40021C153BB641B9A9DB258639614CA5'),(2633,'D','81DE7B424655498DBE033A8DE42BE687'),(2634,'A','23FA63D45DDF4D34B5385DFE651B0704'),(2635,'D','23FA63D45DDF4D34B5385DFE651B0704'),(2636,'B','DAFDF3AF99734E7D9C59FF42A763FA41'),(2637,'c','A564020B59D84B2691A011045C3F1E8F'),(2638,'D','65FE9164C46042FC9E5249702D2DB01B'),(2639,'A','950D0F13630F413E8AC7C1204B8BF3A7'),(2640,'D','950D0F13630F413E8AC7C1204B8BF3A7'),(2641,'C','FFDE9803781140E3AB49D331BAD62C68'),(2642,'A','7D356A076A924E8BB828CC797A02E772'),(2643,'D','7D356A076A924E8BB828CC797A02E772'),(2644,'C','26D1F529943A4563BD9F9E90072998BD'),(2645,'C','435FA646B2DC42C491410E5B3380E9B9'),(2646,'B','37D7BA4ED95445449703BDF24D75F468'),(2647,'D','37D7BA4ED95445449703BDF24D75F468'),(2648,'C','CC5D1A99998A4A6283EB1401734E0928'),(2649,'C','88832E08CCCE4FAF989D4AC973C5287C'),(2650,'C','3AEB1FFADDBD46E188F3DC98EBAE5E13'),(2651,'C','19747CBB70304669961950CFB1930E1A'),(2652,'C','C70C3434ABFC4EE19B5EC06B8F7C59FD'),(2653,'b','4AB398CB7DDA459A88B1E1F57E3EC6EE'),(2654,'A','D95DDC8A41EC44B284C6EBA47DA05436'),(2655,'D','D95DDC8A41EC44B284C6EBA47DA05436'),(2656,'A','F8FD938EC2B744149757D0BD8D4EA614'),(2657,'C','2BB702A78FD644FD8AEF5B13EA24AEB9'),(2658,'B','E53765164D154D50B8A656C344ED1622'),(2659,'D','C3BA7DD5E21647FC9CF238D991B6FAB5'),(2660,'D','887695A4D51D4573B31901AD8FD3DB14'),(2661,'c','6DC12F24337F4978B6BB3B6F29039D8D'),(2662,'c','C31F06002D4C4FBC80175DEEDF52CEF2'),(2663,'C','430FE9095C004F3C9109EBB676B1279B'),(2664,'c','43446A3C28F645D4899221ADE47FEA60'),(2665,'C','BED615F09A814F769EDD8CD78CCD3DDD'),(2666,'C','7D8F6FAB08C247069D94717924151EEB'),(2667,'D','CF41A0C354414167906FCDDB9290B8F4'),(2668,'C','B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(2669,'a','8354BA5ED5BC4B3BADC817F11CD9F351'),(2670,'B','7D2CB2D41DE946918514CAFDAC4C874A'),(2671,'B','0D7CD7C532FA4B2692597B598CC88D28'),(2672,'B','47FA650F96204794AD1916AAA6191136'),(2673,'A','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(2674,'D','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(2675,'D','2BB4C85CF8844AC3978033DBFBA7E9E0'),(2676,'D','13F6A99EF75F45A4827E6C2A75E8323A'),(2677,'C','0A291639601848D282938F42AB2D373F'),(2678,'C','7936CE192D814BD68328C4B805823371'),(2679,'B','19732F19153544BC99D4DF571B059685'),(2680,'A','BF2CB74919AD4E1A950C0FFAE4423746'),(2681,'B','BF2CB74919AD4E1A950C0FFAE4423746'),(2682,'D','8C168A6DCDAA441F9997C7B0429067C5'),(2683,'A','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(2684,'D','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(2685,'B','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(2686,'C','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(2687,'D','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(2688,'C','204884AD6616437CAA06B0071FDFEDBB'),(2689,'D','204884AD6616437CAA06B0071FDFEDBB'),(2690,'B','32E342CE591C48019499D242A3FA141B'),(2691,'a','BE7FA24BD9BD441C9947856D2F4B801E'),(2692,'B','0DD5F77D69F24CACAD16D51259D3F97E'),(2693,'c','0A4B0A882BC2498CB5A8C5845736C3E3'),(2694,'B','A65E55C923E845BC98A71E9BE8EBEA27'),(2695,'D','96FF1B8100254758AAB61E730FD504F6'),(2696,'D','0D05BD35FE5545D3BC9877D30497B5B4'),(2697,'B','907C812FA29743DE9258DD4AA75B6891'),(2698,'B','041C2D9C292C4FECAD356C628C2B8855'),(2699,'D','DA579D4B61004E4A88071217B0FB4681'),(2700,'D','FE19B8FDD9724BF780886C6EDF2C7240'),(2701,'D','D293EF3344AD4743BE667BB79C071145'),(2702,'D','F79726831AE443149EB651B6F4F78D16'),(2703,'C','8D9A63138EA44A47B84637D046B6BA91'),(2704,'D','DCC0D546885F4B07A136BFD5CF9F57B3'),(2705,'B','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(2706,'D','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(2707,'D','0CFB7FD544D84AB1A433142DFA272701'),(2708,'c','E83CD3521D0540348CA629BAC36804D7'),(2709,'c','097B62E438D94105B8FCE64516C33069'),(2710,'A','EF5406DD1DD744939057A196EC0FCB1F'),(2711,'D','EF5406DD1DD744939057A196EC0FCB1F'),(2712,'C','4F77CD575E454E66B99EE8C15A780674'),(2713,'A','3E55703F094C4BFAB71A559D13724FFE'),(2714,'D','3E55703F094C4BFAB71A559D13724FFE'),(2715,'A','9F0524B08DF144BC8E21C006E2771259'),(2716,'B','9F0524B08DF144BC8E21C006E2771259'),(2717,'C','FB073C05A26649329FC7174BE0CA8E2E'),(2718,'D','797EA301F2AF4F37975671368F236DDA'),(2719,'B','884B4A3D383E4306938818C273AF6123'),(2720,'C','884B4A3D383E4306938818C273AF6123'),(2721,'D','884B4A3D383E4306938818C273AF6123'),(2722,'C','5569AEE989CF42609F70363B716E0C64'),(2723,'C','AEBA258A696F471EB84EBC30553BED7B'),(2724,'C','6B94A3FA4D5743A7B7746B96DB3223E4'),(2725,'C','B66C451B0C584D2B9DBAC960B7234C0C'),(2726,'b','F374A49AFCEE4993A9756AAE19F91B17'),(2727,'A','C7B7826850B846118206DD1572B168E5'),(2728,'D','C7B7826850B846118206DD1572B168E5'),(2729,'a','58088E2E412B4F9C8A86A56843C9A9F7'),(2730,'D','AE62CF5F9D57434CB529E8B7C188FBB9'),(2731,'B','09728B5452DB479691CCCDA46B7C13E7'),(2732,'C','19D4308477F6464E90C6D2E8AA5CBE2E'),(2733,'D','19D4308477F6464E90C6D2E8AA5CBE2E'),(2734,'B','1433B3C90E23486DA1986A75B5ED0685'),(2735,'B','D135E998EF8D43D2AE2FD74BDA287FFA'),(2736,'A','38B1663D58F9473496D5D20D5B61441D'),(2737,'D','38B1663D58F9473496D5D20D5B61441D'),(2738,'B','4B5F335108C2491C864249A36F08A567'),(2739,'C','4B5F335108C2491C864249A36F08A567'),(2740,'D','4B5F335108C2491C864249A36F08A567'),(2741,'C','33E7132926E344638BD380C1AFF7C8FA'),(2742,'C','8805EE75C60148CF978F5D33F149970B'),(2743,'c','75C06802E3FC4EDAB9DB7B421402FB4C'),(2744,'C','31F7E98361E84D189A1A91270E6270D2'),(2745,'b','B3687DBC3A124A1E93FFE261520FBE3B'),(2746,'A','8674C4EAED544AA8B644D6B5988BE841'),(2747,'D','8674C4EAED544AA8B644D6B5988BE841'),(2748,'A','F326B4B5824643C3A4F74EFF485A9198'),(2749,'A','557A9CA3EE784D4189D909524A3ED3DD'),(2750,'D','AAD8E50F58E8414AAC5F8DFC37AC1E78'),(2751,'C','B99EB7C3639A431B9A0B97C75DDD3F8E'),(2752,'C','BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(2753,'D','3D3BDB177B4840FAB0CC1D41C6DB074A'),(2754,'C','3CD696406D1A4919B3A9A72B428F13B2'),(2755,'D','8325DCDE005942F4B3968D2C90A6821E'),(2756,'c','6D24A5C9A32A40848E83F2320AA28A1D'),(2757,'A','DCE4EA8707424C63ACB7C09B3590B279'),(2758,'D','DCE4EA8707424C63ACB7C09B3590B279'),(2759,'D','BADA7322AF1748B694766B7D43309A92'),(2760,'c','EC3E7DB0643E459188D39940E6A234E3'),(2761,'C','95E14927E2334FDFBFCC880871CFBE4C'),(2762,'D','95E14927E2334FDFBFCC880871CFBE4C'),(2763,'B','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(2764,'D','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(2765,'C','78F9B177E2EA45389A83958891DAEA60'),(2766,'a','6DF46658B6494DF59A3D0C9B4CB4D58F'),(2767,'c','3DF17A806C6F41A9A08424F8620C9160'),(2768,'c','7DE0DD0894B54C11B0C15E7481A1BBB4'),(2769,'b','0D37714BF0344AE6B78C817AB34A0560'),(2770,'A','100C13CF364441F79259E88CA9EB59FB'),(2771,'B','3689E90FE66040E1B6002D67BA4CC19F'),(2772,'D','51740FDB8AB3453194FA79410FD417BD'),(2773,'C','897F8E63F86B4F20BE4025B254FE4EB2'),(2774,'C','7AF53BC6C137409BA5BFCBC482135683'),(2775,'C','69F5B79B55AD41638CB033E7BE0BAF4F'),(2776,'B','CFD648F1A75E4FB499314B6C254AB00D'),(2777,'C','CFD648F1A75E4FB499314B6C254AB00D'),(2778,'D','CFD648F1A75E4FB499314B6C254AB00D'),(2779,'B','0B75C0F0F2C9471BA54A29B30AA19987'),(2780,'C','0D990B41618C4E02907669182389572F'),(2781,'C','36151239BBC64E30ADE1091FA360E3B4'),(2782,'B','3EC715768B6E459C87D684C3D10B9192'),(2783,'D','76E50FF39C054726B3513B2900B893C2'),(2784,'C','12367529D8EC4FBDAEC3F52C47BE3FF9'),(2785,'c','E7DCFB11C80C4BDC90E0AB3B77CDC761'),(2786,'C','6CF08D3C564545C596C5CF7DD8C808F6'),(2787,'D','F614748966A24A4ABE09982B17613B12'),(2788,'A','CCE040334B144163A85C501736D10707'),(2789,'B','CCE040334B144163A85C501736D10707'),(2790,'A','51A97DC8CFC04E729781BA052D62DA62'),(2791,'D','51A97DC8CFC04E729781BA052D62DA62'),(2792,'C','849C1AA4560E460FBB7534B24D6DE56E'),(2793,'D','A31D67C5C5A04E209505E4839BDDD44B'),(2794,'c','1507F6D2A79D4E118DFB24858D224EFC'),(2795,'B','71DB815A83274531B7CEE78097091E79'),(2796,'A','343A11A1AC9B41009AB07A05A321F264'),(2797,'D','343A11A1AC9B41009AB07A05A321F264'),(2798,'C','6B22D9B6238B447896FD44AC7E9DB385'),(2799,'A','456FB5AA7C1849EABB961A1F7D79C518'),(2800,'D','456FB5AA7C1849EABB961A1F7D79C518'),(2801,'B','05A44F76F5B84BAEACBC73BFC01F1451'),(2802,'B','C1318305A2E441DB822CD1A097F58874'),(2803,'D','C1318305A2E441DB822CD1A097F58874'),(2804,'B','9C8A1DAD051849C2816DF4B739FA6942'),(2805,'D','056BD98C07154426A296D11E86A01CC4'),(2806,'D','A8417123407C434FBC4B4E8B4CA0B609'),(2807,'D','826F7B4B344F4FA2A85751D96C49DB6C'),(2808,'C','782795B974B2436284C2EC9917A3ACFE'),(2809,'c','40794D1645CD4A4582B24ADB351537B3'),(2810,'D','A24DFD9699CD4BC39C1D45A5E727B9AF'),(2811,'A','7A6E0F0EA26D4262B238329C00AC5511'),(2812,'b','58A2547D3B994BDC8FD48111791C9572'),(2813,'B','4A7D76E2E30E47379C991C09CA22489F'),(2814,'A','36058E13DB6B45858DF2D464CFDDDDC5'),(2815,'D','36058E13DB6B45858DF2D464CFDDDDC5'),(2816,'b','C9FF3B79499E4753BB612FCC437A817E'),(2817,'D','D54CBFF879384DD09D786211A8D5003B'),(2818,'C','31B0BA226D13454D90050D4961110F9A'),(2819,'C','3988954DE6094D0A99A369FEAC5DA692'),(2820,'D','3988954DE6094D0A99A369FEAC5DA692'),(2821,'C','2A0F921BBB90462C8F62E70DAAC5F00E'),(2822,'D','F7401A00985740DFA5208DDACA2BED4A'),(2823,'D','DBF269C2D90743078334F7AC0AF668D3'),(2824,'C','9FC31EA4A8E146E6A3546957CD13E96C'),(2825,'c','F358507CC32C4B0DA17C6F6F02D32D9D'),(2826,'A','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(2827,'D','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(2828,'A','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(2829,'D','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(2830,'D','F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(2831,'B','B2A14C45157C4792B7474B18A8B3025F'),(2832,'D','B2A14C45157C4792B7474B18A8B3025F'),(2833,'C','DB89A81F42B645C7B7755F3E15300D23'),(2834,'D','DB89A81F42B645C7B7755F3E15300D23'),(2835,'C','01AB7988D33E48F4BA19741AB0E71572'),(2836,'C','B058660D59B548CFA3626F66B41544C3'),(2837,'C','E72611F9FC56437C820D9C4762F6B98A'),(2838,'D','919334B660AC4E09AEA4461628F3135B'),(2839,'A','16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(2840,'a','2400C908F76C4A38B55C77D6642160CD'),(2841,'C','4C152C4553DA45349B9C2C73FB085A59'),(2842,'D','4C152C4553DA45349B9C2C73FB085A59'),(2843,'D','C56F058D5A0E4B4B80476A42B8819613'),(2844,'a','BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(2845,'C','57F223C050484D9580B283D91EE42A59'),(2846,'B','6D5ED0C2A05841489C4D33C80C041A9D'),(2847,'D','9CB357F050764DB28B6FBE740AB5CD98'),(2848,'A','337BD57A3C814928818FAA8EA5332F2C'),(2849,'c','48A3077A348942E680282A6D5FF62CD0'),(2850,'A','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(2851,'D','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(2852,'C','08B2626E55054529AD02C7E5F1573F56'),(2853,'B','56CC5B59FFE54E759CE1131B9BD1C6F9'),(2854,'C','69AD3CDE36DF45D59D3A27835D7815EA'),(2855,'B','FC120AE84877414AB4DEBDFC3A68C9D8'),(2856,'c','38B1680643D1402A8C3209D857BD75B5'),(2857,'A','A4570309855B4DDE9D20BFD8CCA90232'),(2858,'B','A4570309855B4DDE9D20BFD8CCA90232'),(2859,'c','00BFB07A88334474A11C494379F9D47A'),(2860,'D','2E8B180D59174612B80CD3B976FE3780'),(2861,'C','BB1C3CA8285947B7985F7943A607BCAF'),(2862,'C','D88B4115C8E042829068C9F9925DB871'),(2863,'C','69CFD1EEE73C4F99B567D022FBB2D9DF'),(2864,'B','C9FFCD49E7B5491190A4BF252BE91FFE'),(2865,'A','E3E5206AE35348DD9A32648BF70F78B2'),(2866,'D','E3E5206AE35348DD9A32648BF70F78B2'),(2867,'a','B403973A869848F983231EE84C8BADC4'),(2868,'A','380A732D59B54AF59C6DA8916B7CFF12'),(2869,'B','380A732D59B54AF59C6DA8916B7CFF12'),(2870,'b','2D96E3D9FF08496BBF19491D345909F0'),(2871,'D','CC57E02B65F5457CAC7E99A9EA5FDE96'),(2872,'A','473F363F30CB411DA28F2B9646502AE3'),(2873,'D','473F363F30CB411DA28F2B9646502AE3'),(2874,'D','002A1E80FFBF4BCAB32159B0C0C2347F'),(2875,'B','30491B50AF2C4181A623CD69BF22B5E8'),(2876,'c','EA1422BBF4B04045AFF8AAEFB5253DE4'),(2877,'B','0D72DF82DA5E4E27AFC1C4C12001C246'),(2878,'D','BE764AB8E1494296B05858C2E013C09D'),(2879,'b','1A020FCD7B0B4E13A23A493FADA22FA2'),(2880,'C','DABA85128E00448FA65E10FFE7AD7CEC'),(2881,'C','869EE067DCA64D82854C1E112F89E100'),(2882,'C','11212DBDD1A44058934324708EA4D36E'),(2883,'c','363F2350E6EF415DAF2ADC888F91FC36'),(2884,'C','F2D0D99EEF2A4E5193051947648AB39A'),(2885,'c','611D4AEC80094769AEAE9C4BC95D8881'),(2886,'C','5AB184E5D8B847BAB42E4E157895D4D8'),(2887,'D','1EC1500ED4074D7B8C30FFBBBAA6C04F'),(2888,'C','F2E5C52372504E2B9CDF61A9A63A209C'),(2889,'D','F2E5C52372504E2B9CDF61A9A63A209C'),(2890,'C','51F51B0BDA244ECF92D31C95F19EAA5E'),(2891,'D','A1017607321A4A5EB2BE8680453F80D5'),(2892,'c','07053EEADBE04BEBB398F2D483A70F99'),(2893,'A','68CCF557034442B281878CF9E6BFD4DE'),(2894,'D','68CCF557034442B281878CF9E6BFD4DE'),(2895,'C','5A933E2EEBBC4A229559620E98E90B90'),(2896,'A','B12C8EC45F3545FA82803E97CC85D14D'),(2897,'D','B12C8EC45F3545FA82803E97CC85D14D'),(2898,'B','532107F14CC54242AB262B56B8296256'),(2899,'D','761BD4B1E7414414AD58669E18B4DCF2'),(2900,'D','3E02A49E8BEF4AF697DC269A35EFCCCF'),(2901,'B','260768D9F1034266916A21BABAD2523E'),(2902,'A','E20410F206D74944A4E8666E35938B8C'),(2903,'D','E20410F206D74944A4E8666E35938B8C'),(2904,'C','8603F7C70EE14A2FABEDA2B3B16B6690'),(2905,'B','0083C71347CC4797AB96263E4185F889'),(2906,'C','CE32D8F81A3A4799891423AEE1340405'),(2907,'D','313E2F7B9922463B88BF759DEEBF2A7A'),(2908,'C','1624520090D94AD9B15CB097BBAC75BA'),(2909,'A','BDEF71151BB541A89958AD77AD4FADAC'),(2910,'D','BDEF71151BB541A89958AD77AD4FADAC'),(2911,'C','2B112C8E4CCB408084F3C8693D04FDA3'),(2912,'C','E7A1E270F6524A3A972760128DB50840'),(2913,'D','E7A1E270F6524A3A972760128DB50840'),(2914,'C','07EB2BB685EC44C8884849B912F7CB7A'),(2915,'c','321F2A7F05F24E6597D4FED785B45242'),(2916,'c','D097C02401F1444CBF529D9790BE4D77'),(2917,'a','D3BD2E6097594BF6897FA4773996D18D'),(2918,'D','38FA66E9834D4302AB1F526F0CB6C64C'),(2919,'D','8719133627C3459B8DA46936379D3E79'),(2920,'C','6689209CD93F413C93678412C34B4E70'),(2921,'A','89E9C70714B04A18B1C300B2FDB5D7CF'),(2922,'A','EADC8D24941E4F16AB713B5517F13B32'),(2923,'C','C47CB190F06C47EA81265325F6C27490'),(2924,'A','C7D9906B8C6C497DAE70F6674253F880'),(2925,'D','C7D9906B8C6C497DAE70F6674253F880'),(2926,'C','721E4B443AB245538B65D16E7081D393'),(2927,'B','55C7DEE9F0DC491797A5C5658FB1D231'),(2928,'A','6105CCBD5536476792F6E35FA318F00D'),(2929,'B','6105CCBD5536476792F6E35FA318F00D'),(2930,'D','5B9D54CCE7CE48C1B0905B35DACD2F64'),(2931,'B','5F5B20CD56B849D980022DF0E5B9F388'),(2932,'D','B4CA7B491A94493094E3C9ADCF6E6C7D'),(2933,'D','9BD1404A37234ECA826E696291EEA8C7'),(2934,'D','4EDF44D4038B401E893CFFFB525DAEF6'),(2935,'a','AEBA9B7D3D4D41778A14BFA9821E7FDD'),(2936,'c','C0C7F2C266A9444C94EFE8C101869FAA'),(2937,'b','55635C9C01044E2E9F98AA5188D7A798'),(2938,'C','FCD456FE19D74DCF870577A64775F01A'),(2939,'B','385356F3A7B34BE99CD61E859A40CCFB'),(2940,'C','A3AA8B2BAA9B4ABCAD8016754B27805F'),(2941,'D','34FD832E1C674363BC6A484873D625FB'),(2942,'c','BAF617ABC55C451B848D8BA7831392DA'),(2943,'B','4AAC582906B74BA7B24E8912C307E761'),(2944,'D','E5119048041048BA8FD71047961E2C13'),(2945,'D','83C621712001443098043C47D3CA1B93'),(2946,'D','49B8A0C78E3D46119C60500AE935AA9A'),(2947,'B','09CF76033C224B3B81F30BC17455DA12'),(2948,'A','042472B1E50D421F86E921B1B7EE1F82'),(2949,'B','042472B1E50D421F86E921B1B7EE1F82'),(2950,'C','6D71DC33FC6E476EA47186F7CA7FC016'),(2951,'D','6D71DC33FC6E476EA47186F7CA7FC016'),(2952,'C','C38A8CF0A2084E658C518CF1617880DB'),(2953,'D','586E65D652464C2B94F87A6CA6FAF00C'),(2954,'b','7042FE042FA54970A3ED2B3A236558A1'),(2955,'A','A5A168F938A64E85920ECD9A2F9A6B69'),(2956,'D','A5A168F938A64E85920ECD9A2F9A6B69'),(2957,'c','F5DD3F49C76847B09CBEA42BD9323B3B'),(2958,'a','2E6ACD1A03D1404197ECD3972F7E6B88'),(2959,'A','A940442C9A6747A1A96FCDBE13F4AE5F'),(2960,'D','A940442C9A6747A1A96FCDBE13F4AE5F'),(2961,'B','9F204C2DD5224C92B44B14741EDD5988'),(2962,'B','E0B30D2F47E842BFB1134BE11021AA61'),(2963,'D','E0B30D2F47E842BFB1134BE11021AA61'),(2964,'C','D01E062FAC054FCFB0AD66A7B61C2B40'),(2965,'A','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(2966,'D','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(2967,'B','F2E0C6ED9B474867AFA94CCA2F095F2E'),(2968,'C','F2E0C6ED9B474867AFA94CCA2F095F2E'),(2969,'D','F2E0C6ED9B474867AFA94CCA2F095F2E'),(2970,'B','FCA04C0045614350B3402FDA90B58777'),(2971,'C','FCA04C0045614350B3402FDA90B58777'),(2972,'D','FCA04C0045614350B3402FDA90B58777'),(2973,'C','6FF06E61B42944F8994D8AA47CF71681'),(2974,'B','76D31335BB6743518A442A1EDB033B4D'),(2975,'C','76D31335BB6743518A442A1EDB033B4D'),(2976,'D','76D31335BB6743518A442A1EDB033B4D'),(2977,'B','FCEA2218EAAF4B96B857416F87C7E646'),(2978,'D','FCEA2218EAAF4B96B857416F87C7E646'),(2979,'D','00AACD826F4A4DC9A8DAEA3F69A9DC78'),(2980,'C','25D1744CEA2845109266340BB9E5B7F0'),(2981,'D','E5212F7F4EA94EA3AD2695433FF75151'),(2982,'A','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(2983,'D','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(2984,'C','833F382A883F48CAAB42D61FAD7A9C3C'),(2985,'C','C15207E7452B406A8346FC84FA8B600A'),(2986,'C','10C92B8730C848249813116A972D3351'),(2987,'B','6FEA99C5CFF04D7FBF84C69FC85536B4'),(2988,'C','6FEA99C5CFF04D7FBF84C69FC85536B4'),(2989,'D','6FEA99C5CFF04D7FBF84C69FC85536B4'),(2990,'B','5418643DE3974F9B92BFF27FEC134C0D'),(2991,'D','5418643DE3974F9B92BFF27FEC134C0D'),(2992,'C','68B15C3DC2D843A2BEFD678C72D5700D'),(2993,'D','68B15C3DC2D843A2BEFD678C72D5700D'),(2994,'B','836E0657B0EF4D3FA87B7246E3E5D1B8'),(2995,'C','587FB668F67C426AAF46742C2AEE85BC'),(2996,'D','587FB668F67C426AAF46742C2AEE85BC'),(2997,'D','E11D352C3A5B41FEB3FFD4993593F09C'),(2998,'D','31EA8C2AA2AD4E77ABF8031A027DA4AC'),(2999,'b','BFF7FF82F64342399FF27D06BB8430A1'),(3000,'A','3F1BA41B9D884B8281C390CC84CC4099'),(3001,'B','099AEDF7DA4F442AA7C83489588EF4CA'),(3002,'C','E6A8E448B14A4B51B68A5D6DB552D2CB'),(3003,'C','40FAF9EE1CA34B4897823CC919830A13'),(3004,'C','CF3A4A97B1F049F28301E2BF6D77FC69'),(3005,'D','D0AECE6F725141C8B87EF739D8FFA824'),(3006,'a','81C05B163FD341698EE3315AE8DAEBEA'),(3007,'A','1580B09A53B2421190FD1956925C0EE3'),(3008,'B','1580B09A53B2421190FD1956925C0EE3'),(3009,'A','DD89C18AFABA42FA92E65DAFF569EDB1'),(3010,'D','DD89C18AFABA42FA92E65DAFF569EDB1'),(3011,'c','06589A904E3944C19374F445C3ED7C5C'),(3012,'C','0D99252C648A4578A8089E982BCD8331'),(3013,'A','7B76658AA67546F797523B33605421F5'),(3014,'D','7B76658AA67546F797523B33605421F5'),(3015,'A','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(3016,'B','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(3017,'C','EC30AFFCAF674872AAA22936E6C1ABD0'),(3018,'b','D6B319073120466AAD0FD53565B7573B'),(3019,'B','A06DC45F726040989335C1E67A96EDB9'),(3020,'A','CAE89907A4C84839A8D14281D2EA93D7'),(3021,'D','CAE89907A4C84839A8D14281D2EA93D7'),(3022,'D','EE500293852D44BB96FA44B02C49240E'),(3023,'B','B2DB8EEE147F4094A43B46C6FAEC13C9'),(3024,'B','E8513B120F344F9D8F71ABDC795D8089'),(3025,'B','890DF060C28D479EA02CAECB82B57EEF'),(3026,'D','C7D85EC8A9614BBFB89DED4988C6BB59'),(3027,'C','FE8C619C1F57498CA1715384B824FFC6'),(3028,'c','AC726D85E28A4E6C90451508591C83B4'),(3029,'B','CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(3030,'C','CA9371AC226A468CB60FA0F8872ED2A1'),(3031,'D','18A4504BFA7E4804867563234764F3C4'),(3032,'B','6BCB57D0A7F84F27B3C4E6A852803175'),(3033,'D','6BCB57D0A7F84F27B3C4E6A852803175'),(3034,'A','9806288D7CF14AD4888AE7A6B4C1D4FC'),(3035,'D','9806288D7CF14AD4888AE7A6B4C1D4FC'),(3036,'B','3AFD96EFC3A64996BB8244B58989D188'),(3037,'C','3AFD96EFC3A64996BB8244B58989D188'),(3038,'D','3AFD96EFC3A64996BB8244B58989D188'),(3039,'a','4CE57B2F42C147028A4287A6226AFC2A'),(3040,'A','18888E5C88D145729DE1207DAA84C86A'),(3041,'B','18888E5C88D145729DE1207DAA84C86A'),(3042,'A','636BFC576A2B44E592BBE8FA2AF21612'),(3043,'D','636BFC576A2B44E592BBE8FA2AF21612'),(3044,'B','8AA8059A98CF491C9243AB13A6FDDECF'),(3045,'C','8AA8059A98CF491C9243AB13A6FDDECF'),(3046,'D','8AA8059A98CF491C9243AB13A6FDDECF'),(3047,'B','828F2870EA394075B9477E3D69B4320B'),(3048,'D','828F2870EA394075B9477E3D69B4320B'),(3049,'C','2E187FD1394E41C9BDD608AC338A6A31'),(3050,'C','F72E94DC22BA4393861DA5BB949FA9E5'),(3051,'C','B6A9C8BBA71E4B27B0882FE8436C979A'),(3052,'D','8AC157A0E68744408824363480E9CCA6'),(3053,'D','A3C4A7BACCCD4E86935D4F075C87D4E3'),(3054,'A','0B7152F46F78437C8DADBECCACA0EEFF'),(3055,'A','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(3056,'D','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(3057,'D','1DDC15491A174F9B8B40E3650FE6168B'),(3058,'c','73CB3C7F6D144A35B2958AB3E7547493'),(3059,'b','E7C0DBDBDC144904B18929C1CB357027'),(3060,'A','445DBA57689B4DFC90E19EC07DD1A756'),(3061,'D','445DBA57689B4DFC90E19EC07DD1A756'),(3062,'C','4210953AF462433EA4A369E1864D8090'),(3063,'D','D93A487FA268463385013B6FD70F52CE'),(3064,'B','9F5E5121F7964F9093E1026393E6F20B'),(3065,'C','27D67D5731AE4CF7BBEFE1DB9E160C42'),(3066,'c','BBC7FA02A7664CDA8181CD4F01EE0D1A'),(3067,'B','86B8DB0A20344012B50ABEEAF739E4AA'),(3068,'D','FF4D8CA3ABE34BC1AFA822D4B4504E42'),(3069,'a','E97DBD1F42F549298DD8042133E42162'),(3070,'c','93A8F00159984F7C94BF3E058511CBF6'),(3071,'D','8DC355F938A24150B2EC698F89DD7577'),(3072,'D','E51DCBBBE50146F1A844BBDAAA9E5E7B'),(3073,'c','0187DDB1A64541CB91AAD43C8C4D893B'),(3074,'A','C79815780E524013B0DA285ABD8BE6D5'),(3075,'B','E1804B69F6654A8EB5C93BAB44496924'),(3076,'C','59315ACF311C46678C74334C65F8AE56'),(3077,'c','9363EE7CC3CA465192C0F0C5ADE4FAE8'),(3078,'C','AA628A9D894C40F4985AA0859AF2F5C6'),(3079,'D','AA628A9D894C40F4985AA0859AF2F5C6'),(3080,'B','1D6B31E30FC342C4A6282642CD20E420'),(3081,'D','B593B60625BA4BBF95E7887D05369FC3'),(3082,'D','16C2365819974E789AA08B8578C8AF51'),(3083,'C','D84DD65E84964D0AB771F2C782C4812C'),(3084,'C','827C478ED184485AA4F64EC554B8A06A'),(3085,'c','A51915FFDEFC44869C3F1D0A322F6922'),(3086,'B','2496A0B50F454B258AA43B6088B89E31'),(3087,'C','2496A0B50F454B258AA43B6088B89E31'),(3088,'D','2496A0B50F454B258AA43B6088B89E31'),(3089,'D','DF01EAC0D0B1413386200EEF87093AC3'),(3090,'A','E08ECA9A1B044C26AFEB25B0360CDD91'),(3091,'D','E08ECA9A1B044C26AFEB25B0360CDD91'),(3092,'C','0CD67EE2697F4C3291A13DD4646D310F'),(3093,'a','11127C77AACE419BA648D1CD4453FA92'),(3094,'C','641D0B5317F44561A113792B251C8D6E'),(3095,'D','4B7689B59C4345F5BF12BE380BCE66E5'),(3096,'B','FC1B330CAEF446DD9391A0E74169E88A'),(3097,'A','94C8949770CA43F19833AD4EA4B2265D'),(3098,'D','94C8949770CA43F19833AD4EA4B2265D'),(3099,'A','DD22A69007974128B49075A981795973'),(3100,'D','DD22A69007974128B49075A981795973'),(3101,'C','D4989B486CB34251B822DEB9BCBE98B5'),(3102,'B','FD3E2D92485A4E5A816E1DF8AC408122'),(3103,'D','8432B9942E2C440ABA0AD08DCAE82645'),(3104,'A','C111F2F9370B41F4A841763D39FCFAA8'),(3105,'B','C111F2F9370B41F4A841763D39FCFAA8'),(3106,'D','438A253AECEB412DAC47BE5479F43ADE'),(3107,'C','E5CFBFC734EB47959ECA217B258B7BAF'),(3108,'B','3A4D516356214E38A30A0DC4C2302566'),(3109,'B','5100A97BD3894E5E99F081EFBC0B6F55'),(3110,'b','A6A7044A7F7A462FBD0C561B58864BEC'),(3111,'A','2BC68E5DEA9142B0A111E6D926D05FB3'),(3112,'B','2BC68E5DEA9142B0A111E6D926D05FB3'),(3113,'C','23C5F1ED218C45FD89BA63EEE5847E70'),(3114,'D','23C5F1ED218C45FD89BA63EEE5847E70'),(3115,'D','B2938B9D22E8498EA3018846F3A9D081'),(3116,'C','D9A92C688BD14147AFFF9576828956ED'),(3117,'C','780C6CA9224B441CB4E4F2FD59AEC03C'),(3118,'C','3B1438E8B5504EA4ACA30F2208D35EB7'),(3119,'C','A5697D6E64AA4A628FFAFE6FF3EC8215'),(3120,'B','8CC2A798185B421BB3F49B3069CD9506'),(3121,'D','4FA8AA54627E4DDE9737E07F9C12E37A'),(3122,'A','103FCE24367F4B23BF2CD87FBF800B85'),(3123,'D','103FCE24367F4B23BF2CD87FBF800B85'),(3124,'D','2F4E3D268EB64FEBBC712BC578172F98'),(3125,'D','4123AA4AE4114D5EA7775911B4E0DDDD'),(3126,'B','C2D91934ACB644B0BFC86D36559128D7'),(3127,'C','C2D91934ACB644B0BFC86D36559128D7'),(3128,'D','C2D91934ACB644B0BFC86D36559128D7'),(3129,'C','6759A728F5E44C70BFA99D12D3F0AC42'),(3130,'D','E4936DC1453542B4A1F8FC037110B48A'),(3131,'A','FA5D46B793274E24A6AF3907C67607DA'),(3132,'B','FA5D46B793274E24A6AF3907C67607DA'),(3133,'a','7C480FEDACD94F4583BADDEE72673709'),(3134,'A','A73EAC86CDEA4CA3B1978419292F521F'),(3135,'D','A73EAC86CDEA4CA3B1978419292F521F'),(3136,'a','7BB4084D5F8A48CA8796677F2E26020D'),(3137,'D','30C86F6F4CDD485F893EF185C0EA288E'),(3138,'c','8CF52CFA53484BE9BC1028D23111189A'),(3139,'A','3249367217DF42C5AE1E5E0D314EF3EA'),(3140,'A','1FDD83077F8B4768920979D1E5BA6838'),(3141,'D','1FDD83077F8B4768920979D1E5BA6838'),(3142,'D','7C2EF35E3A434842A84696967CE3D00D'),(3143,'C','93C17CB3F8E144F1973780D64C13195B'),(3144,'D','7D3B3D3ADBEC4D53BAACC875C32C4819'),(3145,'A','9EBB8CFA0722497CA4B7393EB741569B'),(3146,'D','669189E0EE974AD99EC186D906A60EDE'),(3147,'C','8F6A1449C82A4C41B033BC59B2687735'),(3148,'C','3387171FEF3E46B1BC2296D1785AE6FF'),(3149,'B','DF82C86C753143D99DD58C43809362A2'),(3150,'b','549DB8591D884A16A54A1F9F35580428'),(3151,'c','18B6974807F4499682F53E051B05C4A1'),(3152,'b','7C2F1161CC50473ABD2A332AB51293E3'),(3153,'C','9D6F98CD105B4762A513CE99EB04E0DC'),(3154,'C','BDEE8D43E8D14381ADA8AE3FCC08EF13'),(3155,'C','27314DD2BFDA4EA7A01DF90CE1A9A026'),(3156,'C','F25C6A663FB14D9384D1DFF79046F13B'),(3157,'C','FDA049824048422AA1E88A55B7E14D5C'),(3158,'D','FDA049824048422AA1E88A55B7E14D5C'),(3159,'c','5B981D45D2684B32914A4574AFF765C0'),(3160,'B','9540F6F4BE2141A684F641E7C822C053'),(3161,'A','11B64CC57A4B4F958FC31DE2C6B49F24'),(3162,'c','315FD2E91BD8414095C4E3FF3CA9A440'),(3163,'c','98DB711D6D634A02823AB05B5335D7C8'),(3164,'A','0ACDA1E3288247628E61BCAC197D1E1C'),(3165,'D','0ACDA1E3288247628E61BCAC197D1E1C'),(3166,'c','02B8BC857FA84D9090EFB477A8848417'),(3167,'B','2321A0295E38405BBE668FA0A111AF55'),(3168,'D','2321A0295E38405BBE668FA0A111AF55'),(3169,'D','70E7D63B387E46C7AADF3EC978010B43'),(3170,'C','6D3218BD8BA04B13A76F0104CA923A81'),(3171,'B','D002B40C3EF240E1A6255D75A3B06858'),(3172,'C','D002B40C3EF240E1A6255D75A3B06858'),(3173,'D','D002B40C3EF240E1A6255D75A3B06858'),(3174,'B','527EEB7E835C46128859146EA60C57CD'),(3175,'D','3C2C6CC580324177B4ECD21E41644026'),(3176,'C','8FA99C085C3645FA82FCF6ACDDD478C6'),(3177,'C','E11D9AB6F3C64E95A7BF5FF663F0912C'),(3178,'D','C3ABE9208D7848F299090B4554F20785'),(3179,'A','3B4E8792088642EDA1DEBFA68A133D33'),(3180,'D','3B4E8792088642EDA1DEBFA68A133D33'),(3181,'D','29AE95E065684B01A516714F5DDE46CD'),(3182,'B','95D6BC17D4D34D6B815FBE935F4D0BC4'),(3183,'B','01CEAA4E91554641BA84F4BD61C49C11'),(3184,'D','01CEAA4E91554641BA84F4BD61C49C11'),(3185,'B','3795A47161A34FD4B23170FABF61D37F'),(3186,'B','8982AB42C8794CD1BC2654D5B6263EAE'),(3187,'C','8982AB42C8794CD1BC2654D5B6263EAE'),(3188,'D','8982AB42C8794CD1BC2654D5B6263EAE'),(3189,'A','58FC79388AC44E6DA8280CE64913E7BF'),(3190,'D','82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(3191,'B','B7858253780B4F10B35A2DF70121C369'),(3192,'C','B7858253780B4F10B35A2DF70121C369'),(3193,'D','B7858253780B4F10B35A2DF70121C369'),(3194,'D','9D58827A80EE4041A2D5B7FE9F70E965'),(3195,'C','41875999C5E44822853E3E5B267B96E6'),(3196,'C','EACBB9DADCF3466A82BD928EC2089CDD'),(3197,'D','38CFE97C37164229A3C9BBE9C1280D70'),(3198,'C','4AEEA146A2E74C32AE749F6E8A6B9316'),(3199,'C','A242BA4E56C048FDA9320B5D740961D9'),(3200,'D','A242BA4E56C048FDA9320B5D740961D9'),(3201,'C','477A1B9C4EC14ECC9B7290EB7FC1B409'),(3202,'D','1CFC6A1169DD4CFEB0CE86DA075E18CE'),(3203,'D','BAF423A1133D48FE9749B9E60BAA0BE5'),(3204,'A','9B6EFE555A764348B9BE58531E38D912'),(3205,'D','9B6EFE555A764348B9BE58531E38D912'),(3206,'C','63B45DA32B66475685F46FEE983F7547'),(3207,'B','14B207241F264703AEE06543DC63164B'),(3208,'B','867A48EEA69C422F9355B9F7D562FAA2'),(3209,'c','4ED826E4A855460F9E8126D83757CB82'),(3210,'C','4B60751411034489B7E1158DBCE6DB86'),(3211,'B','59B04F9C55C3496FA86542CB070905F4'),(3212,'b','64685341D82C45B3B8F3B1A3134CF03A'),(3213,'c','663C829E8EED41DCB7F7C1E7A55FB822'),(3214,'B','F0C5CEFF9AD34E6ABDE812D79A1EC930'),(3215,'D','AE8CAA19996D439D8B4F5B11C10FFC21'),(3216,'A','2B3329F1ED054BE198371A2B58AA25B7'),(3217,'D','2B3329F1ED054BE198371A2B58AA25B7'),(3218,'A','B32C9CFA62C9468588A801B2CE331CFC'),(3219,'D','B32C9CFA62C9468588A801B2CE331CFC'),(3220,'c','8E292141F8314ACAB1BE203CEC7C65E7'),(3221,'C','F3D9F4A576FB434AB3B2B83D729D5ADB'),(3222,'D','AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(3223,'D','EF446F71B42F4CC19044F26B36678528'),(3224,'c','03EE36FD8C994F1B98C1E2C2B91A200E'),(3225,'a','098AE1032F9B41C8B36F87899682C1F8'),(3226,'A','38A6717475E547C8BBF523ADC792BF42'),(3227,'D','38A6717475E547C8BBF523ADC792BF42'),(3228,'A','C760BFBD98A84463B16312773B7EBB25'),(3229,'B','C760BFBD98A84463B16312773B7EBB25'),(3230,'D','B2EE9F57C339413CA7BB0F366C7E8FCC'),(3231,'A','CF288B06B67349BBB52F112728DD2D6F'),(3232,'C','CCAE2E16A17E40ECBF7E95B61D65428C'),(3233,'D','0A44E4E052BE44469CE9467D42FC90E7'),(3234,'b','B53041E99960452BB1F950A1BB5BC902'),(3235,'B','7A5A8C6864ED4A3DB465E2C3510A7BCF'),(3236,'c','0AC1F7196363456C8EBD6F081D629ADC'),(3237,'C','58944F9F7B22498883DA4ECB977B8FE5'),(3238,'D','58944F9F7B22498883DA4ECB977B8FE5'),(3239,'B','7FADE388B8A248AB9B27C039B27E5369'),(3240,'c','87BE6014D24C434AB344B6353C0A72D8'),(3241,'C','4569A2E28CB042F6921F390684D02DDF'),(3242,'B','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(3243,'C','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(3244,'D','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(3245,'A','9158166EF28D45EE9B79F277AA12AA5D'),(3246,'B','9158166EF28D45EE9B79F277AA12AA5D'),(3247,'c','929298B69B8B4F0C8EDFA385A059F797'),(3248,'c','26CD2246CF504647AE7FDCB47B09D86F'),(3249,'b','B5172B84F6E94789976E31234531B0DE'),(3250,'A','00B20E41CAAE46209AC000C66BEA42A1'),(3251,'B','00B20E41CAAE46209AC000C66BEA42A1'),(3252,'A','A62D2A3B26744455AFA270A7B6427806'),(3253,'D','A62D2A3B26744455AFA270A7B6427806'),(3254,'D','93FE885389694756BD7570A6F6A5E9BF'),(3255,'C','97C2272DF4C34A3C9A50532BF8E16605'),(3256,'C','BC5C71FF35D24B859E8CEA53F879F535'),(3257,'A','AAF33ECA153A45E3B551E2CFFF2930AE'),(3258,'D','AAF33ECA153A45E3B551E2CFFF2930AE'),(3259,'D','36C8655255744CB193374CA64806B296'),(3260,'B','44D45872D8E94A33B4B95A9AA44B1D41'),(3261,'B','08CBCC0569A04EC0959683954D431927'),(3262,'D','08CBCC0569A04EC0959683954D431927'),(3263,'B','5FD277B28E8B49909275103539A1A0AB'),(3264,'D','F84B496BD94844F48AC3708A2926E453'),(3265,'C','9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(3266,'D','B57F7314D44C4F8AA9FF93EE210D5C46'),(3267,'D','7513B1E11DD44F9F8B525E8AA77AE79C'),(3268,'B','46632158F0B34724A8859A8B8DC296A3'),(3269,'a','408DBCE66C364E149EDF791CFEDC6EBA'),(3270,'B','52D7EE46041C46D19C59B62B73DB7980'),(3271,'B','CB23AB9201134BC08EC9307FED325F71'),(3272,'C','636BFD8C449E4E9E8F27747F99AA4DAD'),(3273,'D','73B37FC1868A4568B90D1EB5925B35CD'),(3274,'B','F833D534658142C385B5B2B1A864F786'),(3275,'C','290BECED2ED345B3AE8EC3181A70F21F'),(3276,'c','4275214FA1354D5DA98B73EB37C83842'),(3277,'C','32D7F3306B7B467F8868F18CCCA4A54B'),(3278,'B','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(3279,'D','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(3280,'C','537E32E7CC184D73AF8F5B86D07A55F3'),(3281,'D','537E32E7CC184D73AF8F5B86D07A55F3'),(3282,'C','1150C09E5E1844B0A65739C47FC17A2D'),(3283,'C','C7D1067D038B4285A24418301CAECC40'),(3284,'A','0F81984D117B43FBB0725F97D31EE4D2'),(3285,'A','667DC2D840BF4AA694944A4BA25DBC11'),(3286,'D','667DC2D840BF4AA694944A4BA25DBC11'),(3287,'a','0617883BDD94434A96D05C9C1F0ED825'),(3288,'D','3FFDBE2D2B134E6D8B048BA7089CD7AE'),(3289,'A','F344A682515D442FA44171A17A64A8E7'),(3290,'D','F344A682515D442FA44171A17A64A8E7'),(3291,'B','DEE31C203CD54ADE803E64F26A48B643'),(3292,'B','E393872B749649AC86FF340964D13EF7'),(3293,'C','E393872B749649AC86FF340964D13EF7'),(3294,'D','E393872B749649AC86FF340964D13EF7'),(3295,'C','8DE51CFFE294435CB2D7F7B09047D3FC'),(3296,'D','87B73FCF72D9402697D6C1CEC19756F5'),(3297,'C','7E06F8116A2641B59136F71EFDDE30B3'),(3298,'C','7938256702C74B5AA4D996FB909E0AF5'),(3299,'B','4F9CB47A267A41A8BE8AC90A7AA920A4'),(3300,'b','A9370CB8E0C64CE6B1F95C7879089C19'),(3301,'A','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(3302,'B','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(3303,'C','7EE7AC0A832D4417A2AFE9F7A5BBF146'),(3304,'c','7374CDB393694B91956EF062D4679DD8'),(3305,'D','58D2AED4CD0D4655B1D8D0E3FC42E58F'),(3306,'D','C8493696481F4FE59F25F61F2C54E35E'),(3307,'B','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(3308,'C','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(3309,'D','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(3310,'B','3DDC6332E2584337ABDF2D4F8C24FDCC'),(3311,'c','351D03AAD9D842B0963D8C64C331D5B8'),(3312,'C','0781FF85816C4FD2A3D8A553D859CF1A'),(3313,'B','4A58642B088D4226A6BEC80B701A1EE4'),(3314,'A','0CF374D4739048E08899A5979E775F65'),(3315,'C','A00CB5BB32EF48769CFEAA5E0187A4E8'),(3316,'B','C2567BDBA2D64DED8114094A4DAD1F75'),(3317,'D','2965CFC608EC42E982DE6E5A63957E2C'),(3318,'C','025796F30C8C4B279E45DD6EE100CE17'),(3319,'D','A69EF867A61B492BAC5158D988B4AED7'),(3320,'D','67C92A429E944C8DBFF46F6F3CD510D3'),(3321,'B','859C0B1FE3CD4C58B808649587824A2E'),(3322,'D','5DF28B993CA342AA901157CD56205730'),(3323,'A','C526F3920B464E8FB0E8E9C54E4FD96B'),(3324,'D','C526F3920B464E8FB0E8E9C54E4FD96B'),(3325,'c','0EFB5936274C4628A2A95D30E44BDB5E'),(3326,'C','7B21CE3795E94910BB106279D4A955E7'),(3327,'D','7B21CE3795E94910BB106279D4A955E7'),(3328,'D','5022616CA877457D8A141B4158D8F5E4'),(3329,'D','9D05EED1248B46B3823F23435539D348'),(3330,'b','F77A0C85A4844CF195AA85FE53575F34'),(3331,'A','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(3332,'D','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(3333,'a','897C87D84E924EA2A5F49FD1E5185925'),(3334,'A','4BEEADB7CECA47A6AE0E6711F8189D0B'),(3335,'D','4BEEADB7CECA47A6AE0E6711F8189D0B'),(3336,'D','D12D66B3B6144FC08E81320BF865EE4F'),(3337,'B','A3E0B6F49E144746994FFCDDC06E9839'),(3338,'C','A3E0B6F49E144746994FFCDDC06E9839'),(3339,'D','A3E0B6F49E144746994FFCDDC06E9839'),(3340,'c','F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(3341,'C','0E7146AEC5AC4B45BE242168E7450D4F'),(3342,'A','DD414FCB79974749AF717E98D3D4C7AA'),(3343,'D','DD414FCB79974749AF717E98D3D4C7AA'),(3344,'D','D3D17756BF3A47818C9836C3010F75C1'),(3345,'c','0EBD06CAB2D746EBAFB51CBFDEDF5074'),(3346,'B','1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(3347,'C','082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(3348,'C','59E7C5A418B04944BB933F2B05CF6E74'),(3349,'D','49D406AA1C964A63A7DC9015EC0FD510'),(3350,'A','D7903ED0A7834FC9828EAB5E6C6B4D53'),(3351,'B','D7903ED0A7834FC9828EAB5E6C6B4D53'),(3352,'c','32FFCA29A8D544D8B7448B6D06C36F8B'),(3353,'C','D70E631603694F6CA84BC4D9B54AE60B'),(3354,'C','64E9CA75707D4F579CF3199AF14DAFE0'),(3355,'B','CCF667BBB1FC4235BF83376980992B67'),(3356,'D','CCF667BBB1FC4235BF83376980992B67'),(3357,'D','A88341A5789A4D6EA2061F939BC41A0A'),(3358,'D','C4DAACEFDA044888A90F74EA0CDEB0A4'),(3359,'C','D7484358783848728F4D6F4F7BE71229'),(3360,'c','DC214D6A28774B4CA7937F45B0F14DD9'),(3361,'B','C87A28C672E54DAA8563BE61465B7A10'),(3362,'D','F1DC1F9FFF994C11822F462CDA652971'),(3363,'C','AFB6EE1D837A4449824B71102CDA2567'),(3364,'C','E979082DB56D4ADDA9B913424DEF7645'),(3365,'C','70E10A105A884D80ACD0BB0CC791B0F5'),(3366,'A','DC8491743C70479797D720E87CA9D53B'),(3367,'D','DC8491743C70479797D720E87CA9D53B'),(3368,'A','E99E0619078241348D2CF86A18EDF1E8'),(3369,'D','E99E0619078241348D2CF86A18EDF1E8'),(3370,'A','89E92C92C9CC4D0AA3BD1B560B326729'),(3371,'c','DF32D57DCDE548729DAA68628CD2AE2F'),(3372,'B','FE8614017D9F4D3FA72B7B458504ED67'),(3373,'c','DEEECCA653C8461996B16D55A1B4A055'),(3374,'C','A684A92DEA0E4203A233F605ABB213AB'),(3375,'D','A684A92DEA0E4203A233F605ABB213AB'),(3376,'D','731058054035494DAB0E4A44D5C0CEA2'),(3377,'B','0380EF54C2B346518CC4F8BE18BFF628'),(3378,'C','91D49DF2C5BA43A98EAD3F8202697370'),(3379,'C','AE1EEAEA6A204F87B16DE80B0144C717'),(3380,'C','E0CA769473A1448A86A006924DC34251'),(3381,'D','E0CA769473A1448A86A006924DC34251'),(3382,'a','12BEC049BFA24377BCE5112391D98488'),(3383,'C','987B70BE81F04BA3AE766AF0135BC0DA'),(3384,'A','1F8EE8AA42FF48E8A0BAA496AC54D513'),(3385,'D','1F8EE8AA42FF48E8A0BAA496AC54D513'),(3386,'D','5184B400846F48CD9B8E1AC993E7922F'),(3387,'b','26936E991BFF41FCBADE80B60B9EEFE8'),(3388,'D','E2CE2B56ABAA491EBE1B03A88B81A060'),(3389,'a','71DFF9365E7A4D77A40649D199BC80EF'),(3390,'C','739F3C040815411E8E4E0B3F001839BA'),(3391,'B','33CB39951E3D43D6999C89E4FE18A38A');

/*Table structure for table `examination_Questions_message` */

DROP TABLE IF EXISTS `examination_Questions_message`;

CREATE TABLE `examination_Questions_message` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `stem` varchar(500) NOT NULL COMMENT '题干',
  `Comment` varchar(500) DEFAULT NULL COMMENT '点评',
  `score` int(10) NOT NULL COMMENT '评分',
  `examination_card` varchar(100) NOT NULL COMMENT '准考证号',
  `examination_code` varchar(100) NOT NULL COMMENT '考试号',
  `ex_index` int(10) NOT NULL,
  `is_true` int(1) DEFAULT '0',
  `actual_chose` varchar(10) DEFAULT NULL COMMENT '实际选项',
  `uid` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2684 DEFAULT CHARSET=utf8 COMMENT='考试题干信息表';

/*Data for the table `examination_Questions_message` */

insert  into `examination_Questions_message`(`id`,`stem`,`Comment`,`score`,`examination_card`,`examination_code`,`ex_index`,`is_true`,`actual_chose`,`uid`) values (730,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'33847C7E645E4F72A74B7D74FCA50B28'),(731,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'AD156DB8C99E4AC09AC2870B6ACC6512'),(732,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'307FCB1526514497B5A1EDF2B4413AC2'),(733,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'023A8F0EEE8A4552B143D2D773B952F5'),(734,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'A9E66B343EAE4716B90668BE26223209'),(735,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'66691F2761F14AE4B31822ABC6A588DF'),(736,'如下哪些不是java的关键字?','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'E98381DA38084E33B2AC280BE51E25C3'),(737,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'AEB40BDD245549C889983956D76B98E0'),(738,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'AF7F21667F024A35A631E78513D74D5B'),(739,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'89DE9D102BF641A4B36CE8D8A5A4DC17'),(740,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1286976612114A438FAFA1909E70080D'),(741,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'3E7831B46614477DAEC02CC0D257D409'),(742,'如下哪些不是java的关键字?','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'535F1A92CCCF419484CC809BA76CBF10'),(743,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'01AF89EADF3F4CB3863843F3872176EE'),(744,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'0628E41F7BE042D1B02DE5A1FDCB182D'),(745,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(746,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'411CF3440F544A0E885A7CA9C635A0A3'),(747,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'D55DF333DF5148198D0AB00B8A1318A1'),(748,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1B77DA2116C2458AB79D9036DFA44FE1'),(749,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'37A1227DFC7C4A9EBF7673E08144E125'),(750,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'05F7786BF78E4CC3B86A8BACB6CA2137'),(751,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'359E5B13D49A43AA80BAAB943ABF82AE'),(752,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'96DE5D38ECA042A592E24FF659623260'),(753,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'595FEC504F08464EAA982C6DB610AFB7'),(754,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'BF55B02584644008817483E1885FC428'),(755,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'DEB8E00B47984B408E214125C97F561E'),(756,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'6E054FFAE3584AD088B6ECC7B4965322'),(757,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9DB691B963F5461AAC3E754346F22282'),(758,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CC6F88C11377484D9B49E839BFBD8D48'),(759,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'572E53DB246E40E2B8DF655AA8D74114'),(760,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(761,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9E71E08F01E44C8CBDE27DF7C8C2EA36'),(762,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'C27B38E93804484BA4C20A017DC36AD3'),(763,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'E81CA77AA7114CEE940B2017685315F8'),(764,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'D6FEB574878D45FDA87E87D21B2FECE6'),(765,'如下哪些不是java的关键字?','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'D0EAD34BC874489F9D4C666BDFEEB456'),(766,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'080AC05A00A0463F8DA60212FE66F7FA'),(767,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9588534660054E15B07269C3B0E61B60'),(768,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'709BD0672D6246459F23A361BB4FD037'),(769,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'F1DF5A8ECA484D85913D9057559B6E20'),(770,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9025A20BA72843C1B7B245810369EA9C'),(771,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'7560F2D221EB4068A112AEE2DD7594F0'),(772,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'07061192BFEA41D385A1B82AB1899900'),(773,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'0E800B19ACD3493B8392AA1E745FC526'),(774,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'99501CBC0F964897B5FABA2BD033EBE4'),(775,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1833AFC55CC8402FAF7AC5371C0CAE19'),(776,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'76E152C8AD4146CEAF75A4D879F5FD00'),(777,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'B652A6A0A12549AB8652E4432135948B'),(778,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CB38E30E01274C4B8FCE0C4D4A324FE4'),(779,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9432EC995CB04163B0118BE98A5A1735'),(780,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'E47C27479C9C4D4293C08DC6B15EABB9'),(781,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'6BE96985E07A45B5902184756CC7266F'),(782,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'DBC7179BEB2443CC8B79C226A868B53A'),(783,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'5DDC385AA08440F380130A53C0808333'),(784,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'24FE7079EB4B46E49CCFDD956F6FF753'),(785,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'C58B91FF03EB4334B2CDAE9270CBC56A'),(786,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9931269B85B3407CAD2538474F0D86C0'),(787,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'F8F723F3F63C441C845141DE446D6DAD'),(788,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(789,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CEC688299710476A867EDB0BD774B3AB'),(790,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(791,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'FF3EE10F7F8A40C0A22C946BA66A43DB'),(792,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'A6D21D1AE5664320945F8F3B8EF61563'),(793,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'50006AB4956F4EECA09BEA06EFDD47BA'),(794,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'809FD1A230F2447591B7DFCAFE9ADEDD'),(795,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'C27AFF79C3DB4160AF2366D618D1B0C0'),(796,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CCBE640AD2764BDF99BF4AF323DDE8A6'),(797,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'935C9CFE7F9D49ADA0B1D4D230836B7E'),(798,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'8D128BCBEF114A8A9F21E4C12B89265A'),(799,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'FC918759DD134FC7B8808340796A6E10'),(800,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'8A3DF44930B2411781E644DBAF6EC0BA'),(801,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'6FDA82C6B47547B3B4B8464495BE9319'),(802,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'F97BB081144A4CF0A5BB1CAEDE3661E3'),(803,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006001','2018020808400611',1,0,NULL,'D297C90E79CD409899CA6CFE31AA3965'),(804,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'1E46898D9E2A47BB844F2BB778BC1819'),(805,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CFB948206CFE4664B8455AE662BF2D84'),(806,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'CB3D1028B169461EBBC0B8C70621BB12'),(807,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9EE5241B598D47AB8291C178572148D9'),(808,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'9DC5993EE56F4782A01CBAD4B501A62F'),(809,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'553BE7DBFF814162A26D7362C58061A7'),(810,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'5E09FBD6E7FE402889DA86D12E0BC2AA'),(811,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006001','2018020808400611',1,0,NULL,'C3E126C77AE64823BA806EDE323714D0'),(812,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'C281AF83C3D048A388B1D8DB558B98BF'),(813,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'8B82035BE89647F29421B21DD985658A'),(814,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'5A003EF15715480D9670339F3E861B98'),(815,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'37B3BD3890E547EE99A0DF7BE6993FFE'),(816,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(817,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'4425428C58B74D67A2B044FC2C25A34F'),(818,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'2D7CEED6F7764D548D89AB16C69227E1'),(819,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'043B129719A042B98CBF2E28227F4177'),(820,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'62CE818D71ED44FA90386382838B4D9A'),(821,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3B80D26280B748858E3D6945B2E5383A'),(822,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'501A71A732D04BBC842D3A2C0E6C7E81'),(823,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'E7B5E813FB8E484BBAB82C802B6DDCCD'),(824,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3C59EF7A55BF42D7A2386303168B41E6'),(825,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'B0B5DF79A7FF49A59190A71F79FCD3C7'),(826,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'7A10C5C4166C4D369CB7B13BA1282FEE'),(827,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'531E9499C4404A4F87124A0477A832B7'),(828,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'09F1FC33E50542ECBAADE31A65D25524'),(829,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'BBE5511E95214082A7658FB057F3AC60'),(830,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'56CD45D13F9F4BA88DF8C3426D569005'),(831,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'4CE8A739509C4747B07BC9ACBA549F30'),(832,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'4556DC3D22534DAC84EB30BD05C652A0'),(833,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'05E31A91164341BFB413D7AC211EF002'),(834,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'6D93DD9548E24AB28D4E8B0EE1E3A30E'),(835,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'7D5E514B84964350935BC2D25193E537'),(836,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'96B0D01FA63E4FE8B11FB177C7791749'),(837,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'DCB01C2CD2EB435586A57D7CDF47E5BC'),(838,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'D6A555FE1080443DAC5CA287C256761D'),(839,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(840,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'9CB027C6BCE7460CA30F124B1B63D1BF'),(841,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'0D490C469B2A4213BCA13EB31217E7A8'),(842,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'00174112FD76452F8AA4B2E380BB419A'),(843,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'ED58D69EDDD34197962E7AB32D685DE9'),(844,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'1812208044334BFEB52FFC01DA63AE83'),(845,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3F8AF57D6A074EC996DF83FB0705C478'),(846,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'1950C8AB7B7541BF86293EFCC3DE11BA'),(847,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'EDA3CE4666164096B884AA77AE49FD8F'),(848,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'DE8CB3D4EF7040D0A1C5550BF8AE0343'),(849,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'5320AE5158BD4505BF94595E0706B221'),(850,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'908A8F4C1C7843ED811DA1E7DA28A8E6'),(851,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'7C7BAB6646FA41E78D14165E562042B8'),(852,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'004FED8329A048698E81106D4FB1714C'),(853,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'437DF6589C0B4094B8CDCC9320837C5D'),(854,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'294B40B018DC459FB45D3B729EA40F51'),(855,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'1F7AFF2D6849427C85B7179BC91EE999'),(856,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'D01CD39ADA0643BB8BBD8799CFBBABFA'),(857,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'65FB4E1B0D1D4DA88FD86813EE408BE6'),(858,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'5C632E6002924066A4DC0837103B09C1'),(859,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'1882D20B302B4905ACE92D9EEA0C68BF'),(860,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'5BDDAB0369814D12BDB77D5D166AE312'),(861,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'6B0AC3609AAA45DB8AACE89DECE8BA9A'),(862,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'158A3DC7F8A64598A55B5E535AAA4E33'),(863,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'C52630B669114C938E4C6CFD83237612'),(864,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'732BFC140FC449FDA43E0A8565B91BC4'),(865,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'1245D10B827A4C8BA46938B91F3FE7B8'),(866,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3C2E5BABF1EE49048BA0442B71508B38'),(867,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'554C0EF546B644DC819DAB3C0601C8E7'),(868,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'8BCF6A6DAE2647D5B218B61197C4F4FD'),(869,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'B7A26F4577054BF484B2AB4DE8FDE5D3'),(870,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3DD7907201814B189FB7196E351C2D97'),(871,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'6507CAEDB7734678B37E5935C114BC40'),(872,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'BCF551CB959B448B92F110D6E3A6CEB2'),(873,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'D617B0ACF0EE4679874E27E5AF6B60D2'),(874,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'3B323001322F48679D600AD4FE9E7905'),(875,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'55F32060A4724CCDB907F2721E946A4E'),(876,'如下哪些不是java的关键字?','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'828485D006AA456189A68DF541346251'),(877,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'5E0E5A153608468B952193473D436141'),(878,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'8B64E9A279134DD4B915C45B06338079'),(879,'如下哪些不是java的关键字?','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'0EA3C2EF5615434CBE9193C7401B4CD9'),(880,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'93039D2860D74E9D834EBCB32C9C1866'),(881,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'27C3A86660FE474AAC6D4BE318DE79A7'),(882,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'F99150C327694362A7C726135D43A43A'),(883,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'181DC739D0564E7284A1CBD8086907A1'),(884,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'2F7173F3FB624EFF87A6962C823F2D2D'),(885,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'D824EA6F59D44636BD5AC90BD9F900CF'),(886,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'6AFFA7CA9F7C409CA051443BCDF70E2C'),(887,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'B14F2F5F954B4FACA0E545D8EF431A93'),(888,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'8EBFD285D0854CB693A012A34D031D16'),(889,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'9FA48EFABC674BBB9FBE6B4F8A2AE221'),(890,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006001','2018020808400611',2,0,NULL,'38224DC43C514D3BB68F81BF29735E85'),(891,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006001','2018020808400611',2,0,NULL,'F954012773EC4DB293D8CF1F17575C80'),(892,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B142E8B7E0C04FEE9CB7BB19BAB731FF'),(893,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'D3F1C927CA474084948B2CF27870D957'),(894,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'7074E3BF6A124D3E992167C6BD58E767'),(895,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'C02B55F3CE6442628F670783207C5362'),(896,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'DEA25DFDECC24608A62174A5A0E0EDE4'),(897,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'2C1F6ED6BBBA45E2A45655583F2385CD'),(898,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B48647378F8E400FBA08CAD34666019C'),(899,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'908A80EC085E4AB0AEC7092992848387'),(900,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'C7DCF27B756D4CC18CC2DEAF6DEBC532'),(901,'如下哪些不是java的关键字?','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'62F28AE7A3664CB79BED79E730FA1D77'),(902,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'8256DAB3DBE14B98A7C537FC28D76E5F'),(903,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'9EF38305650842FB85394DA6D1A46EA0'),(904,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'852F76DA2073465C847D5693152356FA'),(905,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'A6E4413B7CBF44B2A5D2A50F5FA27076'),(906,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'CE05EB019C8A4EC0A8CF188BB9DCB648'),(907,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'4C5E0A40957A48C39CB85958577E4994'),(908,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'757AD1D494B94519BC03443347011325'),(909,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'024CE98B628C4D3D881C30D98196982C'),(910,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'C5F7E3D877BD492AB2BC86817A9B77CD'),(911,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'0504A7BB1F134AD286FD8CA7CA31759E'),(912,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'5879DC37332E44919C45BCB889E580FC'),(913,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'04A4028A95844785935C780C9DB74A53'),(914,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'6CDFE8F6B700401AA8745C3B0DC272EF'),(915,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'1E9BF6CCC36648C9962463A1C1B2B09F'),(916,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'6FA02E0CD577441595BC5412F065817C'),(917,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'BAC57760D094472299A1A521C2C0C298'),(918,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'02EC582ABC144C839AE1A5962726A7D2'),(919,'如下哪些不是java的关键字?','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'57EF3BE1298845C588A767D5FAEEAFBD'),(920,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'A32AEE8A60FD474EA251E4D233FBE12E'),(921,'如下哪些不是java的关键字?','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(922,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'54DFAD28A6E04C439CEE332C7FF3E75C'),(923,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'71AB3318078E49FAA5554D2F12FFEE48'),(924,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'C79378050CBC42CDA37AAB7972E2CD9D'),(925,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'D537C851221A46D98DB6776091F8E571'),(926,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'7D0474B3E4FD4E809AD9238C64F1EE62'),(927,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'EA6813301FCC43538DF356CB5A1B8A6F'),(928,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'0E1C9D489C774D03863E069C49F81CE5'),(929,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'63CBB2E07E3244678AF540F65F466919'),(930,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'B5BBF42AF8214339B290FC03DC28EBAA'),(931,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'CBF94654BCE8403483579FC6C6307BCB'),(932,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'078FFB388D2247C782BAB0AC771092A9'),(933,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'47C4BDDA23B748D7B0823483717163D4'),(934,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'4C84A3529A1C42AD9B7314722E90FB45'),(935,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'4D4E4BE3FB2D40B3AD56D685772D76BF'),(936,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B0B6F2FE273C4D3D86B5A30D1A6EF076'),(937,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'540A6A5C87CC4EC99C7CDC30D629EC23'),(938,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'96EC57D4BFEB47769A2C09507F2ABFC5'),(939,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'5DDF9F25890D4FF392644BBC735DCD7A'),(940,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(941,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'D6609FA578754C77BF08E5C5158C3C55'),(942,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'568D4745298047DBB255B73E61B7EB73'),(943,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'AC7E0D0B358245DBAE503B16DB7CCA98'),(944,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'63FBAAA7188B4B8EABA1657645A73FE1'),(945,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B42101106B1A4427ABD5830DE2862C73'),(946,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B05B38C6A9314D59BD85EB40E2D0B4CF'),(947,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'A4FD8B6880C44CE38651469A23EED233'),(948,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'F97283AD17A94F358B7BA73FBACF95CE'),(949,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'045D8C8628C742018180B2C2092000F5'),(950,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'5087D7A57CF64EFFA049F4BEDDEFA162'),(951,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'AED7FF5036E94F89A3601D15F1C29959'),(952,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'8A8142C34AD24DE4B6358FC6AC18938F'),(953,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'1F3FBE72591F475AB969A4F8EF4E2C60'),(954,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'A54F2711DFE34E4E9CA401134288C91D'),(955,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'653AF4E8D2A14A5D9BEC74C434E4D68B'),(956,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'87BEB1C026074995862847610484E7AF'),(957,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'7076C9D204BF49FBB92AAA7277B38ED0'),(958,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'81E6E99EC5A24830A2C530F91C38ABAC'),(959,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'15C50F987BAA495F8881A71259A22E2A'),(960,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'7B9A73BE7B9E417EAC73DA069CD728C5'),(961,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'BF71E4E2100443888F7017A215D0EDDD'),(962,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'19D0E4AB948F454185705481CF21931D'),(963,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B9389C4D870D4434B9B4A5EFB28D845A'),(964,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'D5BC53403A504EE087798448704A8D3D'),(965,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'4DA5EB8FAF7B486888DE6396DAA20F10'),(966,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'15E1CB05FC584DBBB285870255A56FE7'),(967,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',1,0,NULL,'B81C34972A854BA0A3DFC01452426EC7'),(968,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'D4BE8BDA77FE4847AC14112E841C5A8F'),(969,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'B4CACB1D109C492BA9A9D9896893BECE'),(970,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'DF346032A4BA45CB84F751E6B8C520B1'),(971,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'CE213BFD587341DBB6BE9E3CC48C622C'),(972,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',1,0,NULL,'841C28A31A474814A7274D551B88E105'),(973,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'458514E21CEA46949A398E823F66A43D'),(974,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'42EF937022E541409542B7DB395AAAA0'),(975,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'EAB90D4E56C840A5A3F04D416F26AED7'),(976,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'0CA93240428A402C9144B742CAAE165D'),(977,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'AF4F177B66164781B6408D303F86810C'),(978,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'57F009EAB72D4617870D4E86CB898E61'),(979,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'EEAA379F31DC470C979F6559DBE4E49D'),(980,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'264C3E77D7C74A65A54D7AE14D8ABEB5'),(981,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'07CFADE87C7D4A93BF61D3F2D1AB0435'),(982,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'AF6F0E141EC142B9A89238371A01088E'),(983,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(984,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'8ADC4E8C77704976AF6D5FDF24DCEFDC'),(985,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'18AAF3C9FD7A409B95537D0B00CA04FD'),(986,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'538F95F7DB924A9C83F6A406B11A0C88'),(987,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'C322AC8EE90B462B8F7CBC30475A63A4'),(988,'如下哪些不是java的关键字?','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'5D2D3F19A2D7417F851101DB6C69EA50'),(989,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'FF328EB4F05344059CD477D79A3F3756'),(990,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'984F4DB6953E4901B44D41F4B237219B'),(991,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'A11DDB9986C1462A8F88DF4025A813F8'),(992,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'CF688CC154204D41AF8B7BE2E9325206'),(993,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'2D3350F3DC2F49BC91842BF028CEB6BD'),(994,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'30F8BB727A8A4A03A41CC55C34CC4A34'),(995,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'C5A72355D986431998AFAB25C24A1BC7'),(996,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'6399DD9F92C243B19CB9630D77CE4E57'),(997,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'8DEF217850E7425E8F63CDEA64E965BB'),(998,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'2C902492655A4D45ADBF1414F2F22A69'),(999,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'7C2B55E5DDC443389212B3ED4D1982D9'),(1000,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'9E565542D2C4426F9C93BDD402FF9B7C'),(1001,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'501B24E92D88480C9BD8DA17FDCAA073'),(1002,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'995A1117E9E84428A976E20C3701002A'),(1003,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'DD84DD927AEA4E7497D2112A1238F726'),(1004,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(1005,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'45BCA083FBEE417C85D9A8FCB72D3218'),(1006,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'3EF12E00F8644DA9ACE62A96B3A8DFFD'),(1007,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'2EB316C6176A43F9AAB28179E2D102E3'),(1008,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'D0A1111E66FA40CF83F38723C1F2E243'),(1009,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'E6074C379FC64361BF5E26FC42DE09B8'),(1010,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(1011,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'5583044BC4BE4658BDBCDFB09F4888D8'),(1012,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'9FA981DED83B4AC494357F78CBE8D82A'),(1013,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'97A24EFBAA8043708AA7E3196C8DD36C'),(1014,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'09A4554A2A894F67AB29EC161ED0AD94'),(1015,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'8193D4AE48644B4FBDF8A9CA36244CEA'),(1016,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'713912F5E46346328118DC9E610F552E'),(1017,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'85369AE2C3894B0DBA0A8CF1BF9696AC'),(1018,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'F82A50997800481EBF83F8841EA0966A'),(1019,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'876C19BA1A644AE09B59FF21D3D0BF20'),(1020,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'CB375B3254C24F86940623F97D4964C7'),(1021,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'428316A7473843298FBD06B2451F7960'),(1022,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'63C38F3C6C8743358657ED4F97DAAC92'),(1023,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'AA5086CF642A47FF835942F0B91B2E96'),(1024,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'B23EF313E63946E2BBBD12223102C69A'),(1025,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'6106E40EF34841518AC57C37111CED16'),(1026,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'2FF97CAE7008449CAB06D72F3203CBBD'),(1027,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'A56FE711FAFD42F687F7965CCB5E9E1D'),(1028,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'D351981F52454075B38A8BBD17130695'),(1029,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'B1D4185AEDBB46DBA02C56353547049B'),(1030,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'6698F9521A344EC0964FFFDDD42EC889'),(1031,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'34756F5E0EE640A7A5F24B1C035831B5'),(1032,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'1D660E6E977B41D887BAA72BA7D82329'),(1033,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'E3A90239DF874BD883EBC1D805A03DAC'),(1034,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'764A8B7CDA5848EDAA5863C0FDD9B179'),(1035,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'C9588B688CA445078A926C8D252487AF'),(1036,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'6D27985CDB994BCEB691CAD52D8DFF95'),(1037,'如下哪些不是java的关键字?','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'7512F0CBEAC945EFB5F0123F97F54D88'),(1038,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'BDF349BCA1394593B1851DD7F624D3B0'),(1039,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'2248B08C238F4318AFC4D31A13568876'),(1040,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'9D4B6C71FF364B1382B511C5A0CD05CB'),(1041,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'4D2A4EAD46104AC798BBDC5D0B3E4698'),(1042,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'312A61C4E17740EAA9C7D2DAD637858B'),(1043,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'A65B0F53E4B04E91BF77E0C4A945686A'),(1044,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(1045,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'7D2A7A91D8E849828F8A26BA90A2F3DF'),(1046,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'D9264BD53FC5479CA3621E774007C4D6'),(1047,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'63AB8F5ECAA44DA98E349BDB678F0F37'),(1048,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'8D543E1694A74A9FBE6FC5998FB9915E'),(1049,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006002','2018020808400611',2,0,NULL,'5B2756250E7447BA92124C11C1B48534'),(1050,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'8E3A0710EDBA4065929590F25D6EE32A'),(1051,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(1052,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'D9DD8C5678FF469089B52CC20AA2AC43'),(1053,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006002','2018020808400611',2,0,NULL,'56F7E21CF56E4836B0E6DF0BB955C5FE'),(1054,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'57E84310FD9A4D4EB9A1CBF867EAC295'),(1055,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'91FF9D799B564C9F95B189C0FFF6E0A9'),(1056,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'830B4A82C02C44C0A6E2372C1F5B8BB3'),(1057,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'921B6660CAE0477595E7A5BE9EE25E6F'),(1058,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'2FDA6B3787244961AF6001F574545E64'),(1059,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'8E5934A4316C43A0818300E54F770628'),(1060,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'59C78793EE824224AE8075755AF9896C'),(1061,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'B69E338B93B144749C51624C22853441'),(1062,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'4745AB44A1E84A4DAD8399FC7210CE6C'),(1063,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'42503013F61240109E2FC90D689E6137'),(1064,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'E82FEAD8687A449697A0EA04D1593815'),(1065,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'F618DFEDE50E4833914C16E557D4DE80'),(1066,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'125D8E65A6664A2284CAEAA0EFF7D56B'),(1067,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'07B64BF8C1BC43D5BD1C0DFA7B80D523'),(1068,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'7E97CC25138F41F3930150DEAAA7F718'),(1069,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'5237406AF0E64A1B87AFA78C97521742'),(1070,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'95FAEC7CD2004FE38565189C8153D58B'),(1071,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'0EAA9324F9F04EFCAA69F5B6E732503A'),(1072,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'0C211E5F953F4DE3BBC66268ACDFDC00'),(1073,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'0F0BB2075E6A440DBD6277011E29DF2D'),(1074,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'5BDCB6173CD24C00A54D76CC75DD7D21'),(1075,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'D979ECDC0C434C238ACB528CEA9996E0'),(1076,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'FE9B4DA45A7A4EA3870A3D448A5A27ED'),(1077,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'2DD703ADD11048D291BE7A9D6C33D77A'),(1078,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'0D3E23B1871040EB83BA3E43F31C7249'),(1079,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'2B2A1FC2DDB84E38911106F21A45266D'),(1080,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'848B4A69E2534C10AD366D2805124925'),(1081,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'588B398B2C2E43CE828BFD0B0E174CCE'),(1082,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'2F33726699C144E48CB7C76A856256EA'),(1083,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'F341A225A1B84DAD8C38EDE74F65CA7A'),(1084,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'507CFBA7AD0F4BDBB09406719D56DC3C'),(1085,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'2FA9DDEBB8D84DBA876E5B559C3A6F43'),(1086,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'BA0623754560439BB0F402CE83AE52F4'),(1087,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'6FF9DA87D8854B6087901269F82BB8C3'),(1088,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'32808EFF6EBD40A7ADE6EA42932D76AD'),(1089,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'EC1652EC2A37468391FCB4F7A12CA465'),(1090,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'85381E73235347BABA8FE2C7D6AA8575'),(1091,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'EB3CF51FAA444DDAA10DF6B2DF898FBE'),(1092,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'992C1621A1AD4390B7948389B822B379'),(1093,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'8889C1666DA5478B9BBE4EE0CB27C752'),(1094,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'FACE3F397BDD400DBCD8A65D48D4B34D'),(1095,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(1096,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'C9ED16F8AFCA48B58D30C465AA251572'),(1097,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'50EA8CAD9F1C457797794D09A18E574E'),(1098,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'BBE54DA41275455A97BE8AA214F44FE1'),(1099,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'21AC3DAD00964F8F9A199136F07C35E8'),(1100,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'64DB87B316BB4CA7A4B466B9F3860978'),(1101,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'E6E31C640E584486A7CEF620BC9D3320'),(1102,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'F2E94965759944C5AC98BB548476DEC9'),(1103,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'67121C4B66C0486ABDBDE2C88BFAD0F8'),(1104,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'3EBF6814453340B2A2B61CA8DD0E4463'),(1105,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'96B053B715C2420893AE229AA76D611E'),(1106,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'CD50264C40BB436CA9074CB0B8EC6259'),(1107,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'9AFF39DB01CE451984A72F03FAAD0D2E'),(1108,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'8EB75F2B747347EC8B02E1D5AF61D47B'),(1109,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'948F7B7A3FCE4EF98E72049FB08F9B3D'),(1110,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'813DFF9649A7465FB621A7A5D2682467'),(1111,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'47AD197D959C4A16AD817FBE3DDDA7F5'),(1112,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'14EC3A99C1C84B0D8139501430EA6AFD'),(1113,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'B046E932274B4F4DBEDAD15BBABEF4AE'),(1114,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'C93DAFA1ADAA4735A05AE9F95241EDC6'),(1115,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'BFE462F80A874FE1A7F5819C26A5A140'),(1116,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'9C154B1EF7BF4A078CCA3656BB158699'),(1117,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'5EC69CE7407948D3805A8999B4CAC654'),(1118,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'587C362DCCC14B5BA46D1A7A893479FE'),(1119,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'25F3FBA293764D94A9394C2729C79972'),(1120,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'97D7CA30B1E344869E8619DEABD156F4'),(1121,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'C1381A4661A64CBAAEE49D6BD7D049DF'),(1122,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'AD684B6DEE7148FDA9468A12E44EF9E9'),(1123,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'C0B87C72595E4299B1C68A0B63865C06'),(1124,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'09365560EE224D558C2BE30364DC9051'),(1125,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'14249FAA35E343A49C0835A82CC9773F'),(1126,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'F477C34F8ADD4FDDBC100BE6F1009C9F'),(1127,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'A29048802E814634AA73AB5D72E69447'),(1128,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'F57FE2EB0EA542AB9472778821BAD7A3'),(1129,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'2D99730DF6CD407A9718DA57BC5ECE2C'),(1130,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'45504D0AAFC84F2FB878934036685865'),(1131,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'149386A467344D2A8B43AED0EF7C089E'),(1132,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'F3B2EE9EDD4749109584A5C9D68414AD'),(1133,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006003','2018020808400611',1,0,NULL,'B0FA93EE9B63405CB5D268C2AC54F94A'),(1134,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006003','2018020808400611',1,0,NULL,'45FDBE15934249F1BB9BAD516FBEE325'),(1135,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'FEEDF1B3BF504333B4FFF0680D2B03C1'),(1136,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'A84749A9745C4F948392595C675C019B'),(1137,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'E9A3A125A0404FDFB6011742DB6DB6B9'),(1138,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'9B29B0874B4C4AE08E514C328B2187CD'),(1139,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'E3F3949B95CD43599E1E7B3AD55E4F4D'),(1140,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'A8C86230C4DF425887ECCAAEB5CC02C6'),(1141,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F01DAA2BBFD2443FAE096B23884C24AE'),(1142,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'2E262AAD34AC48829568882086D7202F'),(1143,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'6BB2AD5611C542409938D024EC097EE7'),(1144,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'DB99F657D4E44E369C3A9E4A0A46791A'),(1145,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'54596B78F8E14FB790FCA3624ADBA8C7'),(1146,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'EAC5B4E23C194EA28FD27E9880D8E20A'),(1147,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'1030CC74D14B4403918928BAB6809B31'),(1148,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'D6F6401553564E08A4E581FF84397848'),(1149,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'BD896FBFACFC4B36AF0FE24DECEBDC19'),(1150,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F65F5369D2AC474689AAE38FFF7C932B'),(1151,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'15E755B3282C4516811D36F9B0545C22'),(1152,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'BE2B369CE4C24FC3BFFCC852DC7E46A2'),(1153,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'5D8E662FC59B439B8A68D3D318B47F80'),(1154,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'2DD6A8444DD84E3C81DFD05EED3DC320'),(1155,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'5A0CE621D2F64D7E90B7ACDD84782F0D'),(1156,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'8F87953473BE47C59C6CBA463610D189'),(1157,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'37DF54D7E16343ED847816BB63989CC5'),(1158,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'A0BBAE12E8C149038CB4C140C9BA58B3'),(1159,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'0D11249964FD4A75BC97E2010A771B4A'),(1160,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F9436FC4DBEA4FDBA5200454D7C5327A'),(1161,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'56838134CD794ACAA44586DBF5F3B959'),(1162,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'384941E85F064F08A4083AEA6B0D8817'),(1163,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'5A9716CE20D1462680A593B6C5B89CEB'),(1164,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'A1CD728328734A96A8655BB21E7B378A'),(1165,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'0AA606B630FD45FD842E0407601799B3'),(1166,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'52A6E4E1F52447D1B4E94DFBAFFE4500'),(1167,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'A6B8AFDB00714456914F07751B3FB1A0'),(1168,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'1C100AA2C8024D98897499F8209C5AF4'),(1169,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'4C6F72C4C8B14C7ABC4199A389B65481'),(1170,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'F0DB9D7F36304DA5A6461A92E257B375'),(1171,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'3D1A14ECFFA0406584B905BA2F690773'),(1172,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'739E8ABCE7C64F2C83E502206109DFDB'),(1173,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'E38F2EBDBC434FB1918C4828583DB36A'),(1174,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'191292A230724D4EB6F19FEAEABC3278'),(1175,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'4844E0394ED7459292ABAE08E6EF78CD'),(1176,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'34C5617C9A8B46A9AB391DBA635EE335'),(1177,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'6D16485C782647E6BAD95B07B3ADFC17'),(1178,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'1D0190BAE74B4ADB9BB11A2EE0B76055'),(1179,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'A75A32CCEE03492E90F11BF8C9B64057'),(1180,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'CB673174F5CA450290C914D6BD2F851E'),(1181,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'D95BDD7369DE4DF4AF0CA6665ABC1B06'),(1182,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'AC30E75DE43745BC85CBCDD915D9F1B8'),(1183,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'CB75519CBDEE40A787C87C7166B8052D'),(1184,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'D439C38591184F2983CAD78714385D7B'),(1185,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F1530F13F5A14DEA9F91746A872DD4C6'),(1186,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F5254E1EB9FA40C0A33494D306C600D1'),(1187,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'DEDFE4A171E141459A1430AF359CC194'),(1188,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(1189,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'DE65B6DBF034456A9C46D143E0C594DA'),(1190,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'BC43E962D27248CFA70EDE6E1DC6E0AF'),(1191,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'9E1D56FA615D42BA8734B31FACFD32DF'),(1192,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'3D5B2245D815422DAB789D69EBA0F590'),(1193,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'1061C923799E4CD68CB4D7DDE2C92FFF'),(1194,'下列关于栈的叙述正确的是   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'DA984EA888EB4427A3F91FD8658FC24A'),(1195,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F6BFE1D6183344C5B76596F9A0F5594E'),(1196,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'DCABE90E97B24CC09AA85C70D6999F4D'),(1197,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'AFC9B76CE4EE4DED9B67B783EEF78E2F'),(1198,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'9E2CEBB34C624D5A986A93F7805F2615'),(1199,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'8E628AAEE22341B7BE46FD612B8A19CC'),(1200,'如下哪些不是java的关键字?','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'47B51A629F9A4C13895B84F3788801F9'),(1201,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'C0E1D38F453048669840CC9C1F7C7BCB'),(1202,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'0C3B3A0A7F484C81B514BE6594A93479'),(1203,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'A17D3EF310BA41A49665FA0D873E9C27'),(1204,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'346501B7F0034B7DBAA2884AB5E658C0'),(1205,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'75557D048F23453692EE5E12B2BF12C2'),(1206,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'EF97015C5FF4418DBF4C60636754774D'),(1207,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'CB9A2970FDEC4B3DB457B7DD10E217E5'),(1208,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'D3894E7D8A2946B693456DAA0C3C20D6'),(1209,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'8C7A9B90249941579E5DD04FA1BB81CE'),(1210,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'221F3BC52966430F8EADA646C3655437'),(1211,'下面的哪些声明是合法的？  ','',2,'JD20180208084000006003','2018020808400611',2,0,NULL,'56BD5CEF222246169FF1BD500FF1663D'),(1212,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'976867BEC19E4ED1B01104CCCA6C021A'),(1213,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'73A0A1A36EF544889F7D0FAE6B1303C6'),(1214,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'1A8AD3DD69614D70A8828207DC42A4A3'),(1215,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'F55B96C279084E78BE760C277A7C277C'),(1216,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180208084000006003','2018020808400611',2,0,NULL,'729421F8CA9343018D5E1ECB53AE7CEB'),(1217,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'4A7E5B92AA2B48259664DBA8DC424C96'),(1218,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'A1C803209B8546C1A33B31943018ED7C'),(1219,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',1,0,'b','012BACAA617C40A2A4517011CEB40162'),(1220,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'3DFBBBFF5CFD4E199A30E323001804D8'),(1221,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'D53236B8A89043B7AD78EBED3EDF7082'),(1222,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'651CA25F1CC74C74BA88D50F92FCD370'),(1223,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'7B09CBC415AA4D048D3E843210CDA105'),(1224,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'8AACE908A00A4802B59C6B36BB9337A5'),(1225,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'698FA9F0F43F434094BA4681A58667ED'),(1226,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'B3D28145006843BC8660825F4EFDC0FD'),(1227,'如下哪些不是java的关键字?','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'E7812629EC4C4DAE879ED824F4582BC6'),(1228,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'8403CD89494B4B51A66E35F0949DFC51'),(1229,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'EB10B321FAE0463494F8B91973F66BFC'),(1230,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'06B62452BFDA488F8277E2377225094E'),(1231,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'7689021DD2A24554B3BAC8AA4953DED4'),(1232,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'2820C6BC8B3F424FB97315663FD8C1A5'),(1233,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'ABCE4CAA7ED044F590B67CA7844D4FEA'),(1234,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'294E033CD952474D9A32D06EF34617D3'),(1235,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'5D6D0FD2CB5A455F8C76A0A11532CF66'),(1236,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'897BD3412267477AB1935B5DD3F4DFCA'),(1237,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'7A07815398B14618990E1043254B8682'),(1238,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'3D408F5678ED46029E6D7AD970BB6F76'),(1239,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'583614F7F5E24075950DFF8D840677A7'),(1240,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'10F9B5A04C0C4511B15ACF8EE633E7EF'),(1241,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'ED392F1DB8AF42629A1AC48B77852BA4'),(1242,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'D2094108BBD742918B7192DFE388C362'),(1243,'如下哪些不是java的关键字?','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'CA06ADDDE87149E589A31571DDAACE58'),(1244,'如下哪些不是java的关键字?','',1,'JD20180214102200029001','2018021410222811',1,1,'b','A0165EE57DC146FFB022C4842AF19FD7'),(1245,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'C7FE7511D00141BD92F7EEF608D2540E'),(1246,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'443E423B23044DC79F1E5F9129931BBA'),(1247,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'34FC7A14DE6E4BD890BC2ECFC8CB1849'),(1248,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'5642346732C54350A6709F11A6877E04'),(1249,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'7B896485FF384634BCF54E74AAB236F3'),(1250,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'F926C0ECC64F43C4AA43CC5686AD96AB'),(1251,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'56B14E4D8D754A16923B7B38661874E7'),(1252,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'4ED97386374A4CB399BAE75B3B7F04A5'),(1253,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'34A4550373814A4583565D0D27D12DA9'),(1254,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'AFD5C03FAF6E461E993EF0AA6D30AFA6'),(1255,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'FEECD17C25834D1EBE40E0AB8D27A0D1'),(1256,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'261E0E19DD0D4B92AD9E25A10E6EA246'),(1257,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'D75DC562C2F843269B5C45EB350FA3AD'),(1258,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'B430246C092F424BABB7E12F228C94AD'),(1259,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'585205C658C8488C986B6C7C0B4FB646'),(1260,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'C34688C8BAB54B9F99110787BDD9A0CC'),(1261,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'FC77DDEB56204E76A5B9003B14839238'),(1262,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'6E1833096598439F8115640B1764BC22'),(1263,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'2E49CB6268D949F5A077E9250E6A8296'),(1264,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'95F8508EB1314785809D067307E311ED'),(1265,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'83CD58B0C68446B19CC3E52C7191D5DB'),(1266,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'BA09CF4A268E46719BB1562C1071BFAC'),(1267,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'82D854D78657472481799FA7E7C4AF6C'),(1268,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'57EFE093388D41A48EEEE53F4B337170'),(1269,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'4A04D4A64C06440B9B79FA621B91F0CF'),(1270,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'1A26D4793DA74C28B14AD677DC2EEC36'),(1271,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'D09CC07D43CB4D46A02088AB1F1BD8BF'),(1272,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'4836E60430AC414E8D592776A6628EB6'),(1273,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'1387D86A022F454C906DBFACB326C66A'),(1274,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'E8C8A99699984B05A25F923CFB885B66'),(1275,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'28B6C727DAB3400787950070F088466E'),(1276,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'72A22DC3F9F74DE5B18628DAF6B9F341'),(1277,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'1495AAC7C1DD4327BA0243A778D35D8F'),(1278,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'0E9EABFC29204285B9C562A3829CCF11'),(1279,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'5DF6019386464D37B91B2EC4EADE0604'),(1280,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'E2F9BB39BD5B47D39E83A9CD402E56C3'),(1281,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'6FF6706083574A9DB15B3B7C01E34881'),(1282,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'6D4C6A0FE592413FA97FA276C0F115EC'),(1283,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'01042551428C4DDDB6EEF28FA03C0265'),(1284,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'AF09572A8BAA4C18BC025531D80D273E'),(1285,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'A26F14ABB5124E538467296224508BE5'),(1286,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'0925C1723A33472F91223278E8B86B05'),(1287,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'94169FE7526547CBA0CFD18D8C5F0841'),(1288,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'2248D33C794B45459FCEF31A441DECD3'),(1289,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'8BE9C72252AD42CF9FB5D07A1FA88788'),(1290,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'04CA32B16C3F4074A078E704BE185388'),(1291,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'0202B878BE8347B2811E18F7C5596545'),(1292,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'087E23C1034B45FEBF489BD434B07054'),(1293,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'506F8FA7123841098B8FDCC2FE8FE00E'),(1294,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'B00059FA439C476BABB293289CA95AFC'),(1295,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029001','2018021410222811',1,0,NULL,'558F1A8771AE4633A142D8850103D03F'),(1296,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'CACAFE264F0643D9B6E99D0ED77070DA'),(1297,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',1,0,NULL,'C35CCB1EC4BA43A4AD7157257EC0DED5'),(1298,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',2,0,'bc','6F94F5D84BA24BAC96DD876A3849723A'),(1299,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029001','2018021410222811',2,0,'cd','F82D40C9241943A4A641B2F79FD305B2'),(1300,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',2,0,'bc','374D4F7CDC744C4D90CE84744B3567B5'),(1301,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029001','2018021410222811',2,1,'c','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(1302,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029001','2018021410222811',2,1,'d','B1F4913EE82648BBA0787DD3C482182D'),(1303,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',2,0,'a','D5A0908485B749ECA806CA6349688D71'),(1304,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',2,1,'c','1A3C99581202446399CD4D2957E435FF'),(1305,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'7DE0E15458D34E5A94E38537AAAF592A'),(1306,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'19C81852939949A5A45CCEFB5D8EFEED'),(1307,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'3A37AC4828F14215A0196E91E7D39A48'),(1308,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'BC1E11BE74D645639232359365B6E158'),(1309,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'FF47D51182DB4DA09F0E83566DC0E918'),(1310,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'1CBE1B9E5B304E1E96A2AE19AB8986C1'),(1311,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'68020EC47CAD48DFB7E609CD38B9E169'),(1312,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'493537BAD3CB4F5B942B5813F5B181BE'),(1313,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'D7131517D818414FA7A4C2AE1993D434'),(1314,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'D4E1CE0317934DDAA243CDC34E772950'),(1315,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'26F585B875EC42F2B59C6ACFEC9B3BFB'),(1316,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'D7BD79657ADD434C98CA8D245C2031DE'),(1317,'如下哪些不是java的关键字?','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'3B3296C71C7A43C497E6FD21EA862F38'),(1318,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'035E83A54A1D4068A96A9BF266B6EB1E'),(1319,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'CD719FD7E39848019EB8E25641ECFFBD'),(1320,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'7F08D3C1323143E88C769FB49574361C'),(1321,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'075C9025AE5B4D998414DFFEC663F5A1'),(1322,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'F2547990B70E47D3A8331AF838FB71A4'),(1323,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'AB5DBF5978DF43A1BEB13239407A5D16'),(1324,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029001','2018021410222811',2,0,'bc','A2CB6CD3363643F8A9DF27F8887991CC'),(1325,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'E55BF76712E1438A9FAB1BAC7B0ED7C7'),(1326,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'DCF07752DC654BE49752599D5F308BCD'),(1327,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'ABAEAD1EE0BA46BC86A2BE85F5800C47'),(1328,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'BC80BD86538641309E6AA25A867B22F1'),(1329,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'D1E215794BBF46F28A0C37B9D3936242'),(1330,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'F7317260A183428BA88C3E40C88180D8'),(1331,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'85E8B6F7914F4BCE8533F5A58F74684B'),(1332,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'6CE2540FA0FF437696713F7EA11C1A6A'),(1333,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'CE5C2FD456664E0F9159518082DD8484'),(1334,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'2EEF8A1EF8744402837A20A933F8EA7A'),(1335,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'E06953EB666843B8A1B4665A926F596E'),(1336,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'19BC2D554F7A4B45BD8FF2C68BB40CDA'),(1337,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'69BD435D4F7D446097303BB071AAA4E9'),(1338,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'80F46AA531964C008FCDBAEEC9E8DCD9'),(1339,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'DE5425318C5045208BB13A5234B80FDD'),(1340,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'817049F422604226B0C4102943B7B8F5'),(1341,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(1342,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'B0CE4518E47743608AFFBE6B452176B6'),(1343,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'F3D99320CB124B48B4947E01FE4ECC12'),(1344,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'296252C5A1BC4A4D8C816331F23A4B25'),(1345,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'B177A1C773934FA5B207F8E87D81E6B5'),(1346,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'A96CA27F7064453F905BE81905593D6C'),(1347,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'D4F5374AED9E4AA89819D39DB81BBFDE'),(1348,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'8B30A274598E4C27891E28DB917E5FB0'),(1349,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'04E829B1189A4237BEB30337CC370725'),(1350,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'CBB12FB1F0C24107B58F4546E590AE28'),(1351,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'A0FC3A6B57C946A3BBB0E1469E42D17C'),(1352,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'19A7323061AB48E0BF088E343C0C93CC'),(1353,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'FAC96053479B458FBE6A152567A52F09'),(1354,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'C2BB7761C0234DC6B13417AB8FCBDCF1'),(1355,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'6203C30573BE454ABB2F60144A74C92E'),(1356,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'82A4BFB14D3247A19D05AA6CBE401745'),(1357,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'7248FC8E09944933B0A43E5CFDB3FA9D'),(1358,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'E2C457D841D44B499069F934506C1334'),(1359,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'5E80109810C04E04A82927858B301F59'),(1360,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'61ACC3A755E24A49B5CD75DC007F4706'),(1361,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'262CA6B665C443ED977EA506B45378C4'),(1362,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'248D0E879F744F14BE80586A80AB7816'),(1363,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'30A1DBE2993F47D08EB77F4043E4E3B8'),(1364,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'54542AF7631D4091B12EFE77D5CBA830'),(1365,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'C072CCD1D67E4C4EA755FD7B859866E4'),(1366,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'40AC7C9E0EA94B9DBA1EE7B053B8D577'),(1367,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'FE67B4B0C78147CB80BAEAB317F51039'),(1368,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'D9B19D53C90245B88013FB25E4D80A2E'),(1369,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'8A03CE5AEA1F42C188E09A9FCA13C5F5'),(1370,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'DD9843C56183451EB8C70C3FAE3FF4F0'),(1371,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'929F5A6FC2114769933E3E1F59A7895E'),(1372,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029001','2018021410222811',2,0,NULL,'869C550DC2A943029172A31A836FB137'),(1373,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'655548DA367440DF9DA3BE3BE74700A7'),(1374,'如下哪些不是java的关键字?','',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'3B010524C5E448B7AAE23D60DE30E34D'),(1375,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'29FE99226B6F4AAABC53A72B30AEF2D5'),(1376,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029001','2018021410222811',2,0,NULL,'0D4DDF47D69D495681AA7B8AEAA23189'),(1377,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029002','2018021410222811',1,1,'c','89F655A2BBB743FA8690F03A2355F362'),(1378,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',1,0,'b','B8F11DD9DAC64244B577E877BEBFB5FF'),(1379,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029002','2018021410222811',1,0,'c','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(1380,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',1,1,'cd','0DA6181FD23F495184AE9128881AB30D'),(1381,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',1,0,'a','6911530B0B124AEAA00145929D3BBFD7'),(1382,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'2A4F6DA50AE74CC7A337594A78157C01'),(1383,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'B986D98802E6468485A59C0524946414'),(1384,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'070536DBD34B45968D6C066D501C7D81'),(1385,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'8EFB860529714AC2AB98D0A4791354E2'),(1386,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'C8E37F55ED3B44E3B266094FE7362AA5'),(1387,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'4B9E29A3F0AC42038F5494CD94FDE71F'),(1388,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'286D0E3555594C8AA239BE1606877D20'),(1389,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'5B1A8371922F4B26B6667A058ACB23BE'),(1390,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'9AFA3223D3674E9AB5794DE660951F02'),(1391,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'693CE405916248D89973A458EF74B047'),(1392,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'7696C808CF7D435A846FC77A69848D86'),(1393,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'A80C6B0EFD98408D905CA3B3BF89A8BB'),(1394,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'E917096B193346AB8F41C9491B4C8A17'),(1395,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'1BFB46B8EBB249489CEBA93AA518F88D'),(1396,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'0640B865AC5B46CB9121C984E2D62017'),(1397,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'C29A0DE351E4496BA407B0641D1234CA'),(1398,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'9138094802F2467EBB1DE62EEC2A1DB2'),(1399,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'299E83AE459C4D658A527DF258E063AC'),(1400,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'6561E43E97654FABBF141C7E15F0B49F'),(1401,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'BDEFDAB949C24702A40106A5251ADE2B'),(1402,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'41F4EFE9801C4D90B8DE8A63E5C5F71A'),(1403,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'74ADF931B41C41428AD755CE6EBB94EA'),(1404,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'8AB7AB739A124F77958C6AA2E8D0F70D'),(1405,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'99A6C7CAA93549AB834FAE50C5EECF05'),(1406,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'2ED5734A673E4C339FD0B1438DD73B76'),(1407,'如下哪些不是java的关键字?','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'93FD18AB5C7C41FABD46B4F985C25C16'),(1408,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'EFEF4800716C4E788A54F08A9008C76B'),(1409,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'F70A348516C44BD595D2CD4B6381FE55'),(1410,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'EFC117396B744D1680DEA4C229793E4E'),(1411,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'96ECB3FE612E4FCC83210C5A18943BE6'),(1412,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'CB644C9EE5B845138FCA065C4FBD168F'),(1413,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0867D52E1F0746ED83B62A04A4A00D98'),(1414,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'C0AFDB5D127540A1A3E8937982AA9780'),(1415,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'C1DD9BE59F9A47A5B2C610BEF8F88141'),(1416,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'84979A08FBAC4584AE4D61E43B2BA585'),(1417,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(1418,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'1A2645D1AEE54168B6B253C3DD0CA998'),(1419,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'213431AF11204FD69CCF18F8439522B5'),(1420,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0FCBBA0E48CA43AAA7E30796D30F9CB1'),(1421,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'FFA54377478E42D7A01E7D71E3BBA729'),(1422,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0413E90435FC4D4FB1FEE23601F9FE7A'),(1423,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'E8952C853EFF4BFF87F05D414D4ED78E'),(1424,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'D203B21A22A341059D50FF51D820BA1A'),(1425,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'7301865F1FD946079509C0AFF72F804B'),(1426,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'B0AB1A23B3104B4BAF40A190A0CE2597'),(1427,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'4A0A7795EA85408093FD320E246F3839'),(1428,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'6BEBF5BF0802488AA946FB02AE7F6A8F'),(1429,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'12542706BD1B47119195DC25D9FBE82F'),(1430,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'CF84EF1519B44EA391DFEB1D7669C4FD'),(1431,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'1F908DE55FC44B5DABA7F325B741FABE'),(1432,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'BD9451FDDC5344B2ADF9B2071536DCBE'),(1433,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'9BD5843563AB40E582D75AE781066C2A'),(1434,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'AE0268E517A74B4E8C0674B98BA4937B'),(1435,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'1EF1C021F1664F89B606141F9944285B'),(1436,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'595F46030B864B5AA7A2514C5FD01530'),(1437,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(1438,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0A4B1D2AF0084D7B895035B5EE77D8E6'),(1439,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'CFA4D63725C642A48F7FF82A23D6DF68'),(1440,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'09CBFACD70A14F2F9745A645E465E922'),(1441,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'61F3E2D3FA414A7C982585BCC73FFA87'),(1442,'如下哪些不是java的关键字?','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'9222CF3B26344D5ABF02A74B4D16EB26'),(1443,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0AC17E06E97042EFBEA37DFCDD508C66'),(1444,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'64C581C57611435FA96D0C207F770D40'),(1445,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'7C5608C9F84B48048BB9DC6E1B9ACB5B'),(1446,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'AA64AE2B1CFA45B58FF91578C0C692E9'),(1447,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'C67CA358B09B49B082703D8FB5487FC7'),(1448,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'D7F585C00576434F9E229D2B28AE5B94'),(1449,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'4980664FEEE74094BE1EF5C56E0CF621'),(1450,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'F6CA9C10199B422A97C874A6E8014FEF'),(1451,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'65AAEF852B1241298EF0DD8CE15CF55F'),(1452,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'2DBB8289CE3848ED8436AC61EC34CEB8'),(1453,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'0EBBB7F18A16459393FF93CE72EFADE6'),(1454,'如下哪些不是java的关键字?','',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'3D1895E837B5483CBE893C45DF5AD110'),(1455,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'BCE8E2EB961046C4865CFDD088105D7E'),(1456,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',1,0,NULL,'55A3E48D36974DAAB0070567857162EB'),(1457,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029002','2018021410222811',1,0,NULL,'25FA8D11E9AB40B48B33145A15B64EFB'),(1458,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',2,0,'a','74345EFDF9CE487B92EA4DF6D9A26F3A'),(1459,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029002','2018021410222811',2,1,'b','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(1460,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',2,0,'c','60BB608E6E6E4C32BD2D4FECCD02E707'),(1461,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',2,0,'d','8636C2FA7EB948A2A4F6C0A081D24DB8'),(1462,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',2,0,'cd','632D0490B4F7404D91A9DB9D4862358C'),(1463,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'09428B0CFC0D4C92A64BA390292D8FBA'),(1464,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'8A7D182C8E044B17AB5EDC822114E7EB'),(1465,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'22AC3BDE7E5D44039BA2D0B3691A6E97'),(1466,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'C989535D3DA2465397237A0DF7D4A1ED'),(1467,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'83D4F9BEFC574F7FB720DFA04F6F8D9C'),(1468,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'FB35A591A3CC4B799FAA2CB19F0F3337'),(1469,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'D652C6EA73224BD0AA68641FE2FF8953'),(1470,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'435DFF33FBBF4C8BBF22B18E4D6FCB66'),(1471,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'274E7BEA6110417882F2ECAE1D5E2701'),(1472,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'CD86DC85642E4EC4807A6AF1D59CE34F'),(1473,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'CD337A4012E84D54BE512743FCAD3652'),(1474,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'81E97EC6AB6D42F9AB7694E0964B9FEF'),(1475,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'855F8249B7FC4718A6B81DEFA9876E57'),(1476,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'8B1C032B2EDC4B96AE3B1B2564F4F20C'),(1477,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'A90B7EB988B94928891FE56B40027C73'),(1478,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'63321AF40BF541E19D74646BB674A19F'),(1479,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'5B06C53FDDB54E7FA921FA7A5073A57E'),(1480,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'97DDA73A5682439DB14849C80DD0084A'),(1481,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'F877409A392345589C51F43EE52FB5A7'),(1482,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'EDE23230BBA4443A807812268B2BF4BB'),(1483,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'555CE6702DB64A73966AE59F3E576DC1'),(1484,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'4396F09A6AA84E1B864D2C63A6337752'),(1485,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'53381A42A43340FEA4767E580690F62E'),(1486,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'436D43A3765A462C822FF1A0DE416D15'),(1487,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'23F2E8A0873849D5875F9B7DA8B217F6'),(1488,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'825D7955FBB04834A4D1D6441C4480B4'),(1489,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'9ADE4D63B86A4EA9895E5ECEBDF919D7'),(1490,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'4B733A8DEE6D4739AA5417D62A9AEC50'),(1491,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'7540390049DD4A7F9D190C9F10BA33FC'),(1492,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'EDF65AC0A4484B0B820A06E9D8FC2EE0'),(1493,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'F06B1A470DC2487491F6A83E30E5DBC9'),(1494,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'CF803CA8E4BF4930BA818B704B11BDB4'),(1495,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'0E2A5BD27E394B1090CA3124092283E7'),(1496,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'EDE0E139CEC3451C8E9854861259C3D1'),(1497,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'938DB3CC18C64FC18699CFE62E181DE9'),(1498,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'DC7D5F74C96E415AB785C71833AB8D2C'),(1499,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'9049E39730144C6C8739DB31557F6633'),(1500,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'15C5ACD252D645E1A8084BDCB22BD1F6'),(1501,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'24B4F2D7F305451F87EF5643A6D0C828'),(1502,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'0543D8D393FE4F82A89CDD251772D061'),(1503,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'EDC1A3552D814E34ACAED9520D61A2D1'),(1504,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'E410C06B1C1048CFA0B99B4B28D44B3C'),(1505,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'7B8E1CD00AE149FA80B507FD9164290F'),(1506,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'8298338D4AE4437194D940338B7A3CFE'),(1507,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'5CB23EC66E6B4B2DABEC0E239C86D451'),(1508,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'F989D5B7E01948D4A88173210106E6CC'),(1509,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'ED10214CC95241C1A21839DFB6712B59'),(1510,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'81DDD64B5091404E903A638A3275BB87'),(1511,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'4776E09F1DBA4192BB1C38A4544C45FF'),(1512,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'BF9E794FB6204B4DA28344838DB36967'),(1513,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'E1AD6D445318499694C6435F2D5F074C'),(1514,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'D84A574885B249F5AEB13A59A3601AA4'),(1515,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'7CBE3D12E4224139B9EB06C786ED28FD'),(1516,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'03BC69A2D63B49AC97A4356D8FB0A380'),(1517,'如下哪些不是java的关键字?','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'09C53C15B56941238EF4E2F8B00A9F95'),(1518,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'78E4D599990449DD9FA65CDDFBE61CA2'),(1519,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'FC741D0D99DD4FE093AA5766536AF46C'),(1520,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'58D055FB14FE43ED919859CCCF067B97'),(1521,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'F190C2F69AE34F4B91E74A208A069C7D'),(1522,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'329706FC45284D01B254145C2FDC6FF5'),(1523,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'A0A9C16F6CDD4C0C9C5B0DA460076A29'),(1524,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'808A0BD91EA549508B3EDF9312B85848'),(1525,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'3D05015A6C164D7783F984AB539C3358'),(1526,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'33E22D18B1A548E68947E03AA501A447'),(1527,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'81F52435CD614AEA92585458280A090F'),(1528,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029002','2018021410222811',2,0,NULL,'FC35A8164F4849C7B9DF535EC15B79E6'),(1529,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'F972C82759434FC7AAF61E0C14AC217C'),(1530,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'1D15934771994B7FA18EE7C70DB61D1C'),(1531,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'79C4369D5C084B009ECAB86185455F68'),(1532,'如下哪些不是java的关键字?','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'521F8738D95F4360BA4257A38DD65584'),(1533,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'F43017E7D7994F1FB738CB11F4046AB8'),(1534,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'9F13AA53017F456CBCD746891E672C3E'),(1535,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'295DD721E257458DA40B3B17E8599AA5'),(1536,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'16A6BF18CE014E06AFF9A5BE86AE13E3'),(1537,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'6898DE2C981C41A198058EAF9EEE16A9'),(1538,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'32C34E0881AD47F49BE0B4D549D50988'),(1539,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029002','2018021410222811',2,0,NULL,'DD9C53E5FB494381ADA04E4638EC428C'),(1540,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'2615D6CD0F1C43978448245BDF843B5B'),(1541,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'19B517D3B52F40578347905C3D044486'),(1542,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'F9FA720A32EB4F969E6A5104E0C8E8DB'),(1543,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E70032CFDD22460C966839D6828B3D84'),(1544,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'1BF333CF63E64126A30DD17110FB01AA'),(1545,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'D660E09215B34A70BDC91F490EA27A06'),(1546,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'66A765BB58C54E408F8B8A597438D34B'),(1547,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E0E5CC9B9DFB46D585F1547C00361D74'),(1548,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'4D21A34788D84C99B33234D0632DA411'),(1549,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'3CC7679ED20943A8AB106E2B229CE269'),(1550,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'375B9BBAE57B4CF3A9A85DF58C603211'),(1551,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(1552,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'2D92B3A0EFD24E698D9B7907B5338C11'),(1553,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'2FE0D8ECEB2341F28F9A298B99DBE435'),(1554,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'003A3CE42BBF4289B57F500920DA5DE3'),(1555,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'119E5EF740FA44EABD71DFAD54A61393'),(1556,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(1557,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E6BED81C3B174E708FC985C1CC16F948'),(1558,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'EC95DFD2A860487891780D49A0816759'),(1559,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'F47CE03E84ED4C78AE2B01EFB0BD9982'),(1560,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'B5F2F5237A8C4C5D9498F5598C177300'),(1561,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'99629B14E46243759AAA9D372F54F79B'),(1562,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'AC6471EC5B974392934D74BB93F9433A'),(1563,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'7B5788DE261E4F0B831E2E5DFF8B48F3'),(1564,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(1565,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'2CD78964FDB04D3286C934F576DD6AA2'),(1566,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'6BBE419AF2B74821923AE428CD594584'),(1567,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'91ACB31317C14810AB7FA8D25F474A31'),(1568,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'F547BF7A1E9640B8B7E819EF06D18141'),(1569,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'B4F0B52F92B14322932F9F3468E64390'),(1570,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'3E75ACCA16C14F7191BE8EBDA6C3AC32'),(1571,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'80A64B51289C40FE93FDE1BBA74D0022'),(1572,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'C0EEE70D6F6F4968B8296E2D52E2F1B8'),(1573,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'5A651F4832374D32A049DB3B119167A6'),(1574,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'533E7E73FE0348D0935D07BF4C5D8860'),(1575,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'50E80301AF3A4036A1CC737159EE46CA'),(1576,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'76B3C03EB0C04229974EF7B08BAB3404'),(1577,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'40AF6A85DE0D44C3AF6F2122C99033D1'),(1578,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'B9494DA7CA294715BCE7BDAA3446C82B'),(1579,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'EB20C87468C647FD95CA00663E89E733'),(1580,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'87FA9065EDAC4039A085CC9DBD15063C'),(1581,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'3CEEDA7CD02B46F3BF0F5CFA32D45399'),(1582,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'0E08E66A8AB645159BCE242D26B62202'),(1583,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'9EE93CF38D344B13BDE4CED1D5358251'),(1584,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'1A5266262367427C8637D993FE966F21'),(1585,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'48CA108F7CF14766B4066F3298186FE3'),(1586,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'2039E97D0941437E8774BD4D4C9CC5A5'),(1587,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E54F7561D1A54BCFB5BCE654A9B939E1'),(1588,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E0BCA8C7EA704D44B25AD8D9FBBC9049'),(1589,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'6A4B6D306E954A58AF67FE2B0918A52A'),(1590,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'9ABDBBE373C945ADAB6AECD62691B2EC'),(1591,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'A96CAB20630C46FE98F12F3F9E4EDBC3'),(1592,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E34607B970B847F5833C3EE91DBE260A'),(1593,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'592045A682C143F1B5F73AB2BC49EA39'),(1594,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'15AF822681384E0C8116298B275F4E5F'),(1595,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'154A8F749A014BB89B6559B2ED663231'),(1596,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'B381A76FE262452B9E6C9478034D7294'),(1597,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'E0EBC82ADAA04CB6A525D33648826673'),(1598,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'DAA6D7CA54404D2ABD317D6E34B54068'),(1599,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'9B0FDE2C2E8140E5A112E7196C143B96'),(1600,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'867759DE356A4AF4A9506844D56D3CBD'),(1601,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(1602,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'06817551644C4775813A63475CD22F5C'),(1603,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'B647C898BB624E8B9C169FA8ED71DB11'),(1604,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'8254D1C937494DC1BDE603DFBB7DBA20'),(1605,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'494A6ADC1C424B0990FF898174DEA3BF'),(1606,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'CB798645904E4DFBAE124FC361420EDE'),(1607,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(1608,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'F1A5E74880D34C7CBCFD7ED24D062263'),(1609,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'6D2079CAACF54FD1996EB3B034058787'),(1610,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'7BA353CD6E6146AA9BD40C103F8F0B25'),(1611,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'A086187FDE3E411DA803CCA6FD4A260B'),(1612,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'5AEF21E0863A48B9AAD6675F5EA6EEAB'),(1613,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'95BB57D10490464CACCB836D1987B76C'),(1614,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'A14341A6F3284C5CA55170871D4A4FA1'),(1615,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'1B60F1B1E9E9432AABA1E787C9867C5B'),(1616,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'AA5A5FB2ACCC4BE7894B8E1280C50B53'),(1617,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'CFDF209AC9C147ADAA00CE3B89365063'),(1618,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'7ED13A90A5E34B73A766B23C1F0C11AA'),(1619,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'33826A86CBF94E76B700F60AD89095BF'),(1620,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'0299E16829EB473F86EE48E22507392A'),(1621,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',1,0,NULL,'489788BA73894390B508732C250373F3'),(1622,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029003','2018021410222811',1,0,NULL,'167C1305788C46FCABD8D296563274AA'),(1623,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'AEAA6705843A42FE9B935AA76736D75E'),(1624,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'A8C158F95DEF44FF87D4805613DCCA05'),(1625,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'BC40F65384954721B7F35CE058DC2070'),(1626,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'E8A9CABCE48F44FDB8660AF66F9CD579'),(1627,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'A7CD4554B61F45AE8C3CB6EF8F1E859F'),(1628,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'7736CC6C00C747D9A3B37296533358F8'),(1629,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'9E43F442CC244D75B12236BE6ED302B7'),(1630,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'6A7CBD3CF9DD4923A736F30B26C0F341'),(1631,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'7A1067BE51724D56AD76B9A2DBFED6CD'),(1632,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'E843E01A778B4E529EE11876783B61D6'),(1633,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'63DE80D28D9E4134AB8122CDD21F3A27'),(1634,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'D4A41C347A0C4A92B7BB84DDA41ADC40'),(1635,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'DA658CDFA0EA4008A43FF6B5C8F18337'),(1636,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'96EF4A0B490C4290914DDAC8D05AF71A'),(1637,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'5A66BF0CE99F45AA86BCA1699BB63B71'),(1638,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'40885C34DB05481FB4269E64A982B194'),(1639,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'195C9E8E3A51477687A7D71BB2EB1F84'),(1640,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'F64E7F4C040C4863ADE8A76716B5069F'),(1641,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'A2BDA62415F3495DA7BF416B26FACF04'),(1642,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'C2E31B5A2299479EB316899E28AAC73C'),(1643,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'AAB10F8D7C7940EC9B91ED5C07E7FD57'),(1644,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'FF9F91C6DE7C4F70B25A30900DB69D3E'),(1645,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'5904376E0FEB4D19962CDC61B5E83D00'),(1646,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'254C0048C836445AAC8CF2F05E896957'),(1647,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'7C9BB443AC7D41B7A3049CB978D5F984'),(1648,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'44967D1672CB49C2ACB62C2A9E264DA4'),(1649,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'014E8A798851424C9F8EB15B1D3EF004'),(1650,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'789AA087285040E8A654170258E693CA'),(1651,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'BEC05EC41F6D423F8F42BA058CAFE4A6'),(1652,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'988A4504583D463B954CB26D7AB138DA'),(1653,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'B241A08F2AC948449075C5E5C0E818CB'),(1654,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'4D0C6E8D8EFA468BB0CD1C4274576553'),(1655,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'A77262B0AF5740DB87C9A51FE4911E16'),(1656,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'61D69936A43F41FAB8796932AC9D115D'),(1657,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'C427D5723A7A43D9A9C11B98994CA1A6'),(1658,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'1DAB54B841644A20BD0CE37C7024FF1E'),(1659,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'8E5BBA0B691048C683966FF703BA6E07'),(1660,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'9731F99B9C4A4110B8F5829407E29481'),(1661,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'D9E8856D46EA40F58B247109E2BEB758'),(1662,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'E020D6EFC3B5417684331BD792869938'),(1663,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'094EC8B8D038495EA86724EA0CFBC8E6'),(1664,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'B8703E28F1824FBFAB97FE0D5F7AB1AC'),(1665,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'281B19C9F69D47C59305436EB36A633C'),(1666,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'66B11088551247C1924DF310A1641786'),(1667,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'709B464AAA3647358F69D68D509EA8E3'),(1668,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'58552B603604403A958B9DA4495C11D8'),(1669,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'EA9CC06D7373460D9678ECA2894E64AA'),(1670,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'2D9BE9797C2245D7B1DB8E09C6ACEB53'),(1671,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'DFAEAD70CF24459AA6F0C3223111B42B'),(1672,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'73E3DD9CD09C437AB61941BAE111767E'),(1673,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'D909313558454382A29345276AAB284E'),(1674,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'66684A524E94456C967B1DE167DC0CFB'),(1675,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'B8A918ABED9F444A844BE17CBB2C8639'),(1676,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'E9D73490F69F4DF6B653181BEC8E8F24'),(1677,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'3E6945401C5D485F8323E8CDFE5E9493'),(1678,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'4A88DE2F3B1946A489889028214E14D0'),(1679,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'01A46533ED594CE49940A246AF19B1A6'),(1680,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'866AA7190E484BEAAF35BFA62177E6E9'),(1681,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'B2D5668D6F094EC196253CA62154F829'),(1682,'如下哪些不是java的关键字?','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'D387242B65A14D22B43371C16F8C9411'),(1683,'下面的哪些声明是合法的？  ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'18632F73C2844543B0C18A4322CA8339'),(1684,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'5740D06016464C47B7E7C107A30B7CB0'),(1685,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(1686,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'AAF89D30DF4143DEB7F23A931682BBC1'),(1687,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'40EFD49AB39747948D5F83176DCECCDA'),(1688,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'2AE08401C159412CA3D1740681579A50'),(1689,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'A6F99C70A86343DAB7670CA79FCCA63A'),(1690,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'98EF0AFE64F345369A76B641C32486F0'),(1691,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'379B0496E3A9438D8B7F6C9422666D51'),(1692,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'0B721D7D16F04592AA6F42749580D033'),(1693,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'EE1A413F380D4309BBFFF711A8648157'),(1694,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'B7A3FD0A53D44C839EFA0E045283B7D2'),(1695,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'157D8F6E86244589ABCE190C55E9E206'),(1696,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'5A4370DBC11A467F8F2B7DD7B12A02A8'),(1697,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(1698,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'8FB8A3B925264124ADC086FE3BCCF07C'),(1699,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'C1B926935A27482F8BDFD800A0E134E4'),(1700,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180214102200029003','2018021410222811',2,0,NULL,'2FCFF2A9ECEB49869E3DC6173D8CEE63'),(1701,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'36328B1A27024DF5BF53EE86B0AFE395'),(1702,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'4E3F5523794448A682A9E45F720D337C'),(1703,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'AB86306982F64A30A843B32CC551A395'),(1704,'下列关于栈的叙述正确的是   ','',1,'JD20180214102200029003','2018021410222811',2,0,NULL,'0DEC67667703418A9D500A6AA492ECB5'),(1705,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055001','2018022408515511',1,0,'a','DE9FE12BDBE2439390748073206FD7A5'),(1706,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',1,0,'ab','B6A9FDC67237424789850CDC62960F6F'),(1707,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',1,0,'b','749BB2EA756F45EA81C7DF86DF55C4CE'),(1708,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'39E6BC067CAE4D17AFC56F575DB28D62'),(1709,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055001','2018022408515511',1,1,'b','5A7BC33966824788AAF68E077BF4B593'),(1710,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055001','2018022408515511',1,0,'bc','2C9E2DD1F915459EA056A5A349137FD6'),(1711,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055001','2018022408515511',1,0,'bc','45CD38F7BB2C4E00B47734F25466E71D'),(1712,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055001','2018022408515511',1,1,'c','9688B22F8FD44D63980AEAC3A2F89B7F'),(1713,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'D172597C84C341F0866B539C4483B2E5'),(1714,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'00E6391CB1EE4A6BACCF7F7B72AB410E'),(1715,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'568BDC18AB1045E8813E099558FD496E'),(1716,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'C6B500BD927C41C88DB9D00BFD7AF0FE'),(1717,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'0788717DF9EE497C8BADC2D9A7E9D19F'),(1718,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'6D63BDFF890D4ABDB9024BB9BA454AF9'),(1719,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'EAA46BF912CE4CCBA52FFCB463793446'),(1720,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'06C4FDDABB98445A81483DB9CEE1AFEE'),(1721,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'1A96EAC9928141F094CB921ADBD1B6AB'),(1722,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'53160599A2B34D3FBD1302AB2F9C6CF0'),(1723,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'53077725492E4C7ABA5D53A5CDADD450'),(1724,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'EF2C064FF3864D3388B7B8DFEB930BF8'),(1725,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'8F66DA2C47EA4C2385210F2F81178064'),(1726,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'43603D2B89624DC99830BD1EE69C3730'),(1727,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'81630083A38F49D0BE960AD6F062ACBD'),(1728,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'29A867228E2A435EB5B098E83FAB5889'),(1729,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'BF0E49DD27164962897E2AB31605477D'),(1730,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'F2046F13400747ADB57821BA597C86A1'),(1731,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'C1619AB6ABCA428BBE2DB67FCA8A3232'),(1732,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'266DAC8CF357407E9EF594744D49414E'),(1733,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'9BE869101F7A4AEA9A75C927C78A984D'),(1734,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'FBE4320644EB4B7C9635A397DFA6D74A'),(1735,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'6561C61E1AC646EB88C22636AA6A1E0A'),(1736,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'2F841EE0DFBF4C82A8D2AFF4619B6912'),(1737,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'FAB2F9E3E32A40A9BC43857BD6B97C00'),(1738,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'E26645938F3545CCBD41E8C1CB3B6093'),(1739,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'2EF993C3309E41BCAF1ECA02A88AE421'),(1740,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(1741,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'B4FD0B66F64345DFB23A25256028E2A2'),(1742,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'1C0CF566310C45FF8F76F7FFDE05B2E8'),(1743,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'04192177F3B2401589AB65735D756D55'),(1744,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'FAB1E10EC3C048BAB84520D159612BAA'),(1745,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'0D4F2426ECB14C88831F56D9FFBDA19B'),(1746,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'4483E7EBDD2945E88054262B69920F76'),(1747,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'44A7015B0C9E4DE7BFC397C4F88D158F'),(1748,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'3227122F1D3B4253937F3AC8BA98F55D'),(1749,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(1750,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'346488CE8EEF4D8D8E0041EA1657521F'),(1751,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'F3E2C829CD3E40D6BD08ABCB539DA5B5'),(1752,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'D47B6D432BF74D69A2FF1B9059BCB0D4'),(1753,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'AC40FAC9FCD94D05ACF7502468A369B6'),(1754,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'66D0990F809C448EBDEF19B59496FFEC'),(1755,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'AAB7B4F0DCAF44B5A25602423671A4A0'),(1756,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'6EC20CEF47054C1C80902F92550C91B1'),(1757,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'62CFC755832E43CC8636AC529CA8CC44'),(1758,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'8510596130264C7FAC98B914569D3B27'),(1759,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'49C7A54A42514EE8972F343F37F799E2'),(1760,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'A6B4F5F0C65442A69501AD63A919AC9A'),(1761,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'69441DA83D0748B38D7B1C1CD3AFBDFB'),(1762,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'1C7FA981148C41C89AF466BDC06FF914'),(1763,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'CBA03C9AFACB47BA99F5C37C46AF980C'),(1764,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'58B9E9AB34CE4DE3B726DD52DCE3548E'),(1765,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'0103F17EE62E497285EC7437477AF307'),(1766,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'92107D02C994441BA78D6475FC3054A1'),(1767,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'BF0A5E73F82745769147CDD7F322FB2C'),(1768,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'F8FB56A58FDB4169AA60FEC42FA09383'),(1769,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'E9952F11B8C3415BA1609A2C27A1F61A'),(1770,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'D5A4347BEE0C495C8AD0AD9E2DAA2722'),(1771,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'7039626842984703B880F302A6610165'),(1772,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'BBD768F6849C4F7BBD3DF8D44014696C'),(1773,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'C238FC3B475B4B1B9BBCD1523BEEA0A9'),(1774,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'B5FE489BDF6B4D42932C9A01C977D569'),(1775,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'C1ED1AE40D7043F19E7D333333FA6952'),(1776,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'DF8E33F93C30440A840D498AF2E4F56C'),(1777,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'10CB3A260EC24B4F9A73F5C6E73E30F0'),(1778,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'A15C848F87C54EA9A608CED45093462F'),(1779,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'C17AA689F2424E9A9AFEB8190FA43458'),(1780,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'2972A4EFD72741BEA09835CFCF7252B1'),(1781,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'5285DA94409A45D6BE4433A67D94AE72'),(1782,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(1783,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'22AA7B46E9CC4FF9A52C0D91F2531BA7'),(1784,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',1,0,NULL,'7096A670872842DF935B5B2A7602156A'),(1785,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'0758F9F59E1946E3B274047C62015ADB'),(1786,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',1,0,NULL,'233169FAA7A244BCA1C4F30FEEAFD4BE'),(1787,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055001','2018022408515511',2,1,'c','17AD95CD9BC54FEA8CF08604C1EF8715'),(1788,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'CF614B35CCE44E79A1259A752F6DE2FA'),(1789,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'DCE44BE62D9A47EF8052023CA5CEA01A'),(1790,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'CFC744FF351F46DCB24368F04E696D44'),(1791,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'6BD84423199644FC957A96F9D476DD42'),(1792,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'334F5C50917D4A3F9B535A64900CD18D'),(1793,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'3788075215A14C04B495EB95BB4EADA2'),(1794,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'E00157DEA9A04A18872B46BE84F13D94'),(1795,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'CE7677332D704CCFAAF1860B7B396296'),(1796,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'1C3D9B50490F42B8A878F3B2DE1D45E2'),(1797,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(1798,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'BA073725DF8C439D801FB1901636DD57'),(1799,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'3A65C6D9B6AD43189E49E5ED6AC319CB'),(1800,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'005802D091E542519BFC003D0E2D2E39'),(1801,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'BAEBC257AB0045FC946236CD71F8AB3A'),(1802,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'393D2E8FD028481E98AFE3DBB036177C'),(1803,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'C3539F7F7BEC4650BD1B3C9B1C7C0864'),(1804,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'99A265F02E1B4F238F1171485A4E7DFA'),(1805,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'0819BE7291624D0C8A8F0DF701EFBBA6'),(1806,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'BB543D312AF84975AFB0615D833A236E'),(1807,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'5E98C9F825FF4370BFA8FADE88BAD2DA'),(1808,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'E81064F468FC4E27A2393FD79F7E9503'),(1809,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'2A2AD3907EE647BFBB0F60B90A9F1FED'),(1810,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'A6B39AED85044B269AD6D4610A5E594E'),(1811,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'1F751F03125F4385B745F6B2A50D4B75'),(1812,'如下哪些不是java的关键字?','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'209D4121BDD74D738EEFF4243D813872'),(1813,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'0A09594770674B909158E12AC60DCDD6'),(1814,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'19F96C702E0F44BBBD84E8A3554949D2'),(1815,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'957A3EE7FC7042F2BC267DBA2205A448'),(1816,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'87A936136CF04C099C2577BDBBF2BE5E'),(1817,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'8F17415408FB486488BC09A48902016E'),(1818,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'6942988593844717A912588376F9CCFB'),(1819,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'5530964D6602461F8FE56F45791A3455'),(1820,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'CF5A8EA158EE4D82BC2DC7CE0084C03D'),(1821,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'D98520CFD5CE47AAAB11563B4F87C1C7'),(1822,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'4D71AB4F57A1439285F72C8F606054A8'),(1823,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'9D8493807AC946228A02780FD7FC48B6'),(1824,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'4C96E244ECFA49BD9CE06FF1DF394B06'),(1825,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'C20394955A17428495CE9F8CE8ECD17B'),(1826,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'83CA050675FB4356BA1E6AA1FEB6610A'),(1827,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'2F0A0E2658D6413F8F964E96F766C6A8'),(1828,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'7E2DD2FC2C3B43C1AF53250B313D439D'),(1829,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'E53714C0994746ADB2F291736C1EB2E8'),(1830,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'B755D9D1A6DE4D39A470D994B9992D0B'),(1831,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'93AEBD5A03DE40A081FAC479B064AA6A'),(1832,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'31565EE2E3AB45B58F4C9032DE5F92A0'),(1833,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'CC3BA4021D4844C997650D81BAC9CDF5'),(1834,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'F7ACC12522434C32982E69D7CB36BB7D'),(1835,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'D393233A19904F8E8C05E08B03A6E065'),(1836,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'068F92537E9A4B6688FC5468D0F4488E'),(1837,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'5D9F07B342374D72BF0CA911D3BE6EF9'),(1838,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'1280DA32B07C4297BAAB3859C642CE1C'),(1839,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'7F35566F68F442FE9FA50A03874BC5BC'),(1840,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'5EA296E0B2394366992630E5E7EBAC92'),(1841,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'54A24ECB2F044D4995E456CBC98C34A9'),(1842,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'DF8196C18EE9474F8F99C73E78C4882F'),(1843,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'FB80C4CC2B504CCB98837EA5F79261E7'),(1844,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'3B126CEAD90A4CE5B172771566B43E58'),(1845,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'0C521B1F840C4F3EA961FA58D9BE1FEE'),(1846,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'A5739E94DBF34F1687AF7D70AF300FD4'),(1847,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'16AD3C14ABC342EEAC474B7FA17118B1'),(1848,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'CF630409634242BBA9DEAE4E621B083E'),(1849,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'1F1B3B43C1804FE288C77D3B11B7B92C'),(1850,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'724408989A4A4E898D0DF3DDB3685C9E'),(1851,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'7038A9A5FBA74724BD51F48683E07478'),(1852,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'B64F2E0D5EB843709E2FF88F3B53D8B0'),(1853,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'5063318F9F8948B98596AA89E3AD5C2E'),(1854,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'F205F4C97EF64B339A620EF65BFEB3B7'),(1855,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(1856,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'8F01E94DAF54499DAE4383F918C5F9B3'),(1857,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'91ACD865B67246608C32C964E6830CE5'),(1858,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'6CCFE1E7A6AC4235A3D92E639F540F10'),(1859,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055001','2018022408515511',2,0,NULL,'F868F017613D4F7B82A520CA53820A88'),(1860,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'A5E650650953487BAD3C330A032F013C'),(1861,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'9FB90ADD96C7406B851262044667F7CF'),(1862,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'16223046B41E426CB0C993521EEFA891'),(1863,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'6990A7987D8245AD9F11ED484497DCBA'),(1864,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'A1268745F6DA4A9FAB5AD49B88B5125E'),(1865,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'B06E364A021E40EDB1C2BB2B1A47DCC1'),(1866,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'0340DBD2C12B4670B78BC4661DEAE63B'),(1867,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055001','2018022408515511',2,0,NULL,'5F5257B93B4F44D58F3630AF24FD7F2C'),(1868,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E5BC17E83BA54CA48A67B6BF02FBDF36'),(1869,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'A49E51747A864D47860F7F94CA02F7F5'),(1870,'如下哪些不是java的关键字?','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'67D91679E8D740CE8D23131E986B98B9'),(1871,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'43E198E4A1C845DA86D244E3D03A6F32'),(1872,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'57B805FE40BA43D689079E43CEF8EA11'),(1873,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'935D4D7675F04902AD85B724B07097B6'),(1874,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'86F86AFFF4D84448820F07C4313BC748'),(1875,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'2717E466A2DF45788B5E66BD6C064443'),(1876,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'0B21F6AD31E4484A9532654AEAE0B778'),(1877,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E4938E9343C948E6A4BAE41860A7AAB3'),(1878,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'14A688A6B6924406AD3C30D2DA0B21B4'),(1879,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'194F09FB279F4DBE83B9782DAB269FB3'),(1880,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'DC0044090AE5417ABAEE336169AEC828'),(1881,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'CD53D7573E50468395B5634A9710DC63'),(1882,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'61909EC7D40B420CB526B272E195196C'),(1883,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(1884,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'D5CAEB569C2C495BACCDC433DCC14F43'),(1885,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'928098EB84FD4F3ABA57355652DA4A84'),(1886,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'4B5DE4AFC03C4199B95EA38BDF6A578E'),(1887,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'761196840F5D4476B24D89CD4A269D5F'),(1888,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'36A9EB0D94274D47A4EF19BFDDAEC728'),(1889,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'79B26A457F714842A53357F13DF013B5'),(1890,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'BE9C100157444468B567804E26A76964'),(1891,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E5F99D16E49B469BA578889CFCADF356'),(1892,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'EC5F649DAA6748B49457A45A601FA813'),(1893,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'3AE6B81417D6476EBF61BC82076D5698'),(1894,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'29746DC6045D496E972A7B96F4107EB6'),(1895,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'7F0C627CA34948A2B8942AD79D22CF32'),(1896,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'69F7B368E6BE41C38AA333C2E74AD035'),(1897,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'A4D1DB4FC1D641F293D5CC464C3A608C'),(1898,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'0D16818191AD453F83FDAB28311E034F'),(1899,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'5586B0C5CB3F41779879421F4CE69399'),(1900,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'EA0F993F3CA54470BC757FF6F559BEA3'),(1901,'如下哪些不是java的关键字?','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'751A2B0AC1BE4919996CEA697AB29521'),(1902,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E6AD178C63D44DA198487A72EED38CD7'),(1903,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'66E71A5906264466B87447349155B456'),(1904,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E4CFC7BF9B57444CB207F9F36A2F6ACB'),(1905,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'74480B5FF4484EC09487846A4FA60717'),(1906,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'C2423B5C7C33457ABEB5D0A439C82F88'),(1907,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'6140A62F4AAE45A7ABACA83DB637257C'),(1908,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'99EF76E7F10E4CE68AD0A1711B37EC55'),(1909,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'A0E1E56613CC4668A0FE03B27E9C14E8'),(1910,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'FC0C5DA4DB8F4141ADA9830A215C057A'),(1911,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'6BE177BBFF0E4ABEABA97BC51777CB83'),(1912,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'5B5044D1711646F393AA34C88E289DB8'),(1913,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'6FA04AFEC120404C8B84708512AEE940'),(1914,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'4B00617DA3424C7B99336C0321831570'),(1915,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'8080D48D9EBE464FB7B73E956E6DB304'),(1916,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'2B31095C9C1C4E2DAA4172FC7F6ACA44'),(1917,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'09D480AD5FF04337906A6E7D7A658245'),(1918,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'62051AC20C474638A6CA94B1FBA93403'),(1919,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'0482AC0B2895429ABD8E9CB09D015E65'),(1920,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'D66FA56B06B04BE9B32DEA5E58E2FED4'),(1921,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'555BA336AA0B4412BC7272BE86302EAD'),(1922,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'D23940DF31ED4F84A2899E935A23A47B'),(1923,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'1E8E933476994B3E8C31EF93422AFEA0'),(1924,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E5A0C168BE6A44EAB8889AFBB8DE39AF'),(1925,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'D2B6F35A17FD413B97CF9B108CF38544'),(1926,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'2A7DB67EDB684928BE0C454EEE85359A'),(1927,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'B305E418F4344DF681BC6C41E396E194'),(1928,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'A8F3A84FB9D24DBA9F3CCD662FB83276'),(1929,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'BD59E94A4A124D91B9DB53A687048736'),(1930,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'70C9693B2A83415CA15636E86F65F20E'),(1931,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'6C3ECE66A4FF464CB7B5ADE82CD681FD'),(1932,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'5A50AF5167B34895BA1BF4013B63E747'),(1933,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'C66DB560147540D99E9D2C5B6F0BC376'),(1934,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'82E0210594EC46A5848C1B362B536CE5'),(1935,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'37586978D0294F0DAA4231CE74C06683'),(1936,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'F5426AE44A5C4860A30479E132E46E18'),(1937,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'490DA59D0137492A861B57122BA8DA6F'),(1938,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'1E7C2D0B63784F88931528EE277F602D'),(1939,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'E06613DB0F054BBBB004FB1AAABFEEE8'),(1940,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'A9C7552E2D7D4C45B9B77575AD986857'),(1941,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'24963641377D4F89B083907A7F343AFF'),(1942,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'615A69A631C24BE2AC9947A98C6F1C7E'),(1943,'如下哪些不是java的关键字?','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'7AE249ACF24446D5872457CE801B0355'),(1944,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055002','2018022408515511',1,0,NULL,'58C23496BB8843B69A883398E0666360'),(1945,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'B9D38B1692174AAE911A2663EBA55B3E'),(1946,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'2808DF9DACC946E5B69D29FC50C9AE06'),(1947,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'ED1902732A55443387CD472B2244A72E'),(1948,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055002','2018022408515511',1,0,NULL,'58CCA5BD668A45A38AA01FC7E3B34650'),(1949,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'5B51CC93D8374AEDAE510DF336B2986C'),(1950,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'9DAB033452A947F69CB8F7B8C724EFBD'),(1951,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'0162C6B4758F4301957E58DB6299C09E'),(1952,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'431AFF560A084AC3AADDAF4D839F3E47'),(1953,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'30D3D89650C147FFAFCEDD4522C7EC8E'),(1954,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'3B18185C2E9640F499788DCA1EF71D57'),(1955,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'D12253BBE2B84571838E5E6A8EF6BC3E'),(1956,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'73DE660E898B4424868C66C4E4688BDE'),(1957,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'BA7D1A7853BC4A22ABE081E19E6371D2'),(1958,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F427B9E419114FACBA2D06B270A68270'),(1959,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F6BB47DE9483475BA440CF9DB19F8F2B'),(1960,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'4BC7C14FAA004D69A8EF08AE37534177'),(1961,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(1962,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'6479075EA97B4130B1003BF9DD4E1BDF'),(1963,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'4C5C9360A6FB442E8AF629BA3BC4A3F6'),(1964,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'7D253EA3C6E14AC2931F9D45D998156B'),(1965,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'98C95E20A931459A92A89055D66DAA19'),(1966,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'E89FC25CC66E49BAB7F8CC07F67E2B91'),(1967,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'8244B24B35CF4DD9937649E6ED85B4C7'),(1968,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F6B9D863339A4C8E88EAD26D013B3A7D'),(1969,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'0574B3F614CE42618BB2349DC59194C0'),(1970,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'B85CE9E7145F421CA73FB1A532AEA310'),(1971,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'6F5F15FED99C43C8BF9ECFA906C5B75E'),(1972,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'A1A4355FD0414AA0A12F505A830220C7'),(1973,'如下哪些不是java的关键字?','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(1974,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'525D29DF70614DDB84BDF6F37921D8FD'),(1975,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'53BB7CA57C7243A5BE54B14738A2C030'),(1976,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'6937E3F700C64B789B08B27395A063A2'),(1977,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'89A2D2E6BD1047B28CD40481E8FC98CB'),(1978,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'2B749F30FF0848ACBD1B1C0CA3FF6032'),(1979,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(1980,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'922059CBD4C241039447BC256F0E9FF8'),(1981,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'FEB88DB5421546299B9FF7F0DE93BD95'),(1982,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F937F52ABA8B47F08B5E6B8A7F05D777'),(1983,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'6148A72E4C69455782527585ED19543F'),(1984,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'9FE4B37819814AF8AFECADE4680F335E'),(1985,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'826CBDB7A0374BCB84CC553D72491909'),(1986,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(1987,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'BFFAC648C5384E74960708396A4835EE'),(1988,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'AE18609B5906462A8668A9E28387B319'),(1989,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'4723D32BA83547BEA3D79ED8247C854F'),(1990,'如下哪些不是java的关键字?','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'EEC6D19D21CB4732BFE0707749861851'),(1991,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'3A8265F8E32E498C89567B74996CEBE1'),(1992,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'B46844E54A2147DC894F3A2F23223534'),(1993,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'A844893EC77E42EEBA0D6A315CF5A1A8'),(1994,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'95061B5665CB4E1A8C0BB901AFA78146'),(1995,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'79E40BEC55DB42219CF0E315810464D4'),(1996,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'1A40D359F56745CDB555C14820545EFC'),(1997,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'400DB2E46156492385A1317A5FCA549F'),(1998,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'297A9757DDF349BFBB5C483640BB7696'),(1999,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'076CEFB0BC0F4A7481FFDECEA04F491D'),(2000,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'81CBC08D8E5241BCA53AF8A7C46548BC'),(2001,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'44DF84B88590415EBF1268A084313CB7'),(2002,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'1FD5ECCB2E04424F918D815922BE8B16'),(2003,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'3D623D9B0DFD44AEA19510A6D05EF7A1'),(2004,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(2005,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'156E8B5E7C93431FB792453C2D6E9D58'),(2006,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'6DD3628513804EB78FB74DB67E45D1C5'),(2007,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'60463487E503402F90BCB9AEDDC5D99F'),(2008,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'9056957ADD494F589B146903CC394E98'),(2009,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F1C398E465994CE79819D3F1B1C5D711'),(2010,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'F6A089E2962B4732914FD841EEA27C7B'),(2011,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'BD2A0DB0A458476282B9FC3F1ED7DB8B'),(2012,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'7664BCD2D103432D9C558937F7F5D191'),(2013,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'DCB623C8A76E41DC816C8BAD2BB2CD59'),(2014,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'7D36760CBC1440D69A36DF89FD013338'),(2015,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'98D182F413794EBA91A9FD3F82687B21'),(2016,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'DA5A4B2759DE4F0FAADED9613E2CF6B0'),(2017,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'13FF147C440340DA91F44B48100BE441'),(2018,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'9BE7926A8D324EECAA919855688CFB7E'),(2019,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'986C403E14304F7681AFEC508B7D22ED'),(2020,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'D748D3A247074CB8A7A9CB435DCD7B8D'),(2021,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'AB8D8CDCCF734AC4A27E9A32322A5496'),(2022,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'D4F8F230BA3A4E2F8A56A91524D59A2B'),(2023,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'5233EDE8FDF745DE834CD083CC59E1E3'),(2024,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'3BC8A89BCE1746088FEABCD2902DD7B4'),(2025,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'CB4517418A7D4638A670C424823870F6'),(2026,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055002','2018022408515511',2,0,NULL,'2492AFAA298E4BA4AD1F3075065F87CF'),(2027,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'821254307B414DA98D8E60D2B0D0F1EF'),(2028,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055002','2018022408515511',2,0,NULL,'FBEA8FADE35345F3AF5F5F0574DA5002'),(2029,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'DDF25A56E5C14B95B5BF19E91728E051'),(2030,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(2031,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'D81102D7D14241F8B371716B0FD4859A'),(2032,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'794BCCC1DBEB45518A8D0363904E0C4B'),(2033,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'C705F7FABB504D9BBAF826DA3D21E59C'),(2034,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'41DE0D476F494701B834BBE012FAFD78'),(2035,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'41742C6B9CF94E5781F45D0F061055C7'),(2036,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'C575292F078447AD9941B6E6E42F0806'),(2037,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'C99E82801F1E45F086DE9F96D80C993B'),(2038,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'B4EF7856980E43748E7B9859F808E67B'),(2039,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'E2AFBF3B95694022BEFE20EC4C7B747C'),(2040,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'74260B92A33447CF9FDA8BA2E2A685BA'),(2041,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'3CA7D367EB0F4607A7DC39B5DE62EFAA'),(2042,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'37AD758E189C4B4CBDE223B1FB7D61AB'),(2043,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'0752EF6EDDDE455CA6C49863140CB513'),(2044,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'94D6EAFD46BE4F4A9118805424CEAE15'),(2045,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'554F8738DEC2458DB09FB66BA804C373'),(2046,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'55503C2075384150A0659E86B2B4D051'),(2047,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'82E933EC76DB4F0CBD957CAE393EC4CB'),(2048,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'E8271D4DD51A47F194BBFFED7C32E7EF'),(2049,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'FDEAEEFB35D24043BB41228EFDB76CC6'),(2050,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'2D439F41FCCF4CFD91ED5028D3A3F38D'),(2051,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'264C6D0D5C0E4EE99174003E5DFD1518'),(2052,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'542393BDDF05480EB13913316E281D9E'),(2053,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'B5A0BD7BB821475EA9EBACF96B2BDAEE'),(2054,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'3A42BE66869346008A79E67FFD6DAFFA'),(2055,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'A17978990F384C2A8561854648E23BA3'),(2056,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'6B969D3F35E54FF7AE3FF917E75B43C3'),(2057,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(2058,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'574E332F6CE849C38EB921C4BD14EDE4'),(2059,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'08CEF9E8D3794A60B0E2BA898B4D0372'),(2060,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'F94B004065BE4789BE003DDBA9E5A7E1'),(2061,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'E4E4FC0713AF4C38BDBFAAFE1E270F05'),(2062,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'77E24907FDE74C0EB6352655D741202E'),(2063,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'32F637F4383F4B4D9F732FFDFEAE0241'),(2064,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'2123A75041FD4CA497B8EBBCCE055F3C'),(2065,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'689F9322E20C4CA9B8F9CFCD95B4CEED'),(2066,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'F682AE42507E4309BECEFD302C366344'),(2067,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'7A1F95C5B0624DF699C792459FFA8EA5'),(2068,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'98F3972BF354428297A1CC43A6285CE5'),(2069,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'D21C46A2C9DA4A79ACEC1076F926122A'),(2070,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'AE336B519BE94C9EA807AEBEB2FE34A2'),(2071,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'52B2DA7003194018B637440BB6D5117C'),(2072,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(2073,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(2074,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'6C821B72A9E34DA3B8EC452A28BA8DD1'),(2075,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'40021C153BB641B9A9DB258639614CA5'),(2076,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'81DE7B424655498DBE033A8DE42BE687'),(2077,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'23FA63D45DDF4D34B5385DFE651B0704'),(2078,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'DAFDF3AF99734E7D9C59FF42A763FA41'),(2079,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'A564020B59D84B2691A011045C3F1E8F'),(2080,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'65FE9164C46042FC9E5249702D2DB01B'),(2081,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'950D0F13630F413E8AC7C1204B8BF3A7'),(2082,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'FFDE9803781140E3AB49D331BAD62C68'),(2083,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'7D356A076A924E8BB828CC797A02E772'),(2084,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'26D1F529943A4563BD9F9E90072998BD'),(2085,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'435FA646B2DC42C491410E5B3380E9B9'),(2086,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'37D7BA4ED95445449703BDF24D75F468'),(2087,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'CC5D1A99998A4A6283EB1401734E0928'),(2088,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'88832E08CCCE4FAF989D4AC973C5287C'),(2089,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'3AEB1FFADDBD46E188F3DC98EBAE5E13'),(2090,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'19747CBB70304669961950CFB1930E1A'),(2091,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'C70C3434ABFC4EE19B5EC06B8F7C59FD'),(2092,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'4AB398CB7DDA459A88B1E1F57E3EC6EE'),(2093,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055003','2018022408515511',1,0,NULL,'D95DDC8A41EC44B284C6EBA47DA05436'),(2094,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'F8FD938EC2B744149757D0BD8D4EA614'),(2095,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'2BB702A78FD644FD8AEF5B13EA24AEB9'),(2096,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'E53765164D154D50B8A656C344ED1622'),(2097,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'C3BA7DD5E21647FC9CF238D991B6FAB5'),(2098,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'887695A4D51D4573B31901AD8FD3DB14'),(2099,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'6DC12F24337F4978B6BB3B6F29039D8D'),(2100,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'C31F06002D4C4FBC80175DEEDF52CEF2'),(2101,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'430FE9095C004F3C9109EBB676B1279B'),(2102,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'43446A3C28F645D4899221ADE47FEA60'),(2103,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'BED615F09A814F769EDD8CD78CCD3DDD'),(2104,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'7D8F6FAB08C247069D94717924151EEB'),(2105,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'CF41A0C354414167906FCDDB9290B8F4'),(2106,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(2107,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'8354BA5ED5BC4B3BADC817F11CD9F351'),(2108,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'7D2CB2D41DE946918514CAFDAC4C874A'),(2109,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'0D7CD7C532FA4B2692597B598CC88D28'),(2110,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',1,0,NULL,'47FA650F96204794AD1916AAA6191136'),(2111,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'EA30B5319DE74B6181E8FDBDB8D8DFF1'),(2112,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'2BB4C85CF8844AC3978033DBFBA7E9E0'),(2113,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'13F6A99EF75F45A4827E6C2A75E8323A'),(2114,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0A291639601848D282938F42AB2D373F'),(2115,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'7936CE192D814BD68328C4B805823371'),(2116,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'19732F19153544BC99D4DF571B059685'),(2117,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'BF2CB74919AD4E1A950C0FFAE4423746'),(2118,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'8C168A6DCDAA441F9997C7B0429067C5'),(2119,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(2120,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'853DCDBAFD7D4B2CA9140691ABC4C7AB'),(2121,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'204884AD6616437CAA06B0071FDFEDBB'),(2122,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'32E342CE591C48019499D242A3FA141B'),(2123,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'BE7FA24BD9BD441C9947856D2F4B801E'),(2124,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0DD5F77D69F24CACAD16D51259D3F97E'),(2125,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0A4B0A882BC2498CB5A8C5845736C3E3'),(2126,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'A65E55C923E845BC98A71E9BE8EBEA27'),(2127,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'96FF1B8100254758AAB61E730FD504F6'),(2128,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0D05BD35FE5545D3BC9877D30497B5B4'),(2129,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'907C812FA29743DE9258DD4AA75B6891'),(2130,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'041C2D9C292C4FECAD356C628C2B8855'),(2131,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'DA579D4B61004E4A88071217B0FB4681'),(2132,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'FE19B8FDD9724BF780886C6EDF2C7240'),(2133,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'D293EF3344AD4743BE667BB79C071145'),(2134,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'F79726831AE443149EB651B6F4F78D16'),(2135,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'8D9A63138EA44A47B84637D046B6BA91'),(2136,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'DCC0D546885F4B07A136BFD5CF9F57B3'),(2137,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(2138,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0CFB7FD544D84AB1A433142DFA272701'),(2139,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'E83CD3521D0540348CA629BAC36804D7'),(2140,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'097B62E438D94105B8FCE64516C33069'),(2141,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'EF5406DD1DD744939057A196EC0FCB1F'),(2142,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'4F77CD575E454E66B99EE8C15A780674'),(2143,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'3E55703F094C4BFAB71A559D13724FFE'),(2144,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'9F0524B08DF144BC8E21C006E2771259'),(2145,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'FB073C05A26649329FC7174BE0CA8E2E'),(2146,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'797EA301F2AF4F37975671368F236DDA'),(2147,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'884B4A3D383E4306938818C273AF6123'),(2148,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'5569AEE989CF42609F70363B716E0C64'),(2149,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'AEBA258A696F471EB84EBC30553BED7B'),(2150,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'6B94A3FA4D5743A7B7746B96DB3223E4'),(2151,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'B66C451B0C584D2B9DBAC960B7234C0C'),(2152,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'F374A49AFCEE4993A9756AAE19F91B17'),(2153,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'C7B7826850B846118206DD1572B168E5'),(2154,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'58088E2E412B4F9C8A86A56843C9A9F7'),(2155,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'AE62CF5F9D57434CB529E8B7C188FBB9'),(2156,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'09728B5452DB479691CCCDA46B7C13E7'),(2157,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'19D4308477F6464E90C6D2E8AA5CBE2E'),(2158,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'1433B3C90E23486DA1986A75B5ED0685'),(2159,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'D135E998EF8D43D2AE2FD74BDA287FFA'),(2160,'下面的哪些声明是合法的？  ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'38B1663D58F9473496D5D20D5B61441D'),(2161,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'4B5F335108C2491C864249A36F08A567'),(2162,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'33E7132926E344638BD380C1AFF7C8FA'),(2163,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'8805EE75C60148CF978F5D33F149970B'),(2164,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'75C06802E3FC4EDAB9DB7B421402FB4C'),(2165,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'31F7E98361E84D189A1A91270E6270D2'),(2166,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'B3687DBC3A124A1E93FFE261520FBE3B'),(2167,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'8674C4EAED544AA8B644D6B5988BE841'),(2168,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'F326B4B5824643C3A4F74EFF485A9198'),(2169,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'557A9CA3EE784D4189D909524A3ED3DD'),(2170,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'AAD8E50F58E8414AAC5F8DFC37AC1E78'),(2171,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'B99EB7C3639A431B9A0B97C75DDD3F8E'),(2172,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(2173,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'3D3BDB177B4840FAB0CC1D41C6DB074A'),(2174,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'3CD696406D1A4919B3A9A72B428F13B2'),(2175,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'8325DCDE005942F4B3968D2C90A6821E'),(2176,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'6D24A5C9A32A40848E83F2320AA28A1D'),(2177,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'DCE4EA8707424C63ACB7C09B3590B279'),(2178,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'BADA7322AF1748B694766B7D43309A92'),(2179,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'EC3E7DB0643E459188D39940E6A234E3'),(2180,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'95E14927E2334FDFBFCC880871CFBE4C'),(2181,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224085100055003','2018022408515511',2,0,NULL,'46F33D21A68A4A2F9DE5B1B2EDB571A2'),(2182,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'78F9B177E2EA45389A83958891DAEA60'),(2183,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'6DF46658B6494DF59A3D0C9B4CB4D58F'),(2184,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'3DF17A806C6F41A9A08424F8620C9160'),(2185,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'7DE0DD0894B54C11B0C15E7481A1BBB4'),(2186,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'0D37714BF0344AE6B78C817AB34A0560'),(2187,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'100C13CF364441F79259E88CA9EB59FB'),(2188,'如下哪些不是java的关键字?','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'3689E90FE66040E1B6002D67BA4CC19F'),(2189,'下列关于栈的叙述正确的是   ','',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'51740FDB8AB3453194FA79410FD417BD'),(2190,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'897F8E63F86B4F20BE4025B254FE4EB2'),(2191,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'7AF53BC6C137409BA5BFCBC482135683'),(2192,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224085100055003','2018022408515511',2,0,NULL,'69F5B79B55AD41638CB033E7BE0BAF4F'),(2193,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'CFD648F1A75E4FB499314B6C254AB00D'),(2194,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'0B75C0F0F2C9471BA54A29B30AA19987'),(2195,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'0D990B41618C4E02907669182389572F'),(2196,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'36151239BBC64E30ADE1091FA360E3B4'),(2197,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'3EC715768B6E459C87D684C3D10B9192'),(2198,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'76E50FF39C054726B3513B2900B893C2'),(2199,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'12367529D8EC4FBDAEC3F52C47BE3FF9'),(2200,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'E7DCFB11C80C4BDC90E0AB3B77CDC761'),(2201,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'6CF08D3C564545C596C5CF7DD8C808F6'),(2202,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'F614748966A24A4ABE09982B17613B12'),(2203,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'CCE040334B144163A85C501736D10707'),(2204,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'51A97DC8CFC04E729781BA052D62DA62'),(2205,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'849C1AA4560E460FBB7534B24D6DE56E'),(2206,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'A31D67C5C5A04E209505E4839BDDD44B'),(2207,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'1507F6D2A79D4E118DFB24858D224EFC'),(2208,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'71DB815A83274531B7CEE78097091E79'),(2209,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'343A11A1AC9B41009AB07A05A321F264'),(2210,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'6B22D9B6238B447896FD44AC7E9DB385'),(2211,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'456FB5AA7C1849EABB961A1F7D79C518'),(2212,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'05A44F76F5B84BAEACBC73BFC01F1451'),(2213,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'C1318305A2E441DB822CD1A097F58874'),(2214,'如下哪些不是java的关键字?','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'9C8A1DAD051849C2816DF4B739FA6942'),(2215,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'056BD98C07154426A296D11E86A01CC4'),(2216,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'A8417123407C434FBC4B4E8B4CA0B609'),(2217,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'826F7B4B344F4FA2A85751D96C49DB6C'),(2218,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'782795B974B2436284C2EC9917A3ACFE'),(2219,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'40794D1645CD4A4582B24ADB351537B3'),(2220,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'A24DFD9699CD4BC39C1D45A5E727B9AF'),(2221,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'7A6E0F0EA26D4262B238329C00AC5511'),(2222,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'58A2547D3B994BDC8FD48111791C9572'),(2223,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'4A7D76E2E30E47379C991C09CA22489F'),(2224,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'36058E13DB6B45858DF2D464CFDDDDC5'),(2225,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'C9FF3B79499E4753BB612FCC437A817E'),(2226,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'D54CBFF879384DD09D786211A8D5003B'),(2227,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'31B0BA226D13454D90050D4961110F9A'),(2228,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'3988954DE6094D0A99A369FEAC5DA692'),(2229,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'2A0F921BBB90462C8F62E70DAAC5F00E'),(2230,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'F7401A00985740DFA5208DDACA2BED4A'),(2231,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'DBF269C2D90743078334F7AC0AF668D3'),(2232,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'9FC31EA4A8E146E6A3546957CD13E96C'),(2233,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'F358507CC32C4B0DA17C6F6F02D32D9D'),(2234,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(2235,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'D83AEEDBE0E64DFD8B35F8AAF404B54E'),(2236,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(2237,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'B2A14C45157C4792B7474B18A8B3025F'),(2238,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'DB89A81F42B645C7B7755F3E15300D23'),(2239,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'01AB7988D33E48F4BA19741AB0E71572'),(2240,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'B058660D59B548CFA3626F66B41544C3'),(2241,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'E72611F9FC56437C820D9C4762F6B98A'),(2242,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'919334B660AC4E09AEA4461628F3135B'),(2243,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(2244,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'2400C908F76C4A38B55C77D6642160CD'),(2245,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'4C152C4553DA45349B9C2C73FB085A59'),(2246,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'C56F058D5A0E4B4B80476A42B8819613'),(2247,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(2248,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'57F223C050484D9580B283D91EE42A59'),(2249,'如下哪些不是java的关键字?','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'6D5ED0C2A05841489C4D33C80C041A9D'),(2250,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'9CB357F050764DB28B6FBE740AB5CD98'),(2251,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'337BD57A3C814928818FAA8EA5332F2C'),(2252,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'48A3077A348942E680282A6D5FF62CD0'),(2253,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'EA2AE8B2158A49AEAF06D52C8AAC4B44'),(2254,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'08B2626E55054529AD02C7E5F1573F56'),(2255,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'56CC5B59FFE54E759CE1131B9BD1C6F9'),(2256,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'69AD3CDE36DF45D59D3A27835D7815EA'),(2257,'如下哪些不是java的关键字?','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'FC120AE84877414AB4DEBDFC3A68C9D8'),(2258,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'38B1680643D1402A8C3209D857BD75B5'),(2259,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'A4570309855B4DDE9D20BFD8CCA90232'),(2260,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'00BFB07A88334474A11C494379F9D47A'),(2261,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'2E8B180D59174612B80CD3B976FE3780'),(2262,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'BB1C3CA8285947B7985F7943A607BCAF'),(2263,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'D88B4115C8E042829068C9F9925DB871'),(2264,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'69CFD1EEE73C4F99B567D022FBB2D9DF'),(2265,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'C9FFCD49E7B5491190A4BF252BE91FFE'),(2266,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'E3E5206AE35348DD9A32648BF70F78B2'),(2267,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'B403973A869848F983231EE84C8BADC4'),(2268,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'380A732D59B54AF59C6DA8916B7CFF12'),(2269,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'2D96E3D9FF08496BBF19491D345909F0'),(2270,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'CC57E02B65F5457CAC7E99A9EA5FDE96'),(2271,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009001','2018022410560811',1,0,NULL,'473F363F30CB411DA28F2B9646502AE3'),(2272,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'002A1E80FFBF4BCAB32159B0C0C2347F'),(2273,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'30491B50AF2C4181A623CD69BF22B5E8'),(2274,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009001','2018022410560811',1,0,NULL,'EA1422BBF4B04045AFF8AAEFB5253DE4'),(2275,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'0D72DF82DA5E4E27AFC1C4C12001C246'),(2276,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'BE764AB8E1494296B05858C2E013C09D'),(2277,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'1A020FCD7B0B4E13A23A493FADA22FA2'),(2278,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'DABA85128E00448FA65E10FFE7AD7CEC'),(2279,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'869EE067DCA64D82854C1E112F89E100'),(2280,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'11212DBDD1A44058934324708EA4D36E'),(2281,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'363F2350E6EF415DAF2ADC888F91FC36'),(2282,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'F2D0D99EEF2A4E5193051947648AB39A'),(2283,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'611D4AEC80094769AEAE9C4BC95D8881'),(2284,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'5AB184E5D8B847BAB42E4E157895D4D8'),(2285,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'1EC1500ED4074D7B8C30FFBBBAA6C04F'),(2286,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'F2E5C52372504E2B9CDF61A9A63A209C'),(2287,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'51F51B0BDA244ECF92D31C95F19EAA5E'),(2288,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'A1017607321A4A5EB2BE8680453F80D5'),(2289,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'07053EEADBE04BEBB398F2D483A70F99'),(2290,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'68CCF557034442B281878CF9E6BFD4DE'),(2291,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'5A933E2EEBBC4A229559620E98E90B90'),(2292,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'B12C8EC45F3545FA82803E97CC85D14D'),(2293,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'532107F14CC54242AB262B56B8296256'),(2294,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'761BD4B1E7414414AD58669E18B4DCF2'),(2295,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'3E02A49E8BEF4AF697DC269A35EFCCCF'),(2296,'如下哪些不是java的关键字?','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'260768D9F1034266916A21BABAD2523E'),(2297,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'E20410F206D74944A4E8666E35938B8C'),(2298,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'8603F7C70EE14A2FABEDA2B3B16B6690'),(2299,'如下哪些不是java的关键字?','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'0083C71347CC4797AB96263E4185F889'),(2300,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'CE32D8F81A3A4799891423AEE1340405'),(2301,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'313E2F7B9922463B88BF759DEEBF2A7A'),(2302,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'1624520090D94AD9B15CB097BBAC75BA'),(2303,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'BDEF71151BB541A89958AD77AD4FADAC'),(2304,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'2B112C8E4CCB408084F3C8693D04FDA3'),(2305,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'E7A1E270F6524A3A972760128DB50840'),(2306,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'07EB2BB685EC44C8884849B912F7CB7A'),(2307,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'321F2A7F05F24E6597D4FED785B45242'),(2308,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'D097C02401F1444CBF529D9790BE4D77'),(2309,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'D3BD2E6097594BF6897FA4773996D18D'),(2310,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'38FA66E9834D4302AB1F526F0CB6C64C'),(2311,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'8719133627C3459B8DA46936379D3E79'),(2312,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'6689209CD93F413C93678412C34B4E70'),(2313,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'89E9C70714B04A18B1C300B2FDB5D7CF'),(2314,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'EADC8D24941E4F16AB713B5517F13B32'),(2315,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'C47CB190F06C47EA81265325F6C27490'),(2316,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'C7D9906B8C6C497DAE70F6674253F880'),(2317,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'721E4B443AB245538B65D16E7081D393'),(2318,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'55C7DEE9F0DC491797A5C5658FB1D231'),(2319,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'6105CCBD5536476792F6E35FA318F00D'),(2320,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'5B9D54CCE7CE48C1B0905B35DACD2F64'),(2321,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'5F5B20CD56B849D980022DF0E5B9F388'),(2322,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'B4CA7B491A94493094E3C9ADCF6E6C7D'),(2323,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'9BD1404A37234ECA826E696291EEA8C7'),(2324,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'4EDF44D4038B401E893CFFFB525DAEF6'),(2325,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'AEBA9B7D3D4D41778A14BFA9821E7FDD'),(2326,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'C0C7F2C266A9444C94EFE8C101869FAA'),(2327,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'55635C9C01044E2E9F98AA5188D7A798'),(2328,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'FCD456FE19D74DCF870577A64775F01A'),(2329,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'385356F3A7B34BE99CD61E859A40CCFB'),(2330,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'A3AA8B2BAA9B4ABCAD8016754B27805F'),(2331,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'34FD832E1C674363BC6A484873D625FB'),(2332,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'BAF617ABC55C451B848D8BA7831392DA'),(2333,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'4AAC582906B74BA7B24E8912C307E761'),(2334,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'E5119048041048BA8FD71047961E2C13'),(2335,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'83C621712001443098043C47D3CA1B93'),(2336,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'49B8A0C78E3D46119C60500AE935AA9A'),(2337,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'09CF76033C224B3B81F30BC17455DA12'),(2338,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'042472B1E50D421F86E921B1B7EE1F82'),(2339,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'6D71DC33FC6E476EA47186F7CA7FC016'),(2340,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'C38A8CF0A2084E658C518CF1617880DB'),(2341,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'586E65D652464C2B94F87A6CA6FAF00C'),(2342,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'7042FE042FA54970A3ED2B3A236558A1'),(2343,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'A5A168F938A64E85920ECD9A2F9A6B69'),(2344,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'F5DD3F49C76847B09CBEA42BD9323B3B'),(2345,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'2E6ACD1A03D1404197ECD3972F7E6B88'),(2346,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'A940442C9A6747A1A96FCDBE13F4AE5F'),(2347,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'9F204C2DD5224C92B44B14741EDD5988'),(2348,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'E0B30D2F47E842BFB1134BE11021AA61'),(2349,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'D01E062FAC054FCFB0AD66A7B61C2B40'),(2350,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(2351,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'F2E0C6ED9B474867AFA94CCA2F095F2E'),(2352,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'FCA04C0045614350B3402FDA90B58777'),(2353,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'6FF06E61B42944F8994D8AA47CF71681'),(2354,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'76D31335BB6743518A442A1EDB033B4D'),(2355,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009001','2018022410560811',2,0,NULL,'FCEA2218EAAF4B96B857416F87C7E646'),(2356,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009001','2018022410560811',2,0,NULL,'00AACD826F4A4DC9A8DAEA3F69A9DC78'),(2357,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'25D1744CEA2845109266340BB9E5B7F0'),(2358,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E5212F7F4EA94EA3AD2695433FF75151'),(2359,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'82519CE2251D4FE2BDD2DC6DF86E2A0E'),(2360,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'833F382A883F48CAAB42D61FAD7A9C3C'),(2361,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'C15207E7452B406A8346FC84FA8B600A'),(2362,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'10C92B8730C848249813116A972D3351'),(2363,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'6FEA99C5CFF04D7FBF84C69FC85536B4'),(2364,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'5418643DE3974F9B92BFF27FEC134C0D'),(2365,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'68B15C3DC2D843A2BEFD678C72D5700D'),(2366,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'836E0657B0EF4D3FA87B7246E3E5D1B8'),(2367,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'587FB668F67C426AAF46742C2AEE85BC'),(2368,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E11D352C3A5B41FEB3FFD4993593F09C'),(2369,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'31EA8C2AA2AD4E77ABF8031A027DA4AC'),(2370,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'BFF7FF82F64342399FF27D06BB8430A1'),(2371,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'3F1BA41B9D884B8281C390CC84CC4099'),(2372,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'099AEDF7DA4F442AA7C83489588EF4CA'),(2373,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E6A8E448B14A4B51B68A5D6DB552D2CB'),(2374,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'40FAF9EE1CA34B4897823CC919830A13'),(2375,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'CF3A4A97B1F049F28301E2BF6D77FC69'),(2376,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'D0AECE6F725141C8B87EF739D8FFA824'),(2377,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'81C05B163FD341698EE3315AE8DAEBEA'),(2378,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'1580B09A53B2421190FD1956925C0EE3'),(2379,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'DD89C18AFABA42FA92E65DAFF569EDB1'),(2380,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'06589A904E3944C19374F445C3ED7C5C'),(2381,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'0D99252C648A4578A8089E982BCD8331'),(2382,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'7B76658AA67546F797523B33605421F5'),(2383,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'C3F081DDE5F54FF0AE3A2E86173F5AD6'),(2384,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'EC30AFFCAF674872AAA22936E6C1ABD0'),(2385,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'D6B319073120466AAD0FD53565B7573B'),(2386,'如下哪些不是java的关键字?','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'A06DC45F726040989335C1E67A96EDB9'),(2387,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'CAE89907A4C84839A8D14281D2EA93D7'),(2388,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'EE500293852D44BB96FA44B02C49240E'),(2389,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'B2DB8EEE147F4094A43B46C6FAEC13C9'),(2390,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E8513B120F344F9D8F71ABDC795D8089'),(2391,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'890DF060C28D479EA02CAECB82B57EEF'),(2392,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'C7D85EC8A9614BBFB89DED4988C6BB59'),(2393,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'FE8C619C1F57498CA1715384B824FFC6'),(2394,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'AC726D85E28A4E6C90451508591C83B4'),(2395,'如下哪些不是java的关键字?','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(2396,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'CA9371AC226A468CB60FA0F8872ED2A1'),(2397,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'18A4504BFA7E4804867563234764F3C4'),(2398,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'6BCB57D0A7F84F27B3C4E6A852803175'),(2399,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'9806288D7CF14AD4888AE7A6B4C1D4FC'),(2400,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'3AFD96EFC3A64996BB8244B58989D188'),(2401,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'4CE57B2F42C147028A4287A6226AFC2A'),(2402,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'18888E5C88D145729DE1207DAA84C86A'),(2403,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'636BFC576A2B44E592BBE8FA2AF21612'),(2404,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'8AA8059A98CF491C9243AB13A6FDDECF'),(2405,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'828F2870EA394075B9477E3D69B4320B'),(2406,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'2E187FD1394E41C9BDD608AC338A6A31'),(2407,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'F72E94DC22BA4393861DA5BB949FA9E5'),(2408,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'B6A9C8BBA71E4B27B0882FE8436C979A'),(2409,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'8AC157A0E68744408824363480E9CCA6'),(2410,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'A3C4A7BACCCD4E86935D4F075C87D4E3'),(2411,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'0B7152F46F78437C8DADBECCACA0EEFF'),(2412,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(2413,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'1DDC15491A174F9B8B40E3650FE6168B'),(2414,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'73CB3C7F6D144A35B2958AB3E7547493'),(2415,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E7C0DBDBDC144904B18929C1CB357027'),(2416,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'445DBA57689B4DFC90E19EC07DD1A756'),(2417,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'4210953AF462433EA4A369E1864D8090'),(2418,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'D93A487FA268463385013B6FD70F52CE'),(2419,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'9F5E5121F7964F9093E1026393E6F20B'),(2420,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'27D67D5731AE4CF7BBEFE1DB9E160C42'),(2421,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'BBC7FA02A7664CDA8181CD4F01EE0D1A'),(2422,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'86B8DB0A20344012B50ABEEAF739E4AA'),(2423,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'FF4D8CA3ABE34BC1AFA822D4B4504E42'),(2424,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E97DBD1F42F549298DD8042133E42162'),(2425,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'93A8F00159984F7C94BF3E058511CBF6'),(2426,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'8DC355F938A24150B2EC698F89DD7577'),(2427,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E51DCBBBE50146F1A844BBDAAA9E5E7B'),(2428,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'0187DDB1A64541CB91AAD43C8C4D893B'),(2429,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'C79815780E524013B0DA285ABD8BE6D5'),(2430,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'E1804B69F6654A8EB5C93BAB44496924'),(2431,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'59315ACF311C46678C74334C65F8AE56'),(2432,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'9363EE7CC3CA465192C0F0C5ADE4FAE8'),(2433,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009002','2018022410560811',1,0,NULL,'AA628A9D894C40F4985AA0859AF2F5C6'),(2434,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'1D6B31E30FC342C4A6282642CD20E420'),(2435,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'B593B60625BA4BBF95E7887D05369FC3'),(2436,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',1,0,NULL,'16C2365819974E789AA08B8578C8AF51'),(2437,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'D84DD65E84964D0AB771F2C782C4812C'),(2438,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'827C478ED184485AA4F64EC554B8A06A'),(2439,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'A51915FFDEFC44869C3F1D0A322F6922'),(2440,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'2496A0B50F454B258AA43B6088B89E31'),(2441,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'DF01EAC0D0B1413386200EEF87093AC3'),(2442,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'E08ECA9A1B044C26AFEB25B0360CDD91'),(2443,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'0CD67EE2697F4C3291A13DD4646D310F'),(2444,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'11127C77AACE419BA648D1CD4453FA92'),(2445,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'641D0B5317F44561A113792B251C8D6E'),(2446,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'4B7689B59C4345F5BF12BE380BCE66E5'),(2447,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'FC1B330CAEF446DD9391A0E74169E88A'),(2448,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'94C8949770CA43F19833AD4EA4B2265D'),(2449,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'DD22A69007974128B49075A981795973'),(2450,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'D4989B486CB34251B822DEB9BCBE98B5'),(2451,'如下哪些不是java的关键字?','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'FD3E2D92485A4E5A816E1DF8AC408122'),(2452,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'8432B9942E2C440ABA0AD08DCAE82645'),(2453,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'C111F2F9370B41F4A841763D39FCFAA8'),(2454,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'438A253AECEB412DAC47BE5479F43ADE'),(2455,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'E5CFBFC734EB47959ECA217B258B7BAF'),(2456,'如下哪些不是java的关键字?','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3A4D516356214E38A30A0DC4C2302566'),(2457,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'5100A97BD3894E5E99F081EFBC0B6F55'),(2458,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'A6A7044A7F7A462FBD0C561B58864BEC'),(2459,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'2BC68E5DEA9142B0A111E6D926D05FB3'),(2460,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'23C5F1ED218C45FD89BA63EEE5847E70'),(2461,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'B2938B9D22E8498EA3018846F3A9D081'),(2462,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'D9A92C688BD14147AFFF9576828956ED'),(2463,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'780C6CA9224B441CB4E4F2FD59AEC03C'),(2464,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3B1438E8B5504EA4ACA30F2208D35EB7'),(2465,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'A5697D6E64AA4A628FFAFE6FF3EC8215'),(2466,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'8CC2A798185B421BB3F49B3069CD9506'),(2467,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'4FA8AA54627E4DDE9737E07F9C12E37A'),(2468,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'103FCE24367F4B23BF2CD87FBF800B85'),(2469,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'2F4E3D268EB64FEBBC712BC578172F98'),(2470,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'4123AA4AE4114D5EA7775911B4E0DDDD'),(2471,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'C2D91934ACB644B0BFC86D36559128D7'),(2472,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'6759A728F5E44C70BFA99D12D3F0AC42'),(2473,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'E4936DC1453542B4A1F8FC037110B48A'),(2474,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'FA5D46B793274E24A6AF3907C67607DA'),(2475,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'7C480FEDACD94F4583BADDEE72673709'),(2476,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'A73EAC86CDEA4CA3B1978419292F521F'),(2477,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'7BB4084D5F8A48CA8796677F2E26020D'),(2478,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'30C86F6F4CDD485F893EF185C0EA288E'),(2479,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'8CF52CFA53484BE9BC1028D23111189A'),(2480,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3249367217DF42C5AE1E5E0D314EF3EA'),(2481,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'1FDD83077F8B4768920979D1E5BA6838'),(2482,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'7C2EF35E3A434842A84696967CE3D00D'),(2483,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'93C17CB3F8E144F1973780D64C13195B'),(2484,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'7D3B3D3ADBEC4D53BAACC875C32C4819'),(2485,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'9EBB8CFA0722497CA4B7393EB741569B'),(2486,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'669189E0EE974AD99EC186D906A60EDE'),(2487,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'8F6A1449C82A4C41B033BC59B2687735'),(2488,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3387171FEF3E46B1BC2296D1785AE6FF'),(2489,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'DF82C86C753143D99DD58C43809362A2'),(2490,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'549DB8591D884A16A54A1F9F35580428'),(2491,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'18B6974807F4499682F53E051B05C4A1'),(2492,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'7C2F1161CC50473ABD2A332AB51293E3'),(2493,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'9D6F98CD105B4762A513CE99EB04E0DC'),(2494,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'BDEE8D43E8D14381ADA8AE3FCC08EF13'),(2495,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'27314DD2BFDA4EA7A01DF90CE1A9A026'),(2496,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'F25C6A663FB14D9384D1DFF79046F13B'),(2497,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'FDA049824048422AA1E88A55B7E14D5C'),(2498,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'5B981D45D2684B32914A4574AFF765C0'),(2499,'如下哪些不是java的关键字?','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'9540F6F4BE2141A684F641E7C822C053'),(2500,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'11B64CC57A4B4F958FC31DE2C6B49F24'),(2501,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'315FD2E91BD8414095C4E3FF3CA9A440'),(2502,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'98DB711D6D634A02823AB05B5335D7C8'),(2503,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'0ACDA1E3288247628E61BCAC197D1E1C'),(2504,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'02B8BC857FA84D9090EFB477A8848417'),(2505,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'2321A0295E38405BBE668FA0A111AF55'),(2506,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'70E7D63B387E46C7AADF3EC978010B43'),(2507,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'6D3218BD8BA04B13A76F0104CA923A81'),(2508,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'D002B40C3EF240E1A6255D75A3B06858'),(2509,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'527EEB7E835C46128859146EA60C57CD'),(2510,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3C2C6CC580324177B4ECD21E41644026'),(2511,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'8FA99C085C3645FA82FCF6ACDDD478C6'),(2512,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'E11D9AB6F3C64E95A7BF5FF663F0912C'),(2513,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'C3ABE9208D7848F299090B4554F20785'),(2514,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'3B4E8792088642EDA1DEBFA68A133D33'),(2515,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'29AE95E065684B01A516714F5DDE46CD'),(2516,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'95D6BC17D4D34D6B815FBE935F4D0BC4'),(2517,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009002','2018022410560811',2,0,NULL,'01CEAA4E91554641BA84F4BD61C49C11'),(2518,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009002','2018022410560811',2,0,NULL,'3795A47161A34FD4B23170FABF61D37F'),(2519,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'8982AB42C8794CD1BC2654D5B6263EAE'),(2520,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'58FC79388AC44E6DA8280CE64913E7BF'),(2521,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(2522,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'B7858253780B4F10B35A2DF70121C369'),(2523,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'9D58827A80EE4041A2D5B7FE9F70E965'),(2524,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'41875999C5E44822853E3E5B267B96E6'),(2525,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'EACBB9DADCF3466A82BD928EC2089CDD'),(2526,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'38CFE97C37164229A3C9BBE9C1280D70'),(2527,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'4AEEA146A2E74C32AE749F6E8A6B9316'),(2528,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'A242BA4E56C048FDA9320B5D740961D9'),(2529,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'477A1B9C4EC14ECC9B7290EB7FC1B409'),(2530,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'1CFC6A1169DD4CFEB0CE86DA075E18CE'),(2531,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'BAF423A1133D48FE9749B9E60BAA0BE5'),(2532,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'9B6EFE555A764348B9BE58531E38D912'),(2533,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'63B45DA32B66475685F46FEE983F7547'),(2534,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'14B207241F264703AEE06543DC63164B'),(2535,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'867A48EEA69C422F9355B9F7D562FAA2'),(2536,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'4ED826E4A855460F9E8126D83757CB82'),(2537,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'4B60751411034489B7E1158DBCE6DB86'),(2538,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'59B04F9C55C3496FA86542CB070905F4'),(2539,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'64685341D82C45B3B8F3B1A3134CF03A'),(2540,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'663C829E8EED41DCB7F7C1E7A55FB822'),(2541,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'F0C5CEFF9AD34E6ABDE812D79A1EC930'),(2542,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'AE8CAA19996D439D8B4F5B11C10FFC21'),(2543,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'2B3329F1ED054BE198371A2B58AA25B7'),(2544,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'B32C9CFA62C9468588A801B2CE331CFC'),(2545,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'8E292141F8314ACAB1BE203CEC7C65E7'),(2546,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'F3D9F4A576FB434AB3B2B83D729D5ADB'),(2547,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(2548,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'EF446F71B42F4CC19044F26B36678528'),(2549,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'03EE36FD8C994F1B98C1E2C2B91A200E'),(2550,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'098AE1032F9B41C8B36F87899682C1F8'),(2551,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'38A6717475E547C8BBF523ADC792BF42'),(2552,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'C760BFBD98A84463B16312773B7EBB25'),(2553,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'B2EE9F57C339413CA7BB0F366C7E8FCC'),(2554,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'CF288B06B67349BBB52F112728DD2D6F'),(2555,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'CCAE2E16A17E40ECBF7E95B61D65428C'),(2556,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'0A44E4E052BE44469CE9467D42FC90E7'),(2557,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'B53041E99960452BB1F950A1BB5BC902'),(2558,'如下哪些不是java的关键字?','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'7A5A8C6864ED4A3DB465E2C3510A7BCF'),(2559,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'0AC1F7196363456C8EBD6F081D629ADC'),(2560,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'58944F9F7B22498883DA4ECB977B8FE5'),(2561,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'7FADE388B8A248AB9B27C039B27E5369'),(2562,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'87BE6014D24C434AB344B6353C0A72D8'),(2563,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'4569A2E28CB042F6921F390684D02DDF'),(2564,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'3EDFEA7E99DF4E4AB11D3528AFE645F8'),(2565,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'9158166EF28D45EE9B79F277AA12AA5D'),(2566,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'929298B69B8B4F0C8EDFA385A059F797'),(2567,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'26CD2246CF504647AE7FDCB47B09D86F'),(2568,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'B5172B84F6E94789976E31234531B0DE'),(2569,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'00B20E41CAAE46209AC000C66BEA42A1'),(2570,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'A62D2A3B26744455AFA270A7B6427806'),(2571,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'93FE885389694756BD7570A6F6A5E9BF'),(2572,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'97C2272DF4C34A3C9A50532BF8E16605'),(2573,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'BC5C71FF35D24B859E8CEA53F879F535'),(2574,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'AAF33ECA153A45E3B551E2CFFF2930AE'),(2575,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'36C8655255744CB193374CA64806B296'),(2576,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'44D45872D8E94A33B4B95A9AA44B1D41'),(2577,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'08CBCC0569A04EC0959683954D431927'),(2578,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'5FD277B28E8B49909275103539A1A0AB'),(2579,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'F84B496BD94844F48AC3708A2926E453'),(2580,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(2581,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'B57F7314D44C4F8AA9FF93EE210D5C46'),(2582,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'7513B1E11DD44F9F8B525E8AA77AE79C'),(2583,'如下哪些不是java的关键字?','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'46632158F0B34724A8859A8B8DC296A3'),(2584,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'408DBCE66C364E149EDF791CFEDC6EBA'),(2585,'如下哪些不是java的关键字?','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'52D7EE46041C46D19C59B62B73DB7980'),(2586,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'CB23AB9201134BC08EC9307FED325F71'),(2587,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'636BFD8C449E4E9E8F27747F99AA4DAD'),(2588,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'73B37FC1868A4568B90D1EB5925B35CD'),(2589,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'F833D534658142C385B5B2B1A864F786'),(2590,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'290BECED2ED345B3AE8EC3181A70F21F'),(2591,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'4275214FA1354D5DA98B73EB37C83842'),(2592,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'32D7F3306B7B467F8868F18CCCA4A54B'),(2593,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'BADFC2C98CC84B6DA373D9BA7B7C29A5'),(2594,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'537E32E7CC184D73AF8F5B86D07A55F3'),(2595,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'1150C09E5E1844B0A65739C47FC17A2D'),(2596,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'C7D1067D038B4285A24418301CAECC40'),(2597,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'0F81984D117B43FBB0725F97D31EE4D2'),(2598,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009003','2018022410560811',1,0,NULL,'667DC2D840BF4AA694944A4BA25DBC11'),(2599,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'0617883BDD94434A96D05C9C1F0ED825'),(2600,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',1,0,NULL,'3FFDBE2D2B134E6D8B048BA7089CD7AE'),(2601,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'F344A682515D442FA44171A17A64A8E7'),(2602,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'DEE31C203CD54ADE803E64F26A48B643'),(2603,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'E393872B749649AC86FF340964D13EF7'),(2604,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'8DE51CFFE294435CB2D7F7B09047D3FC'),(2605,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'87B73FCF72D9402697D6C1CEC19756F5'),(2606,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'7E06F8116A2641B59136F71EFDDE30B3'),(2607,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'7938256702C74B5AA4D996FB909E0AF5'),(2608,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'4F9CB47A267A41A8BE8AC90A7AA920A4'),(2609,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'A9370CB8E0C64CE6B1F95C7879089C19'),(2610,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'86C9EEC3DCBA4A15A7982F0B6629FEB8'),(2611,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'7EE7AC0A832D4417A2AFE9F7A5BBF146'),(2612,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'7374CDB393694B91956EF062D4679DD8'),(2613,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'58D2AED4CD0D4655B1D8D0E3FC42E58F'),(2614,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'C8493696481F4FE59F25F61F2C54E35E'),(2615,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(2616,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'3DDC6332E2584337ABDF2D4F8C24FDCC'),(2617,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'351D03AAD9D842B0963D8C64C331D5B8'),(2618,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0781FF85816C4FD2A3D8A553D859CF1A'),(2619,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'4A58642B088D4226A6BEC80B701A1EE4'),(2620,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0CF374D4739048E08899A5979E775F65'),(2621,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'A00CB5BB32EF48769CFEAA5E0187A4E8'),(2622,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'C2567BDBA2D64DED8114094A4DAD1F75'),(2623,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'2965CFC608EC42E982DE6E5A63957E2C'),(2624,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'025796F30C8C4B279E45DD6EE100CE17'),(2625,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'A69EF867A61B492BAC5158D988B4AED7'),(2626,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。 ','问题解析:     本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'67C92A429E944C8DBFF46F6F3CD510D3'),(2627,'如下哪些不是java的关键字?','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'859C0B1FE3CD4C58B808649587824A2E'),(2628,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'5DF28B993CA342AA901157CD56205730'),(2629,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'C526F3920B464E8FB0E8E9C54E4FD96B'),(2630,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0EFB5936274C4628A2A95D30E44BDB5E'),(2631,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'7B21CE3795E94910BB106279D4A955E7'),(2632,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'5022616CA877457D8A141B4158D8F5E4'),(2633,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'9D05EED1248B46B3823F23435539D348'),(2634,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'F77A0C85A4844CF195AA85FE53575F34'),(2635,'下面那几个函数是public void method(){...}的重载函数?  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(2636,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'897C87D84E924EA2A5F49FD1E5185925'),(2637,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'4BEEADB7CECA47A6AE0E6711F8189D0B'),(2638,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'D12D66B3B6144FC08E81320BF865EE4F'),(2639,'有关线程的哪些叙述是对的 (多选)','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'A3E0B6F49E144746994FFCDDC06E9839'),(2640,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(2641,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0E7146AEC5AC4B45BE242168E7450D4F'),(2642,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'DD414FCB79974749AF717E98D3D4C7AA'),(2643,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'D3D17756BF3A47818C9836C3010F75C1'),(2644,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0EBD06CAB2D746EBAFB51CBFDEDF5074'),(2645,'请看下列代码：\n // some code here\n try {\n // some code here\n } catch (SomeException se) {\n // some code here\n } finally {\n // some code here\n }\n下面哪种情况不能使第7行的代码执行： \n','      本题考查异常处理中finally块的用法。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序其它部分以前，能够对程序的状态作统一管理，无论try所指定的程序块中是否抛出例外,finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如关闭打开的文件、删除临时文件等。\n      除了下列情况，总将执行finally做为结束：Jvm过早终止；在finally块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。\n     本题中，如果第1行抛出异常，整个程序会因抛出异常而终止。属于我们上述所说了JVM过早终止，finally块不会被执行。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(2646,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(2647,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'59E7C5A418B04944BB933F2B05CF6E74'),(2648,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'49D406AA1C964A63A7DC9015EC0FD510'),(2649,'下列代码说法正确的是：（多选）（）。\npublic class DaemonThread extends Thread{\n public DaemonThread(String name){\n  super(name);\n }\n public void run() {\n  while (true) {\n   System.out.println(\"Daemon thread running...\");\n  }\n }\n public static void main(String[] args) {\n  DaemonThread dt = new DaemonThread(\"dtThread\");\n  dt.setDaemon(true);\n  dt.start();\n }\n}\n','    本题考查守护线程。守护线程也称后台线程、 精灵线程。使用Thread类的setDaemon方法，可以设置某线程为守护线程。当前所有前台线程都结束时, Java进程结束后台线程, 不管是否结束, 都被停掉!',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'D7903ED0A7834FC9828EAB5E6C6B4D53'),(2650,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'32FFCA29A8D544D8B7448B6D06C36F8B'),(2651,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'D70E631603694F6CA84BC4D9B54AE60B'),(2652,'以下哪个方法用于定义线程的执行体？  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'64E9CA75707D4F579CF3199AF14DAFE0'),(2653,'在下列选项中,创建和启动线程的方式正确的是（多选）：（）。 ','     本题考查创建线程的方式。创建线程的方式有两种，一种方式是继承Thread类 。其创建过程如下：\n     1）继承自Thread类, 覆盖run()方法, 提供并发运行的过程。\n     2） 创建这个类的实例。\n     3）使用start() 方法启动线程。\n     另一方式为实现Runnable接口，其创建过程如下：\n      1）.实现Runnable接口, 实现run()方法, 提供并发运行的过程。\n       2）. 创建这个类的实例, 用这个实例作为Thread构造器参数创建Thread类。\n        使用start() 方法启动线程。\n',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'CCF667BBB1FC4235BF83376980992B67'),(2654,'已知表达式 int m [ ] = {0，1，2，3，4，5，6}；   下面哪个表达式的值与数组下标量总数相等?  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'A88341A5789A4D6EA2061F939BC41A0A'),(2655,'请看下列代码：\npublic class Foo { \n     public static void main (String[]args) throws Exception { \n           String name = \"tarena\";\n            byte[] c = name.getBytes();\n            try { \n                 File f = new File(\"company.txt\"); \n                 FileOutputStream out = new FileOutputStream(f, true); \n                     out.write(c);\n                     out.close();\n              } \n              catch (IOException e)   {} \n       } \n}\n假设文件company.txt中已存在一些内容，则关于上述代码的说法正确的是：（）\n','本题考查使用FileOutputStream实现追加写。  FileOutputStream类的构造方法FileOutputStream(File, boolean)的第二构造参数设置为true表示向文件末尾追加写数据，否则为覆盖写。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'C4DAACEFDA044888A90F74EA0CDEB0A4'),(2656,'已知如下代码, 请问哪个语句是正确的？  \npublic class Test {\n long a[] = new long[10];\n\n public static void main(String arg[]) {\n  System.out.print(a[6]);\n }\n}\n','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'D7484358783848728F4D6F4F7BE71229'),(2657,'下列代码编译和运行的结果是：（）。\npublic class A {\n public void process() {\n  System.out.print(\"A,\");\n }\n public static void main(String[] args) {\n  try {\n   new B().process();\n  } catch (IOException e) {\n   System.out.println(\"Exception\");\n  }\n }\n}\nclass B extends A {\n public void process() throws IOException  {\n  super.process();\n  System.out.print(\"B,\");\n   throw new IOException();\n }\n} \n','    本题考查重写方法时的异常处理。如果使用继承时，在父类别的某个方法上声明了throws某些异常，而在子类别中覆盖该方法时，可以有如下操作：\n    1）.不处理异常（覆盖时不设定throws）\n    2）.可throws父类方法中声明的部分异常\n    3）.可throws父类方法中抛出异常的子类异常\n     但是不可以做如下操作：\n     1）.throws出额外的异常\n     2）.throws父类方法中抛出异常的父类异常。\n      本题中父类A的process没有抛出异常，在子类B的process方法抛出了额外的异常IOException，会导致编译失败。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'DC214D6A28774B4CA7937F45B0F14DD9'),(2658,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'C87A28C672E54DAA8563BE61465B7A10'),(2659,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'F1DC1F9FFF994C11822F462CDA652971'),(2660,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'AFB6EE1D837A4449824B71102CDA2567'),(2661,'下列代码编译和运行的结果是：（）。\npublic class TestOne {\n public static void main(String[] args) throws Exception {\n  Thread.sleep(3000);\n  System.out.println(\"sleep\");\n }\n} \n','    本题考查Thread类的sleep方法。\nThread.sleep(times) 使当前线程从 Running状态 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable状态， 如果被其他线程打断当前线程的休眠阻塞, 就会发生InterruptedException.\n      本题中线程休眠3秒后，重新回到Runnable状态，然后，被调度执行进入Running状态，输出“sleep”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'E979082DB56D4ADDA9B913424DEF7645'),(2662,'给出如下代码： class Test{ private int m;  public static void fun() { //some code } }  如何使成员变量m被函数fun()直接访问？   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'70E10A105A884D80ACD0BB0CC791B0F5'),(2663,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'DC8491743C70479797D720E87CA9D53B'),(2664,'下面的哪些声明是合法的？  ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'E99E0619078241348D2CF86A18EDF1E8'),(2665,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。','本题考查如何构建InputStreamReader对象。InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'89E92C92C9CC4D0AA3BD1B560B326729'),(2666,'下列选项中关于synchronized的使用正确的是：（）。','     本题考查synchronized的使用\n    多个线程并发读写同一个临界资源时候会发生线程安全问题，可以使用同步代码块实现同步读写临界资源, 解决并发安全问题.\n      a. 同步代码块 synchronized(同步监视器){... }\n         同步监视器 是一个任意对象实例，是一个多个线程之间的互斥的锁机制， 多个线程要使用同一个\"监视器\" 实现同步互斥.常见写法为   synchronized(this){ ...  }\n       b.如果方法的全部过程需要同步, 可以简单使用synchronized 修饰方法, 例如选项C的用法。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'DF32D57DCDE548729DAA68628CD2AE2F'),(2667,'如下哪些不是java的关键字?','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'FE8614017D9F4D3FA72B7B458504ED67'),(2668,'下面不能使线程处于阻塞状态（Block）的是：（）。 ','    本题考查线程的状态。可以使线程进入阻塞状态的方式有：\n    1）.sleep方法\n     2）.wait方法\n     3）.IO等待\n     4）.同步代码块，synchronized(Object obj){}\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'DEEECCA653C8461996B16D55A1B4A055'),(2669,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'A684A92DEA0E4203A233F605ABB213AB'),(2670,'请看下列代码：\npublic static void main(String[] args) throws Exception{\n  FileOutputStream fos\n   = new FileOutputStream(\"record.dat\");\n  BufferedOutputStream bos\n   = new BufferedOutputStream(fos);\n  bos.write(\'a\');\n}\n关于上述代码编译运行的结果的是：（）。\n','本题考查缓冲流的用法，BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。使用缓冲输出流可以提高写出效率，例如本题中，就没有将缓冲区中的字符a写出去。这是因为在缓冲区中的数据保存直到缓冲区满后才写出，BufferedOutputStream默认的缓冲区为8k，显然缓冲区没有满。当然，也可以使用fluash方法将缓冲区中的数据强制写出或使用close方法关闭流，关闭流之前，缓冲输出流会将缓冲区数据一次性写出。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'731058054035494DAB0E4A44D5C0CEA2'),(2671,'下列代码运行的结果是：（）。\npublic class Boxer {\n Integer i;\n int x;\n public Boxer(int y) {\n  x = i + y;\n  System.out.println(x);\n }\n public static void main(String[] args) {\n  new Boxer(new Integer(4));\n }\n} \n','     本题考查NullPointerException异常。当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\n       本题中，在编译代码“ x = i + y;”时，要对i进行自动拆箱，即相当于代码“ x = i.intValue() + y;\",但执行时属性i的值为null，因此抛出空指针异常。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'0380EF54C2B346518CC4F8BE18BFF628'),(2672,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'91D49DF2C5BA43A98EAD3F8202697370'),(2673,'下列代码编译和运行的结果是：（）。\n public static void main(String[] args) {\n  try {\n   String[] s=null;\n   s[0] = \"test\";\n   System.out.println(s[0]);\n  } catch (Exception ex) {\n   System.out.println(\"Exception\");\n  } catch (NullPointerException npe) {\n   System.out.println(\"NullPointerException\");\n  }\n } \n','      本题考查异常处理中多catch块的情况。catch代码块是异常处理代码。可以写多个catch处理一系列异常，但是要注意：异常的大小关系，大类型的放到后面处理。例如本题中，应把捕获异常的顺序改成如下代码：\n  } catch ( NullPointerException ex) {\n     System.out.println(\"NullPointerException\");\n  } catch (Exception npe) {\n     System.out.println(\"Exception\");\n  }\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'AE1EEAEA6A204F87B16DE80B0144C717'),(2674,'给出如下声明：  String s = “Example”; 合法的代码有哪些？   ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'E0CA769473A1448A86A006924DC34251'),(2675,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'12BEC049BFA24377BCE5112391D98488'),(2676,'下列代码编译和运行的结果是：（）。\npublic class Threads5 {\n public static void main(String[] args) {\n  new Thread(new Runnable() {\n   public void run() {\n    System.out.print(\"bar\");\n   }\n  }).start();\n }\n} \n','   本题考查线程在内部类中的应用。\n   本题中使用内部类的形式创建线程，该用法是正确的，程序可以正常运行输出字符串“bar”。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'987B70BE81F04BA3AE766AF0135BC0DA'),(2677,'已知如下代码： \npublic class Test {\n public static void main(String arg[]) {\n  int i = 5;\n  do {\n   System.out.print(i);\n  } while (--i > 5);\n\n  System.out.print(\"finished\");\n }\n}\n执行后的输出是什么？ (多选) ','',2,'JD20180224105600009003','2018022410560811',2,0,NULL,'1F8EE8AA42FF48E8A0BAA496AC54D513'),(2678,'方法resume()负责恢复哪些线程的执行 ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'5184B400846F48CD9B8E1AC993E7922F'),(2679,'下列代码中，能实现按行读取文件的数据的流是：（）。 ','   本题考查BufferedReader的用法。\n    BufferedReader的readLine() 方法 读取一个文本行，该方法返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'26936E991BFF41FCBADE80B60B9EEFE8'),(2680,'下列关于栈的叙述正确的是   ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'E2CE2B56ABAA491EBE1B03A88B81A060'),(2681,'在Java中，要创建一个InputStreamReader类的对象，下列选项正确的是：（）。 ','    本题考查如何构建InputStreamReader对象。\n      InputStreamReader为 字符输入流。使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。需要使用字节输入流作为参数构造InputStreamReader对象。\n',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'71DFF9365E7A4D77A40649D199BC80EF'),(2682,'请看下列代码：\nclass ThreadDemo implements Runnable{\n int age=0;\n public synchronized void run(){\n  for(int i=0;i<100;i++){\n   System.out.println(\"age=\"+(age++));\n  }\n }\n}\n','    本题考查多线程。\n    本题中若要两个线程共用一个age数据，也就是两个线程共用一个目标对象，即Runnable的引用。本题中C选项使用了同一个目标对象r1。',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'739F3C040815411E8E4E0B3F001839BA'),(2683,'关于垃圾收集的哪些叙述是对的  ','',1,'JD20180224105600009003','2018022410560811',2,0,NULL,'33CB39951E3D43D6999C89E4FE18A38A');

/*Table structure for table `examination_Questions_option` */

DROP TABLE IF EXISTS `examination_Questions_option`;

CREATE TABLE `examination_Questions_option` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `lable` varchar(10) NOT NULL COMMENT '选项标签',
  `context` varchar(500) NOT NULL COMMENT '选项内容',
  `uid` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10741 DEFAULT CHARSET=utf8 COMMENT='题干选项表';

/*Data for the table `examination_Questions_option` */

insert  into `examination_Questions_option`(`id`,`lable`,`context`,`uid`) values (2925,'a','s>>>=3   ','33847C7E645E4F72A74B7D74FCA50B28'),(2926,'b','s[3]= “X”  ','33847C7E645E4F72A74B7D74FCA50B28'),(2927,'c','int i = s.length()   ','33847C7E645E4F72A74B7D74FCA50B28'),(2928,'d','s = s + 10 ','33847C7E645E4F72A74B7D74FCA50B28'),(2929,'a','名为dtThread的线程为守护线程 ','AD156DB8C99E4AC09AC2870B6ACC6512'),(2930,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','AD156DB8C99E4AC09AC2870B6ACC6512'),(2931,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','AD156DB8C99E4AC09AC2870B6ACC6512'),(2932,'d','main线程是守护线程 ','AD156DB8C99E4AC09AC2870B6ACC6512'),(2933,'a','long 1 = 4990  ','307FCB1526514497B5A1EDF2B4413AC2'),(2934,'b','int i = 4L  ','307FCB1526514497B5A1EDF2B4413AC2'),(2935,'c','float f =1.1  ','307FCB1526514497B5A1EDF2B4413AC2'),(2936,'d','double d = 34.4','307FCB1526514497B5A1EDF2B4413AC2'),(2937,'a','5.0','023A8F0EEE8A4552B143D2D773B952F5'),(2938,'b','4.0','023A8F0EEE8A4552B143D2D773B952F5'),(2939,'c','6.0','023A8F0EEE8A4552B143D2D773B952F5'),(2940,'d','finished','023A8F0EEE8A4552B143D2D773B952F5'),(2941,'a','第3行抛出异常 ','A9E66B343EAE4716B90668BE26223209'),(2942,'b','第1行抛出异常 ','A9E66B343EAE4716B90668BE26223209'),(2943,'c','第5行抛出异常 ','A9E66B343EAE4716B90668BE26223209'),(2944,'d','第3行代码成功执行 ','A9E66B343EAE4716B90668BE26223209'),(2945,'a','第3行抛出异常 ','66691F2761F14AE4B31822ABC6A588DF'),(2946,'b','第1行抛出异常 ','66691F2761F14AE4B31822ABC6A588DF'),(2947,'c','第5行抛出异常 ','66691F2761F14AE4B31822ABC6A588DF'),(2948,'d','第3行代码成功执行 ','66691F2761F14AE4B31822ABC6A588DF'),(2949,'a','const   ','E98381DA38084E33B2AC280BE51E25C3'),(2950,'b','NULL  ','E98381DA38084E33B2AC280BE51E25C3'),(2951,'c','false   ','E98381DA38084E33B2AC280BE51E25C3'),(2952,'d','this  ','E98381DA38084E33B2AC280BE51E25C3'),(2953,'a','通过调用stop()方法而停止的线程。 ','AEB40BDD245549C889983956D76B98E0'),(2954,'b','通过调用sleep()方法而停止的线程。 ','AEB40BDD245549C889983956D76B98E0'),(2955,'c','通过调用wait()方法而停止的线程。 ','AEB40BDD245549C889983956D76B98E0'),(2956,'d','通过调用suspend()方法而停止的线程。 ','AEB40BDD245549C889983956D76B98E0'),(2957,'a','long 1 = 4990  ','AF7F21667F024A35A631E78513D74D5B'),(2958,'b','int i = 4L  ','AF7F21667F024A35A631E78513D74D5B'),(2959,'c','float f =1.1  ','AF7F21667F024A35A631E78513D74D5B'),(2960,'d','double d = 34.4','AF7F21667F024A35A631E78513D74D5B'),(2961,'a','一旦一个线程被创建，它就立即开始运行。  ','89DE9D102BF641A4B36CE8D8A5A4DC17'),(2962,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','89DE9D102BF641A4B36CE8D8A5A4DC17'),(2963,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','89DE9D102BF641A4B36CE8D8A5A4DC17'),(2964,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','89DE9D102BF641A4B36CE8D8A5A4DC17'),(2965,'a','start()    ','1286976612114A438FAFA1909E70080D'),(2966,'b','init()    ','1286976612114A438FAFA1909E70080D'),(2967,'c','run()    ','1286976612114A438FAFA1909E70080D'),(2968,'d','main()  ','1286976612114A438FAFA1909E70080D'),(2969,'a','long 1 = 4990  ','3E7831B46614477DAEC02CC0D257D409'),(2970,'b','int i = 4L  ','3E7831B46614477DAEC02CC0D257D409'),(2971,'c','float f =1.1  ','3E7831B46614477DAEC02CC0D257D409'),(2972,'d','double d = 34.4','3E7831B46614477DAEC02CC0D257D409'),(2973,'a','const   ','535F1A92CCCF419484CC809BA76CBF10'),(2974,'b','NULL  ','535F1A92CCCF419484CC809BA76CBF10'),(2975,'c','false   ','535F1A92CCCF419484CC809BA76CBF10'),(2976,'d','this  ','535F1A92CCCF419484CC809BA76CBF10'),(2977,'a','m.length()    ','01AF89EADF3F4CB3863843F3872176EE'),(2978,'b','m.length   ','01AF89EADF3F4CB3863843F3872176EE'),(2979,'c','m.length()+1   ','01AF89EADF3F4CB3863843F3872176EE'),(2980,'d','m.length-1','01AF89EADF3F4CB3863843F3872176EE'),(2981,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0628E41F7BE042D1B02DE5A1FDCB182D'),(2982,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0628E41F7BE042D1B02DE5A1FDCB182D'),(2983,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0628E41F7BE042D1B02DE5A1FDCB182D'),(2984,'d','new InputStreamReader(\"1.dat\") ; ','0628E41F7BE042D1B02DE5A1FDCB182D'),(2985,'a','输出：test ','1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(2986,'b','输出：Exception ','1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(2987,'c','编译失败 ','1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(2988,'d','输出：NullPointerException ','1BF06A2E644D42B7AF1DFE9F84AAD3D5'),(2989,'a','编译错误 ','411CF3440F544A0E885A7CA9C635A0A3'),(2990,'b','程序可以通过编译，运行后文件company.txt没有任何改变','411CF3440F544A0E885A7CA9C635A0A3'),(2991,'c','程序可以通过编译，运行后文件company.txt的长度变为0','411CF3440F544A0E885A7CA9C635A0A3'),(2992,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','411CF3440F544A0E885A7CA9C635A0A3'),(2993,'a','编译错误 ','D55DF333DF5148198D0AB00B8A1318A1'),(2994,'b','抛出运行时异常 ','D55DF333DF5148198D0AB00B8A1318A1'),(2995,'c','输出：sleep ','D55DF333DF5148198D0AB00B8A1318A1'),(2996,'d','代码正常运行，但是无输出 ','D55DF333DF5148198D0AB00B8A1318A1'),(2997,'a','编译错误 ','1B77DA2116C2458AB79D9036DFA44FE1'),(2998,'b','实现向文件record.dat追加写入字符a ','1B77DA2116C2458AB79D9036DFA44FE1'),(2999,'c','实现向文件record.dat覆盖写入字符a ','1B77DA2116C2458AB79D9036DFA44FE1'),(3000,'d','文件record.dat无任何内容 ','1B77DA2116C2458AB79D9036DFA44FE1'),(3001,'a','s>>>=3   ','37A1227DFC7C4A9EBF7673E08144E125'),(3002,'b','s[3]= “X”  ','37A1227DFC7C4A9EBF7673E08144E125'),(3003,'c','int i = s.length()   ','37A1227DFC7C4A9EBF7673E08144E125'),(3004,'d','s = s + 10 ','37A1227DFC7C4A9EBF7673E08144E125'),(3005,'a','5.0','05F7786BF78E4CC3B86A8BACB6CA2137'),(3006,'b','4.0','05F7786BF78E4CC3B86A8BACB6CA2137'),(3007,'c','6.0','05F7786BF78E4CC3B86A8BACB6CA2137'),(3008,'d','finished','05F7786BF78E4CC3B86A8BACB6CA2137'),(3009,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','359E5B13D49A43AA80BAAB943ABF82AE'),(3010,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','359E5B13D49A43AA80BAAB943ABF82AE'),(3011,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','359E5B13D49A43AA80BAAB943ABF82AE'),(3012,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','359E5B13D49A43AA80BAAB943ABF82AE'),(3013,'a','输出：4 ','96DE5D38ECA042A592E24FF659623260'),(3014,'b','在运行时抛出NullPointerException异常 ','96DE5D38ECA042A592E24FF659623260'),(3015,'c','在运行时抛出NumberFormatException异常 ','96DE5D38ECA042A592E24FF659623260'),(3016,'d','在运行时抛出IllegalStateException异常 ','96DE5D38ECA042A592E24FF659623260'),(3017,'a','Output is null.             ','595FEC504F08464EAA982C6DB610AFB7'),(3018,'b','Output is 0 ','595FEC504F08464EAA982C6DB610AFB7'),(3019,'c','编译时报错 ','595FEC504F08464EAA982C6DB610AFB7'),(3020,'d','运行时报错','595FEC504F08464EAA982C6DB610AFB7'),(3021,'a','一旦一个线程被创建，它就立即开始运行。  ','BF55B02584644008817483E1885FC428'),(3022,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','BF55B02584644008817483E1885FC428'),(3023,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','BF55B02584644008817483E1885FC428'),(3024,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','BF55B02584644008817483E1885FC428'),(3025,'a','sleep方法 ','DEB8E00B47984B408E214125C97F561E'),(3026,'b','IO等待 ','DEB8E00B47984B408E214125C97F561E'),(3027,'c','yield方法 ','DEB8E00B47984B408E214125C97F561E'),(3028,'d','wait方法 ','DEB8E00B47984B408E214125C97F561E'),(3029,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','6E054FFAE3584AD088B6ECC7B4965322'),(3030,'b','垃圾收集将检查并释放不在使用的内存  ','6E054FFAE3584AD088B6ECC7B4965322'),(3031,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','6E054FFAE3584AD088B6ECC7B4965322'),(3032,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','6E054FFAE3584AD088B6ECC7B4965322'),(3033,'a','start()    ','9DB691B963F5461AAC3E754346F22282'),(3034,'b','init()    ','9DB691B963F5461AAC3E754346F22282'),(3035,'c','run()    ','9DB691B963F5461AAC3E754346F22282'),(3036,'d','main()  ','9DB691B963F5461AAC3E754346F22282'),(3037,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','CC6F88C11377484D9B49E839BFBD8D48'),(3038,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','CC6F88C11377484D9B49E839BFBD8D48'),(3039,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','CC6F88C11377484D9B49E839BFBD8D48'),(3040,'d','new InputStreamReader(\"1.dat\") ; ','CC6F88C11377484D9B49E839BFBD8D48'),(3041,'a','编译错误 ','572E53DB246E40E2B8DF655AA8D74114'),(3042,'b','抛出运行时异常 ','572E53DB246E40E2B8DF655AA8D74114'),(3043,'c','输出：bar ','572E53DB246E40E2B8DF655AA8D74114'),(3044,'d','代码正常运行，但是无输出 ','572E53DB246E40E2B8DF655AA8D74114'),(3045,'a','编译错误 ','D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(3046,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(3047,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(3048,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D45DDBE36DFB4C7B8FD43A9603F0ACCB'),(3049,'a','sleep方法 ','9E71E08F01E44C8CBDE27DF7C8C2EA36'),(3050,'b','IO等待 ','9E71E08F01E44C8CBDE27DF7C8C2EA36'),(3051,'c','yield方法 ','9E71E08F01E44C8CBDE27DF7C8C2EA36'),(3052,'d','wait方法 ','9E71E08F01E44C8CBDE27DF7C8C2EA36'),(3053,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','C27B38E93804484BA4C20A017DC36AD3'),(3054,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','C27B38E93804484BA4C20A017DC36AD3'),(3055,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','C27B38E93804484BA4C20A017DC36AD3'),(3056,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','C27B38E93804484BA4C20A017DC36AD3'),(3057,'a','Output is null.             ','E81CA77AA7114CEE940B2017685315F8'),(3058,'b','Output is 0 ','E81CA77AA7114CEE940B2017685315F8'),(3059,'c','编译时报错 ','E81CA77AA7114CEE940B2017685315F8'),(3060,'d','运行时报错','E81CA77AA7114CEE940B2017685315F8'),(3061,'a','将private int m改为 protected int m  ','D6FEB574878D45FDA87E87D21B2FECE6'),(3062,'b','将private int m改为 public int m    ','D6FEB574878D45FDA87E87D21B2FECE6'),(3063,'c','将private int m改为 static int m     ','D6FEB574878D45FDA87E87D21B2FECE6'),(3064,'d','将private int m改为int m ','D6FEB574878D45FDA87E87D21B2FECE6'),(3065,'a','const   ','D0EAD34BC874489F9D4C666BDFEEB456'),(3066,'b','NULL  ','D0EAD34BC874489F9D4C666BDFEEB456'),(3067,'c','false   ','D0EAD34BC874489F9D4C666BDFEEB456'),(3068,'d','this  ','D0EAD34BC874489F9D4C666BDFEEB456'),(3069,'a','m.length()    ','080AC05A00A0463F8DA60212FE66F7FA'),(3070,'b','m.length   ','080AC05A00A0463F8DA60212FE66F7FA'),(3071,'c','m.length()+1   ','080AC05A00A0463F8DA60212FE66F7FA'),(3072,'d','m.length-1','080AC05A00A0463F8DA60212FE66F7FA'),(3073,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','9588534660054E15B07269C3B0E61B60'),(3074,'b','垃圾收集将检查并释放不在使用的内存  ','9588534660054E15B07269C3B0E61B60'),(3075,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','9588534660054E15B07269C3B0E61B60'),(3076,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','9588534660054E15B07269C3B0E61B60'),(3077,'a','Output is null.             ','709BD0672D6246459F23A361BB4FD037'),(3078,'b','Output is 0 ','709BD0672D6246459F23A361BB4FD037'),(3079,'c','编译时报错 ','709BD0672D6246459F23A361BB4FD037'),(3080,'d','运行时报错','709BD0672D6246459F23A361BB4FD037'),(3081,'a','public void method( int m){...}     ','F1DF5A8ECA484D85913D9057559B6E20'),(3082,'b','public int method(){...} ','F1DF5A8ECA484D85913D9057559B6E20'),(3083,'c','public void method2(){...}    ','F1DF5A8ECA484D85913D9057559B6E20'),(3084,'d','public int method(int m，float f ){...} ','F1DF5A8ECA484D85913D9057559B6E20'),(3085,'a','输出Exception ','9025A20BA72843C1B7B245810369EA9C'),(3086,'b','输出A,B,Exception ','9025A20BA72843C1B7B245810369EA9C'),(3087,'c','编译失败 ','9025A20BA72843C1B7B245810369EA9C'),(3088,'d','在运行时抛出NullPointerException异常 ','9025A20BA72843C1B7B245810369EA9C'),(3089,'a','start()    ','7560F2D221EB4068A112AEE2DD7594F0'),(3090,'b','init()    ','7560F2D221EB4068A112AEE2DD7594F0'),(3091,'c','run()    ','7560F2D221EB4068A112AEE2DD7594F0'),(3092,'d','main()  ','7560F2D221EB4068A112AEE2DD7594F0'),(3093,'a','编译错误 ','07061192BFEA41D385A1B82AB1899900'),(3094,'b','程序可以通过编译，运行后文件company.txt没有任何改变','07061192BFEA41D385A1B82AB1899900'),(3095,'c','程序可以通过编译，运行后文件company.txt的长度变为0','07061192BFEA41D385A1B82AB1899900'),(3096,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','07061192BFEA41D385A1B82AB1899900'),(3097,'a','输出：4 ','0E800B19ACD3493B8392AA1E745FC526'),(3098,'b','在运行时抛出NullPointerException异常 ','0E800B19ACD3493B8392AA1E745FC526'),(3099,'c','在运行时抛出NumberFormatException异常 ','0E800B19ACD3493B8392AA1E745FC526'),(3100,'d','在运行时抛出IllegalStateException异常 ','0E800B19ACD3493B8392AA1E745FC526'),(3101,'a','第3行抛出异常 ','99501CBC0F964897B5FABA2BD033EBE4'),(3102,'b','第1行抛出异常 ','99501CBC0F964897B5FABA2BD033EBE4'),(3103,'c','第5行抛出异常 ','99501CBC0F964897B5FABA2BD033EBE4'),(3104,'d','第3行代码成功执行 ','99501CBC0F964897B5FABA2BD033EBE4'),(3105,'a','输出：4 ','1833AFC55CC8402FAF7AC5371C0CAE19'),(3106,'b','在运行时抛出NullPointerException异常 ','1833AFC55CC8402FAF7AC5371C0CAE19'),(3107,'c','在运行时抛出NumberFormatException异常 ','1833AFC55CC8402FAF7AC5371C0CAE19'),(3108,'d','在运行时抛出IllegalStateException异常 ','1833AFC55CC8402FAF7AC5371C0CAE19'),(3109,'a','public void method( int m){...}     ','76E152C8AD4146CEAF75A4D879F5FD00'),(3110,'b','public int method(){...} ','76E152C8AD4146CEAF75A4D879F5FD00'),(3111,'c','public void method2(){...}    ','76E152C8AD4146CEAF75A4D879F5FD00'),(3112,'d','public int method(int m，float f ){...} ','76E152C8AD4146CEAF75A4D879F5FD00'),(3113,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','B652A6A0A12549AB8652E4432135948B'),(3114,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','B652A6A0A12549AB8652E4432135948B'),(3115,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','B652A6A0A12549AB8652E4432135948B'),(3116,'d','new InputStreamReader(\"1.dat\") ; ','B652A6A0A12549AB8652E4432135948B'),(3117,'a','编译错误 ','CB38E30E01274C4B8FCE0C4D4A324FE4'),(3118,'b','抛出运行时异常 ','CB38E30E01274C4B8FCE0C4D4A324FE4'),(3119,'c','输出：bar ','CB38E30E01274C4B8FCE0C4D4A324FE4'),(3120,'d','代码正常运行，但是无输出 ','CB38E30E01274C4B8FCE0C4D4A324FE4'),(3121,'a','编译错误 ','9432EC995CB04163B0118BE98A5A1735'),(3122,'b','实现向文件record.dat追加写入字符a ','9432EC995CB04163B0118BE98A5A1735'),(3123,'c','实现向文件record.dat覆盖写入字符a ','9432EC995CB04163B0118BE98A5A1735'),(3124,'d','文件record.dat无任何内容 ','9432EC995CB04163B0118BE98A5A1735'),(3125,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','E47C27479C9C4D4293C08DC6B15EABB9'),(3126,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','E47C27479C9C4D4293C08DC6B15EABB9'),(3127,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','E47C27479C9C4D4293C08DC6B15EABB9'),(3128,'d','new InputStreamReader(\"dat\") ; ','E47C27479C9C4D4293C08DC6B15EABB9'),(3129,'a','名为dtThread的线程为守护线程 ','6BE96985E07A45B5902184756CC7266F'),(3130,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','6BE96985E07A45B5902184756CC7266F'),(3131,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','6BE96985E07A45B5902184756CC7266F'),(3132,'d','main线程是守护线程 ','6BE96985E07A45B5902184756CC7266F'),(3133,'a','名为dtThread的线程为守护线程 ','DBC7179BEB2443CC8B79C226A868B53A'),(3134,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','DBC7179BEB2443CC8B79C226A868B53A'),(3135,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','DBC7179BEB2443CC8B79C226A868B53A'),(3136,'d','main线程是守护线程 ','DBC7179BEB2443CC8B79C226A868B53A'),(3137,'a','sleep方法 ','5DDC385AA08440F380130A53C0808333'),(3138,'b','IO等待 ','5DDC385AA08440F380130A53C0808333'),(3139,'c','yield方法 ','5DDC385AA08440F380130A53C0808333'),(3140,'d','wait方法 ','5DDC385AA08440F380130A53C0808333'),(3141,'a','InputStreamReader','24FE7079EB4B46E49CCFDD956F6FF753'),(3142,'b','BufferedReader','24FE7079EB4B46E49CCFDD956F6FF753'),(3143,'c','FileInputStream','24FE7079EB4B46E49CCFDD956F6FF753'),(3144,'d','InputStream','24FE7079EB4B46E49CCFDD956F6FF753'),(3145,'a','栈是非线性结构        ','C58B91FF03EB4334B2CDAE9270CBC56A'),(3146,'b','栈是一种树状结构 ','C58B91FF03EB4334B2CDAE9270CBC56A'),(3147,'c','栈具有先进先出的特征  ','C58B91FF03EB4334B2CDAE9270CBC56A'),(3148,'d','栈具有后进先出的特征 ','C58B91FF03EB4334B2CDAE9270CBC56A'),(3149,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','9931269B85B3407CAD2538474F0D86C0'),(3150,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','9931269B85B3407CAD2538474F0D86C0'),(3151,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','9931269B85B3407CAD2538474F0D86C0'),(3152,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','9931269B85B3407CAD2538474F0D86C0'),(3153,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','F8F723F3F63C441C845141DE446D6DAD'),(3154,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','F8F723F3F63C441C845141DE446D6DAD'),(3155,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','F8F723F3F63C441C845141DE446D6DAD'),(3156,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','F8F723F3F63C441C845141DE446D6DAD'),(3157,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(3158,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(3159,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(3160,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','CFAFA6D5A57D465C9F06D4D5DB0BC18F'),(3161,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','CEC688299710476A867EDB0BD774B3AB'),(3162,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','CEC688299710476A867EDB0BD774B3AB'),(3163,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','CEC688299710476A867EDB0BD774B3AB'),(3164,'d','new InputStreamReader(\"dat\") ; ','CEC688299710476A867EDB0BD774B3AB'),(3165,'a','通过调用stop()方法而停止的线程。 ','1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(3166,'b','通过调用sleep()方法而停止的线程。 ','1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(3167,'c','通过调用wait()方法而停止的线程。 ','1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(3168,'d','通过调用suspend()方法而停止的线程。 ','1FF09A0A5AA049C2BF5E0F0336EFE7E9'),(3169,'a','输出：test ','FF3EE10F7F8A40C0A22C946BA66A43DB'),(3170,'b','输出：Exception ','FF3EE10F7F8A40C0A22C946BA66A43DB'),(3171,'c','编译失败 ','FF3EE10F7F8A40C0A22C946BA66A43DB'),(3172,'d','输出：NullPointerException ','FF3EE10F7F8A40C0A22C946BA66A43DB'),(3173,'a','编译错误 ','A6D21D1AE5664320945F8F3B8EF61563'),(3174,'b','实现向文件record.dat追加写入字符a ','A6D21D1AE5664320945F8F3B8EF61563'),(3175,'c','实现向文件record.dat覆盖写入字符a ','A6D21D1AE5664320945F8F3B8EF61563'),(3176,'d','文件record.dat无任何内容 ','A6D21D1AE5664320945F8F3B8EF61563'),(3177,'a','栈是非线性结构        ','50006AB4956F4EECA09BEA06EFDD47BA'),(3178,'b','栈是一种树状结构 ','50006AB4956F4EECA09BEA06EFDD47BA'),(3179,'c','栈具有先进先出的特征  ','50006AB4956F4EECA09BEA06EFDD47BA'),(3180,'d','栈具有后进先出的特征 ','50006AB4956F4EECA09BEA06EFDD47BA'),(3181,'a','InputStreamReader','809FD1A230F2447591B7DFCAFE9ADEDD'),(3182,'b','BufferedReader','809FD1A230F2447591B7DFCAFE9ADEDD'),(3183,'c','FileInputStream','809FD1A230F2447591B7DFCAFE9ADEDD'),(3184,'d','InputStream','809FD1A230F2447591B7DFCAFE9ADEDD'),(3185,'a','将private int m改为 protected int m  ','C27AFF79C3DB4160AF2366D618D1B0C0'),(3186,'b','将private int m改为 public int m    ','C27AFF79C3DB4160AF2366D618D1B0C0'),(3187,'c','将private int m改为 static int m     ','C27AFF79C3DB4160AF2366D618D1B0C0'),(3188,'d','将private int m改为int m ','C27AFF79C3DB4160AF2366D618D1B0C0'),(3189,'a','编译错误 ','CCBE640AD2764BDF99BF4AF323DDE8A6'),(3190,'b','抛出运行时异常 ','CCBE640AD2764BDF99BF4AF323DDE8A6'),(3191,'c','输出：bar ','CCBE640AD2764BDF99BF4AF323DDE8A6'),(3192,'d','代码正常运行，但是无输出 ','CCBE640AD2764BDF99BF4AF323DDE8A6'),(3193,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','935C9CFE7F9D49ADA0B1D4D230836B7E'),(3194,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','935C9CFE7F9D49ADA0B1D4D230836B7E'),(3195,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','935C9CFE7F9D49ADA0B1D4D230836B7E'),(3196,'d','new InputStreamReader(\"dat\") ; ','935C9CFE7F9D49ADA0B1D4D230836B7E'),(3197,'a','s>>>=3   ','8D128BCBEF114A8A9F21E4C12B89265A'),(3198,'b','s[3]= “X”  ','8D128BCBEF114A8A9F21E4C12B89265A'),(3199,'c','int i = s.length()   ','8D128BCBEF114A8A9F21E4C12B89265A'),(3200,'d','s = s + 10 ','8D128BCBEF114A8A9F21E4C12B89265A'),(3201,'a','private synchronized Object o; ','FC918759DD134FC7B8808340796A6E10'),(3202,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','FC918759DD134FC7B8808340796A6E10'),(3203,'c','public synchronized void go() { /* code here */ } ','FC918759DD134FC7B8808340796A6E10'),(3204,'d','private synchronized(this) void go() { /* code here */ } ','FC918759DD134FC7B8808340796A6E10'),(3205,'a','编译错误 ','8A3DF44930B2411781E644DBAF6EC0BA'),(3206,'b','抛出运行时异常 ','8A3DF44930B2411781E644DBAF6EC0BA'),(3207,'c','输出：sleep ','8A3DF44930B2411781E644DBAF6EC0BA'),(3208,'d','代码正常运行，但是无输出 ','8A3DF44930B2411781E644DBAF6EC0BA'),(3209,'a','通过调用stop()方法而停止的线程。 ','6FDA82C6B47547B3B4B8464495BE9319'),(3210,'b','通过调用sleep()方法而停止的线程。 ','6FDA82C6B47547B3B4B8464495BE9319'),(3211,'c','通过调用wait()方法而停止的线程。 ','6FDA82C6B47547B3B4B8464495BE9319'),(3212,'d','通过调用suspend()方法而停止的线程。 ','6FDA82C6B47547B3B4B8464495BE9319'),(3213,'a','private synchronized Object o; ','F97BB081144A4CF0A5BB1CAEDE3661E3'),(3214,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','F97BB081144A4CF0A5BB1CAEDE3661E3'),(3215,'c','public synchronized void go() { /* code here */ } ','F97BB081144A4CF0A5BB1CAEDE3661E3'),(3216,'d','private synchronized(this) void go() { /* code here */ } ','F97BB081144A4CF0A5BB1CAEDE3661E3'),(3217,'a','5.0','D297C90E79CD409899CA6CFE31AA3965'),(3218,'b','4.0','D297C90E79CD409899CA6CFE31AA3965'),(3219,'c','6.0','D297C90E79CD409899CA6CFE31AA3965'),(3220,'d','finished','D297C90E79CD409899CA6CFE31AA3965'),(3221,'a','输出：test ','1E46898D9E2A47BB844F2BB778BC1819'),(3222,'b','输出：Exception ','1E46898D9E2A47BB844F2BB778BC1819'),(3223,'c','编译失败 ','1E46898D9E2A47BB844F2BB778BC1819'),(3224,'d','输出：NullPointerException ','1E46898D9E2A47BB844F2BB778BC1819'),(3225,'a','private synchronized Object o; ','CFB948206CFE4664B8455AE662BF2D84'),(3226,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','CFB948206CFE4664B8455AE662BF2D84'),(3227,'c','public synchronized void go() { /* code here */ } ','CFB948206CFE4664B8455AE662BF2D84'),(3228,'d','private synchronized(this) void go() { /* code here */ } ','CFB948206CFE4664B8455AE662BF2D84'),(3229,'a','栈是非线性结构        ','CB3D1028B169461EBBC0B8C70621BB12'),(3230,'b','栈是一种树状结构 ','CB3D1028B169461EBBC0B8C70621BB12'),(3231,'c','栈具有先进先出的特征  ','CB3D1028B169461EBBC0B8C70621BB12'),(3232,'d','栈具有后进先出的特征 ','CB3D1028B169461EBBC0B8C70621BB12'),(3233,'a','将private int m改为 protected int m  ','9EE5241B598D47AB8291C178572148D9'),(3234,'b','将private int m改为 public int m    ','9EE5241B598D47AB8291C178572148D9'),(3235,'c','将private int m改为 static int m     ','9EE5241B598D47AB8291C178572148D9'),(3236,'d','将private int m改为int m ','9EE5241B598D47AB8291C178572148D9'),(3237,'a','输出Exception ','9DC5993EE56F4782A01CBAD4B501A62F'),(3238,'b','输出A,B,Exception ','9DC5993EE56F4782A01CBAD4B501A62F'),(3239,'c','编译失败 ','9DC5993EE56F4782A01CBAD4B501A62F'),(3240,'d','在运行时抛出NullPointerException异常 ','9DC5993EE56F4782A01CBAD4B501A62F'),(3241,'a','InputStreamReader','553BE7DBFF814162A26D7362C58061A7'),(3242,'b','BufferedReader','553BE7DBFF814162A26D7362C58061A7'),(3243,'c','FileInputStream','553BE7DBFF814162A26D7362C58061A7'),(3244,'d','InputStream','553BE7DBFF814162A26D7362C58061A7'),(3245,'a','编译错误 ','5E09FBD6E7FE402889DA86D12E0BC2AA'),(3246,'b','实现向文件record.dat追加写入字符a ','5E09FBD6E7FE402889DA86D12E0BC2AA'),(3247,'c','实现向文件record.dat覆盖写入字符a ','5E09FBD6E7FE402889DA86D12E0BC2AA'),(3248,'d','文件record.dat无任何内容 ','5E09FBD6E7FE402889DA86D12E0BC2AA'),(3249,'a','m.length()    ','C3E126C77AE64823BA806EDE323714D0'),(3250,'b','m.length   ','C3E126C77AE64823BA806EDE323714D0'),(3251,'c','m.length()+1   ','C3E126C77AE64823BA806EDE323714D0'),(3252,'d','m.length-1','C3E126C77AE64823BA806EDE323714D0'),(3253,'a','将private int m改为 protected int m  ','C281AF83C3D048A388B1D8DB558B98BF'),(3254,'b','将private int m改为 public int m    ','C281AF83C3D048A388B1D8DB558B98BF'),(3255,'c','将private int m改为 static int m     ','C281AF83C3D048A388B1D8DB558B98BF'),(3256,'d','将private int m改为int m ','C281AF83C3D048A388B1D8DB558B98BF'),(3257,'a','通过调用stop()方法而停止的线程。 ','8B82035BE89647F29421B21DD985658A'),(3258,'b','通过调用sleep()方法而停止的线程。 ','8B82035BE89647F29421B21DD985658A'),(3259,'c','通过调用wait()方法而停止的线程。 ','8B82035BE89647F29421B21DD985658A'),(3260,'d','通过调用suspend()方法而停止的线程。 ','8B82035BE89647F29421B21DD985658A'),(3261,'a','一旦一个线程被创建，它就立即开始运行。  ','5A003EF15715480D9670339F3E861B98'),(3262,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','5A003EF15715480D9670339F3E861B98'),(3263,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','5A003EF15715480D9670339F3E861B98'),(3264,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','5A003EF15715480D9670339F3E861B98'),(3265,'a','编译错误 ','37B3BD3890E547EE99A0DF7BE6993FFE'),(3266,'b','抛出运行时异常 ','37B3BD3890E547EE99A0DF7BE6993FFE'),(3267,'c','输出：bar ','37B3BD3890E547EE99A0DF7BE6993FFE'),(3268,'d','代码正常运行，但是无输出 ','37B3BD3890E547EE99A0DF7BE6993FFE'),(3269,'a','编译错误 ','A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(3270,'b','抛出运行时异常 ','A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(3271,'c','输出：bar ','A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(3272,'d','代码正常运行，但是无输出 ','A0516EE040EF4EBD9D1AAA3EAEB7D4FB'),(3273,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','4425428C58B74D67A2B044FC2C25A34F'),(3274,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','4425428C58B74D67A2B044FC2C25A34F'),(3275,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','4425428C58B74D67A2B044FC2C25A34F'),(3276,'d','new InputStreamReader(\"1.dat\") ; ','4425428C58B74D67A2B044FC2C25A34F'),(3277,'a','public void method( int m){...}     ','2D7CEED6F7764D548D89AB16C69227E1'),(3278,'b','public int method(){...} ','2D7CEED6F7764D548D89AB16C69227E1'),(3279,'c','public void method2(){...}    ','2D7CEED6F7764D548D89AB16C69227E1'),(3280,'d','public int method(int m，float f ){...} ','2D7CEED6F7764D548D89AB16C69227E1'),(3281,'a','m.length()    ','043B129719A042B98CBF2E28227F4177'),(3282,'b','m.length   ','043B129719A042B98CBF2E28227F4177'),(3283,'c','m.length()+1   ','043B129719A042B98CBF2E28227F4177'),(3284,'d','m.length-1','043B129719A042B98CBF2E28227F4177'),(3285,'a','start()    ','62CE818D71ED44FA90386382838B4D9A'),(3286,'b','init()    ','62CE818D71ED44FA90386382838B4D9A'),(3287,'c','run()    ','62CE818D71ED44FA90386382838B4D9A'),(3288,'d','main()  ','62CE818D71ED44FA90386382838B4D9A'),(3289,'a','编译错误 ','3B80D26280B748858E3D6945B2E5383A'),(3290,'b','程序可以通过编译，运行后文件company.txt没有任何改变','3B80D26280B748858E3D6945B2E5383A'),(3291,'c','程序可以通过编译，运行后文件company.txt的长度变为0','3B80D26280B748858E3D6945B2E5383A'),(3292,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','3B80D26280B748858E3D6945B2E5383A'),(3293,'a','通过调用stop()方法而停止的线程。 ','501A71A732D04BBC842D3A2C0E6C7E81'),(3294,'b','通过调用sleep()方法而停止的线程。 ','501A71A732D04BBC842D3A2C0E6C7E81'),(3295,'c','通过调用wait()方法而停止的线程。 ','501A71A732D04BBC842D3A2C0E6C7E81'),(3296,'d','通过调用suspend()方法而停止的线程。 ','501A71A732D04BBC842D3A2C0E6C7E81'),(3297,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','E7B5E813FB8E484BBAB82C802B6DDCCD'),(3298,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','E7B5E813FB8E484BBAB82C802B6DDCCD'),(3299,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','E7B5E813FB8E484BBAB82C802B6DDCCD'),(3300,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','E7B5E813FB8E484BBAB82C802B6DDCCD'),(3301,'a','编译错误 ','3C59EF7A55BF42D7A2386303168B41E6'),(3302,'b','实现向文件record.dat追加写入字符a ','3C59EF7A55BF42D7A2386303168B41E6'),(3303,'c','实现向文件record.dat覆盖写入字符a ','3C59EF7A55BF42D7A2386303168B41E6'),(3304,'d','文件record.dat无任何内容 ','3C59EF7A55BF42D7A2386303168B41E6'),(3305,'a','输出：4 ','B0B5DF79A7FF49A59190A71F79FCD3C7'),(3306,'b','在运行时抛出NullPointerException异常 ','B0B5DF79A7FF49A59190A71F79FCD3C7'),(3307,'c','在运行时抛出NumberFormatException异常 ','B0B5DF79A7FF49A59190A71F79FCD3C7'),(3308,'d','在运行时抛出IllegalStateException异常 ','B0B5DF79A7FF49A59190A71F79FCD3C7'),(3309,'a','s>>>=3   ','7A10C5C4166C4D369CB7B13BA1282FEE'),(3310,'b','s[3]= “X”  ','7A10C5C4166C4D369CB7B13BA1282FEE'),(3311,'c','int i = s.length()   ','7A10C5C4166C4D369CB7B13BA1282FEE'),(3312,'d','s = s + 10 ','7A10C5C4166C4D369CB7B13BA1282FEE'),(3313,'a','名为dtThread的线程为守护线程 ','531E9499C4404A4F87124A0477A832B7'),(3314,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','531E9499C4404A4F87124A0477A832B7'),(3315,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','531E9499C4404A4F87124A0477A832B7'),(3316,'d','main线程是守护线程 ','531E9499C4404A4F87124A0477A832B7'),(3317,'a','InputStreamReader','09F1FC33E50542ECBAADE31A65D25524'),(3318,'b','BufferedReader','09F1FC33E50542ECBAADE31A65D25524'),(3319,'c','FileInputStream','09F1FC33E50542ECBAADE31A65D25524'),(3320,'d','InputStream','09F1FC33E50542ECBAADE31A65D25524'),(3321,'a','m.length()    ','BBE5511E95214082A7658FB057F3AC60'),(3322,'b','m.length   ','BBE5511E95214082A7658FB057F3AC60'),(3323,'c','m.length()+1   ','BBE5511E95214082A7658FB057F3AC60'),(3324,'d','m.length-1','BBE5511E95214082A7658FB057F3AC60'),(3325,'a','s>>>=3   ','56CD45D13F9F4BA88DF8C3426D569005'),(3326,'b','s[3]= “X”  ','56CD45D13F9F4BA88DF8C3426D569005'),(3327,'c','int i = s.length()   ','56CD45D13F9F4BA88DF8C3426D569005'),(3328,'d','s = s + 10 ','56CD45D13F9F4BA88DF8C3426D569005'),(3329,'a','sleep方法 ','4CE8A739509C4747B07BC9ACBA549F30'),(3330,'b','IO等待 ','4CE8A739509C4747B07BC9ACBA549F30'),(3331,'c','yield方法 ','4CE8A739509C4747B07BC9ACBA549F30'),(3332,'d','wait方法 ','4CE8A739509C4747B07BC9ACBA549F30'),(3333,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','4556DC3D22534DAC84EB30BD05C652A0'),(3334,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','4556DC3D22534DAC84EB30BD05C652A0'),(3335,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','4556DC3D22534DAC84EB30BD05C652A0'),(3336,'d','new InputStreamReader(\"dat\") ; ','4556DC3D22534DAC84EB30BD05C652A0'),(3337,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','05E31A91164341BFB413D7AC211EF002'),(3338,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','05E31A91164341BFB413D7AC211EF002'),(3339,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','05E31A91164341BFB413D7AC211EF002'),(3340,'d','new InputStreamReader(\"1.dat\") ; ','05E31A91164341BFB413D7AC211EF002'),(3341,'a','输出Exception ','6D93DD9548E24AB28D4E8B0EE1E3A30E'),(3342,'b','输出A,B,Exception ','6D93DD9548E24AB28D4E8B0EE1E3A30E'),(3343,'c','编译失败 ','6D93DD9548E24AB28D4E8B0EE1E3A30E'),(3344,'d','在运行时抛出NullPointerException异常 ','6D93DD9548E24AB28D4E8B0EE1E3A30E'),(3345,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','7D5E514B84964350935BC2D25193E537'),(3346,'b','垃圾收集将检查并释放不在使用的内存  ','7D5E514B84964350935BC2D25193E537'),(3347,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','7D5E514B84964350935BC2D25193E537'),(3348,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','7D5E514B84964350935BC2D25193E537'),(3349,'a','start()    ','96B0D01FA63E4FE8B11FB177C7791749'),(3350,'b','init()    ','96B0D01FA63E4FE8B11FB177C7791749'),(3351,'c','run()    ','96B0D01FA63E4FE8B11FB177C7791749'),(3352,'d','main()  ','96B0D01FA63E4FE8B11FB177C7791749'),(3353,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','DCB01C2CD2EB435586A57D7CDF47E5BC'),(3354,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','DCB01C2CD2EB435586A57D7CDF47E5BC'),(3355,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','DCB01C2CD2EB435586A57D7CDF47E5BC'),(3356,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','DCB01C2CD2EB435586A57D7CDF47E5BC'),(3357,'a','编译错误 ','D6A555FE1080443DAC5CA287C256761D'),(3358,'b','抛出运行时异常 ','D6A555FE1080443DAC5CA287C256761D'),(3359,'c','输出：sleep ','D6A555FE1080443DAC5CA287C256761D'),(3360,'d','代码正常运行，但是无输出 ','D6A555FE1080443DAC5CA287C256761D'),(3361,'a','InputStreamReader','80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(3362,'b','BufferedReader','80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(3363,'c','FileInputStream','80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(3364,'d','InputStream','80C9CDD3EFD84AA5BAFD1D7A7E66B571'),(3365,'a','Output is null.             ','9CB027C6BCE7460CA30F124B1B63D1BF'),(3366,'b','Output is 0 ','9CB027C6BCE7460CA30F124B1B63D1BF'),(3367,'c','编译时报错 ','9CB027C6BCE7460CA30F124B1B63D1BF'),(3368,'d','运行时报错','9CB027C6BCE7460CA30F124B1B63D1BF'),(3369,'a','一旦一个线程被创建，它就立即开始运行。  ','0D490C469B2A4213BCA13EB31217E7A8'),(3370,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','0D490C469B2A4213BCA13EB31217E7A8'),(3371,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','0D490C469B2A4213BCA13EB31217E7A8'),(3372,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','0D490C469B2A4213BCA13EB31217E7A8'),(3373,'a','输出：4 ','00174112FD76452F8AA4B2E380BB419A'),(3374,'b','在运行时抛出NullPointerException异常 ','00174112FD76452F8AA4B2E380BB419A'),(3375,'c','在运行时抛出NumberFormatException异常 ','00174112FD76452F8AA4B2E380BB419A'),(3376,'d','在运行时抛出IllegalStateException异常 ','00174112FD76452F8AA4B2E380BB419A'),(3377,'a','栈是非线性结构        ','ED58D69EDDD34197962E7AB32D685DE9'),(3378,'b','栈是一种树状结构 ','ED58D69EDDD34197962E7AB32D685DE9'),(3379,'c','栈具有先进先出的特征  ','ED58D69EDDD34197962E7AB32D685DE9'),(3380,'d','栈具有后进先出的特征 ','ED58D69EDDD34197962E7AB32D685DE9'),(3381,'a','编译错误 ','1812208044334BFEB52FFC01DA63AE83'),(3382,'b','程序可以通过编译，运行后文件company.txt没有任何改变','1812208044334BFEB52FFC01DA63AE83'),(3383,'c','程序可以通过编译，运行后文件company.txt的长度变为0','1812208044334BFEB52FFC01DA63AE83'),(3384,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','1812208044334BFEB52FFC01DA63AE83'),(3385,'a','输出：test ','3F8AF57D6A074EC996DF83FB0705C478'),(3386,'b','输出：Exception ','3F8AF57D6A074EC996DF83FB0705C478'),(3387,'c','编译失败 ','3F8AF57D6A074EC996DF83FB0705C478'),(3388,'d','输出：NullPointerException ','3F8AF57D6A074EC996DF83FB0705C478'),(3389,'a','名为dtThread的线程为守护线程 ','1950C8AB7B7541BF86293EFCC3DE11BA'),(3390,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','1950C8AB7B7541BF86293EFCC3DE11BA'),(3391,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','1950C8AB7B7541BF86293EFCC3DE11BA'),(3392,'d','main线程是守护线程 ','1950C8AB7B7541BF86293EFCC3DE11BA'),(3393,'a','public void method( int m){...}     ','EDA3CE4666164096B884AA77AE49FD8F'),(3394,'b','public int method(){...} ','EDA3CE4666164096B884AA77AE49FD8F'),(3395,'c','public void method2(){...}    ','EDA3CE4666164096B884AA77AE49FD8F'),(3396,'d','public int method(int m，float f ){...} ','EDA3CE4666164096B884AA77AE49FD8F'),(3397,'a','编译错误 ','DE8CB3D4EF7040D0A1C5550BF8AE0343'),(3398,'b','实现向文件record.dat追加写入字符a ','DE8CB3D4EF7040D0A1C5550BF8AE0343'),(3399,'c','实现向文件record.dat覆盖写入字符a ','DE8CB3D4EF7040D0A1C5550BF8AE0343'),(3400,'d','文件record.dat无任何内容 ','DE8CB3D4EF7040D0A1C5550BF8AE0343'),(3401,'a','public void method( int m){...}     ','5320AE5158BD4505BF94595E0706B221'),(3402,'b','public int method(){...} ','5320AE5158BD4505BF94595E0706B221'),(3403,'c','public void method2(){...}    ','5320AE5158BD4505BF94595E0706B221'),(3404,'d','public int method(int m，float f ){...} ','5320AE5158BD4505BF94595E0706B221'),(3405,'a','sleep方法 ','908A8F4C1C7843ED811DA1E7DA28A8E6'),(3406,'b','IO等待 ','908A8F4C1C7843ED811DA1E7DA28A8E6'),(3407,'c','yield方法 ','908A8F4C1C7843ED811DA1E7DA28A8E6'),(3408,'d','wait方法 ','908A8F4C1C7843ED811DA1E7DA28A8E6'),(3409,'a','long 1 = 4990  ','7C7BAB6646FA41E78D14165E562042B8'),(3410,'b','int i = 4L  ','7C7BAB6646FA41E78D14165E562042B8'),(3411,'c','float f =1.1  ','7C7BAB6646FA41E78D14165E562042B8'),(3412,'d','double d = 34.4','7C7BAB6646FA41E78D14165E562042B8'),(3413,'a','5.0','004FED8329A048698E81106D4FB1714C'),(3414,'b','4.0','004FED8329A048698E81106D4FB1714C'),(3415,'c','6.0','004FED8329A048698E81106D4FB1714C'),(3416,'d','finished','004FED8329A048698E81106D4FB1714C'),(3417,'a','start()    ','437DF6589C0B4094B8CDCC9320837C5D'),(3418,'b','init()    ','437DF6589C0B4094B8CDCC9320837C5D'),(3419,'c','run()    ','437DF6589C0B4094B8CDCC9320837C5D'),(3420,'d','main()  ','437DF6589C0B4094B8CDCC9320837C5D'),(3421,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','294B40B018DC459FB45D3B729EA40F51'),(3422,'b','垃圾收集将检查并释放不在使用的内存  ','294B40B018DC459FB45D3B729EA40F51'),(3423,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','294B40B018DC459FB45D3B729EA40F51'),(3424,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','294B40B018DC459FB45D3B729EA40F51'),(3425,'a','编译错误 ','1F7AFF2D6849427C85B7179BC91EE999'),(3426,'b','实现向文件record.dat追加写入字符a ','1F7AFF2D6849427C85B7179BC91EE999'),(3427,'c','实现向文件record.dat覆盖写入字符a ','1F7AFF2D6849427C85B7179BC91EE999'),(3428,'d','文件record.dat无任何内容 ','1F7AFF2D6849427C85B7179BC91EE999'),(3429,'a','s>>>=3   ','D01CD39ADA0643BB8BBD8799CFBBABFA'),(3430,'b','s[3]= “X”  ','D01CD39ADA0643BB8BBD8799CFBBABFA'),(3431,'c','int i = s.length()   ','D01CD39ADA0643BB8BBD8799CFBBABFA'),(3432,'d','s = s + 10 ','D01CD39ADA0643BB8BBD8799CFBBABFA'),(3433,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','65FB4E1B0D1D4DA88FD86813EE408BE6'),(3434,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','65FB4E1B0D1D4DA88FD86813EE408BE6'),(3435,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','65FB4E1B0D1D4DA88FD86813EE408BE6'),(3436,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','65FB4E1B0D1D4DA88FD86813EE408BE6'),(3437,'a','编译错误 ','5C632E6002924066A4DC0837103B09C1'),(3438,'b','抛出运行时异常 ','5C632E6002924066A4DC0837103B09C1'),(3439,'c','输出：sleep ','5C632E6002924066A4DC0837103B09C1'),(3440,'d','代码正常运行，但是无输出 ','5C632E6002924066A4DC0837103B09C1'),(3441,'a','通过调用stop()方法而停止的线程。 ','1882D20B302B4905ACE92D9EEA0C68BF'),(3442,'b','通过调用sleep()方法而停止的线程。 ','1882D20B302B4905ACE92D9EEA0C68BF'),(3443,'c','通过调用wait()方法而停止的线程。 ','1882D20B302B4905ACE92D9EEA0C68BF'),(3444,'d','通过调用suspend()方法而停止的线程。 ','1882D20B302B4905ACE92D9EEA0C68BF'),(3445,'a','private synchronized Object o; ','5BDDAB0369814D12BDB77D5D166AE312'),(3446,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','5BDDAB0369814D12BDB77D5D166AE312'),(3447,'c','public synchronized void go() { /* code here */ } ','5BDDAB0369814D12BDB77D5D166AE312'),(3448,'d','private synchronized(this) void go() { /* code here */ } ','5BDDAB0369814D12BDB77D5D166AE312'),(3449,'a','第3行抛出异常 ','6B0AC3609AAA45DB8AACE89DECE8BA9A'),(3450,'b','第1行抛出异常 ','6B0AC3609AAA45DB8AACE89DECE8BA9A'),(3451,'c','第5行抛出异常 ','6B0AC3609AAA45DB8AACE89DECE8BA9A'),(3452,'d','第3行代码成功执行 ','6B0AC3609AAA45DB8AACE89DECE8BA9A'),(3453,'a','编译错误 ','158A3DC7F8A64598A55B5E535AAA4E33'),(3454,'b','实现向文件record.dat追加写入字符a ','158A3DC7F8A64598A55B5E535AAA4E33'),(3455,'c','实现向文件record.dat覆盖写入字符a ','158A3DC7F8A64598A55B5E535AAA4E33'),(3456,'d','文件record.dat无任何内容 ','158A3DC7F8A64598A55B5E535AAA4E33'),(3457,'a','InputStreamReader','C52630B669114C938E4C6CFD83237612'),(3458,'b','BufferedReader','C52630B669114C938E4C6CFD83237612'),(3459,'c','FileInputStream','C52630B669114C938E4C6CFD83237612'),(3460,'d','InputStream','C52630B669114C938E4C6CFD83237612'),(3461,'a','栈是非线性结构        ','732BFC140FC449FDA43E0A8565B91BC4'),(3462,'b','栈是一种树状结构 ','732BFC140FC449FDA43E0A8565B91BC4'),(3463,'c','栈具有先进先出的特征  ','732BFC140FC449FDA43E0A8565B91BC4'),(3464,'d','栈具有后进先出的特征 ','732BFC140FC449FDA43E0A8565B91BC4'),(3465,'a','输出Exception ','1245D10B827A4C8BA46938B91F3FE7B8'),(3466,'b','输出A,B,Exception ','1245D10B827A4C8BA46938B91F3FE7B8'),(3467,'c','编译失败 ','1245D10B827A4C8BA46938B91F3FE7B8'),(3468,'d','在运行时抛出NullPointerException异常 ','1245D10B827A4C8BA46938B91F3FE7B8'),(3469,'a','Output is null.             ','3C2E5BABF1EE49048BA0442B71508B38'),(3470,'b','Output is 0 ','3C2E5BABF1EE49048BA0442B71508B38'),(3471,'c','编译时报错 ','3C2E5BABF1EE49048BA0442B71508B38'),(3472,'d','运行时报错','3C2E5BABF1EE49048BA0442B71508B38'),(3473,'a','一旦一个线程被创建，它就立即开始运行。  ','554C0EF546B644DC819DAB3C0601C8E7'),(3474,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','554C0EF546B644DC819DAB3C0601C8E7'),(3475,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','554C0EF546B644DC819DAB3C0601C8E7'),(3476,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','554C0EF546B644DC819DAB3C0601C8E7'),(3477,'a','5.0','8BCF6A6DAE2647D5B218B61197C4F4FD'),(3478,'b','4.0','8BCF6A6DAE2647D5B218B61197C4F4FD'),(3479,'c','6.0','8BCF6A6DAE2647D5B218B61197C4F4FD'),(3480,'d','finished','8BCF6A6DAE2647D5B218B61197C4F4FD'),(3481,'a','输出：test ','B7A26F4577054BF484B2AB4DE8FDE5D3'),(3482,'b','输出：Exception ','B7A26F4577054BF484B2AB4DE8FDE5D3'),(3483,'c','编译失败 ','B7A26F4577054BF484B2AB4DE8FDE5D3'),(3484,'d','输出：NullPointerException ','B7A26F4577054BF484B2AB4DE8FDE5D3'),(3485,'a','编译错误 ','3DD7907201814B189FB7196E351C2D97'),(3486,'b','抛出运行时异常 ','3DD7907201814B189FB7196E351C2D97'),(3487,'c','输出：sleep ','3DD7907201814B189FB7196E351C2D97'),(3488,'d','代码正常运行，但是无输出 ','3DD7907201814B189FB7196E351C2D97'),(3489,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','6507CAEDB7734678B37E5935C114BC40'),(3490,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','6507CAEDB7734678B37E5935C114BC40'),(3491,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','6507CAEDB7734678B37E5935C114BC40'),(3492,'d','new InputStreamReader(\"1.dat\") ; ','6507CAEDB7734678B37E5935C114BC40'),(3493,'a','private synchronized Object o; ','BCF551CB959B448B92F110D6E3A6CEB2'),(3494,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','BCF551CB959B448B92F110D6E3A6CEB2'),(3495,'c','public synchronized void go() { /* code here */ } ','BCF551CB959B448B92F110D6E3A6CEB2'),(3496,'d','private synchronized(this) void go() { /* code here */ } ','BCF551CB959B448B92F110D6E3A6CEB2'),(3497,'a','输出Exception ','D617B0ACF0EE4679874E27E5AF6B60D2'),(3498,'b','输出A,B,Exception ','D617B0ACF0EE4679874E27E5AF6B60D2'),(3499,'c','编译失败 ','D617B0ACF0EE4679874E27E5AF6B60D2'),(3500,'d','在运行时抛出NullPointerException异常 ','D617B0ACF0EE4679874E27E5AF6B60D2'),(3501,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','3B323001322F48679D600AD4FE9E7905'),(3502,'b','垃圾收集将检查并释放不在使用的内存  ','3B323001322F48679D600AD4FE9E7905'),(3503,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','3B323001322F48679D600AD4FE9E7905'),(3504,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','3B323001322F48679D600AD4FE9E7905'),(3505,'a','long 1 = 4990  ','55F32060A4724CCDB907F2721E946A4E'),(3506,'b','int i = 4L  ','55F32060A4724CCDB907F2721E946A4E'),(3507,'c','float f =1.1  ','55F32060A4724CCDB907F2721E946A4E'),(3508,'d','double d = 34.4','55F32060A4724CCDB907F2721E946A4E'),(3509,'a','const   ','828485D006AA456189A68DF541346251'),(3510,'b','NULL  ','828485D006AA456189A68DF541346251'),(3511,'c','false   ','828485D006AA456189A68DF541346251'),(3512,'d','this  ','828485D006AA456189A68DF541346251'),(3513,'a','sleep方法 ','5E0E5A153608468B952193473D436141'),(3514,'b','IO等待 ','5E0E5A153608468B952193473D436141'),(3515,'c','yield方法 ','5E0E5A153608468B952193473D436141'),(3516,'d','wait方法 ','5E0E5A153608468B952193473D436141'),(3517,'a','long 1 = 4990  ','8B64E9A279134DD4B915C45B06338079'),(3518,'b','int i = 4L  ','8B64E9A279134DD4B915C45B06338079'),(3519,'c','float f =1.1  ','8B64E9A279134DD4B915C45B06338079'),(3520,'d','double d = 34.4','8B64E9A279134DD4B915C45B06338079'),(3521,'a','const   ','0EA3C2EF5615434CBE9193C7401B4CD9'),(3522,'b','NULL  ','0EA3C2EF5615434CBE9193C7401B4CD9'),(3523,'c','false   ','0EA3C2EF5615434CBE9193C7401B4CD9'),(3524,'d','this  ','0EA3C2EF5615434CBE9193C7401B4CD9'),(3525,'a','第3行抛出异常 ','93039D2860D74E9D834EBCB32C9C1866'),(3526,'b','第1行抛出异常 ','93039D2860D74E9D834EBCB32C9C1866'),(3527,'c','第5行抛出异常 ','93039D2860D74E9D834EBCB32C9C1866'),(3528,'d','第3行代码成功执行 ','93039D2860D74E9D834EBCB32C9C1866'),(3529,'a','将private int m改为 protected int m  ','27C3A86660FE474AAC6D4BE318DE79A7'),(3530,'b','将private int m改为 public int m    ','27C3A86660FE474AAC6D4BE318DE79A7'),(3531,'c','将private int m改为 static int m     ','27C3A86660FE474AAC6D4BE318DE79A7'),(3532,'d','将private int m改为int m ','27C3A86660FE474AAC6D4BE318DE79A7'),(3533,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','F99150C327694362A7C726135D43A43A'),(3534,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','F99150C327694362A7C726135D43A43A'),(3535,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','F99150C327694362A7C726135D43A43A'),(3536,'d','new InputStreamReader(\"dat\") ; ','F99150C327694362A7C726135D43A43A'),(3537,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','181DC739D0564E7284A1CBD8086907A1'),(3538,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','181DC739D0564E7284A1CBD8086907A1'),(3539,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','181DC739D0564E7284A1CBD8086907A1'),(3540,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','181DC739D0564E7284A1CBD8086907A1'),(3541,'a','输出：test ','2F7173F3FB624EFF87A6962C823F2D2D'),(3542,'b','输出：Exception ','2F7173F3FB624EFF87A6962C823F2D2D'),(3543,'c','编译失败 ','2F7173F3FB624EFF87A6962C823F2D2D'),(3544,'d','输出：NullPointerException ','2F7173F3FB624EFF87A6962C823F2D2D'),(3545,'a','栈是非线性结构        ','D824EA6F59D44636BD5AC90BD9F900CF'),(3546,'b','栈是一种树状结构 ','D824EA6F59D44636BD5AC90BD9F900CF'),(3547,'c','栈具有先进先出的特征  ','D824EA6F59D44636BD5AC90BD9F900CF'),(3548,'d','栈具有后进先出的特征 ','D824EA6F59D44636BD5AC90BD9F900CF'),(3549,'a','输出：4 ','6AFFA7CA9F7C409CA051443BCDF70E2C'),(3550,'b','在运行时抛出NullPointerException异常 ','6AFFA7CA9F7C409CA051443BCDF70E2C'),(3551,'c','在运行时抛出NumberFormatException异常 ','6AFFA7CA9F7C409CA051443BCDF70E2C'),(3552,'d','在运行时抛出IllegalStateException异常 ','6AFFA7CA9F7C409CA051443BCDF70E2C'),(3553,'a','private synchronized Object o; ','B14F2F5F954B4FACA0E545D8EF431A93'),(3554,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','B14F2F5F954B4FACA0E545D8EF431A93'),(3555,'c','public synchronized void go() { /* code here */ } ','B14F2F5F954B4FACA0E545D8EF431A93'),(3556,'d','private synchronized(this) void go() { /* code here */ } ','B14F2F5F954B4FACA0E545D8EF431A93'),(3557,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','8EBFD285D0854CB693A012A34D031D16'),(3558,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','8EBFD285D0854CB693A012A34D031D16'),(3559,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','8EBFD285D0854CB693A012A34D031D16'),(3560,'d','new InputStreamReader(\"dat\") ; ','8EBFD285D0854CB693A012A34D031D16'),(3561,'a','编译错误 ','9FA48EFABC674BBB9FBE6B4F8A2AE221'),(3562,'b','实现向文件record.dat追加写入字符a ','9FA48EFABC674BBB9FBE6B4F8A2AE221'),(3563,'c','实现向文件record.dat覆盖写入字符a ','9FA48EFABC674BBB9FBE6B4F8A2AE221'),(3564,'d','文件record.dat无任何内容 ','9FA48EFABC674BBB9FBE6B4F8A2AE221'),(3565,'a','编译错误 ','38224DC43C514D3BB68F81BF29735E85'),(3566,'b','实现向文件record.dat追加写入字符a ','38224DC43C514D3BB68F81BF29735E85'),(3567,'c','实现向文件record.dat覆盖写入字符a ','38224DC43C514D3BB68F81BF29735E85'),(3568,'d','文件record.dat无任何内容 ','38224DC43C514D3BB68F81BF29735E85'),(3569,'a','名为dtThread的线程为守护线程 ','F954012773EC4DB293D8CF1F17575C80'),(3570,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','F954012773EC4DB293D8CF1F17575C80'),(3571,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','F954012773EC4DB293D8CF1F17575C80'),(3572,'d','main线程是守护线程 ','F954012773EC4DB293D8CF1F17575C80'),(3573,'a','编译错误 ','B142E8B7E0C04FEE9CB7BB19BAB731FF'),(3574,'b','抛出运行时异常 ','B142E8B7E0C04FEE9CB7BB19BAB731FF'),(3575,'c','输出：sleep ','B142E8B7E0C04FEE9CB7BB19BAB731FF'),(3576,'d','代码正常运行，但是无输出 ','B142E8B7E0C04FEE9CB7BB19BAB731FF'),(3577,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','D3F1C927CA474084948B2CF27870D957'),(3578,'b','垃圾收集将检查并释放不在使用的内存  ','D3F1C927CA474084948B2CF27870D957'),(3579,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','D3F1C927CA474084948B2CF27870D957'),(3580,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','D3F1C927CA474084948B2CF27870D957'),(3581,'a','一旦一个线程被创建，它就立即开始运行。  ','7074E3BF6A124D3E992167C6BD58E767'),(3582,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','7074E3BF6A124D3E992167C6BD58E767'),(3583,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','7074E3BF6A124D3E992167C6BD58E767'),(3584,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','7074E3BF6A124D3E992167C6BD58E767'),(3585,'a','通过调用stop()方法而停止的线程。 ','C02B55F3CE6442628F670783207C5362'),(3586,'b','通过调用sleep()方法而停止的线程。 ','C02B55F3CE6442628F670783207C5362'),(3587,'c','通过调用wait()方法而停止的线程。 ','C02B55F3CE6442628F670783207C5362'),(3588,'d','通过调用suspend()方法而停止的线程。 ','C02B55F3CE6442628F670783207C5362'),(3589,'a','public void method( int m){...}     ','DEA25DFDECC24608A62174A5A0E0EDE4'),(3590,'b','public int method(){...} ','DEA25DFDECC24608A62174A5A0E0EDE4'),(3591,'c','public void method2(){...}    ','DEA25DFDECC24608A62174A5A0E0EDE4'),(3592,'d','public int method(int m，float f ){...} ','DEA25DFDECC24608A62174A5A0E0EDE4'),(3593,'a','sleep方法 ','2C1F6ED6BBBA45E2A45655583F2385CD'),(3594,'b','IO等待 ','2C1F6ED6BBBA45E2A45655583F2385CD'),(3595,'c','yield方法 ','2C1F6ED6BBBA45E2A45655583F2385CD'),(3596,'d','wait方法 ','2C1F6ED6BBBA45E2A45655583F2385CD'),(3597,'a','编译错误 ','B48647378F8E400FBA08CAD34666019C'),(3598,'b','抛出运行时异常 ','B48647378F8E400FBA08CAD34666019C'),(3599,'c','输出：sleep ','B48647378F8E400FBA08CAD34666019C'),(3600,'d','代码正常运行，但是无输出 ','B48647378F8E400FBA08CAD34666019C'),(3601,'a','s>>>=3   ','908A80EC085E4AB0AEC7092992848387'),(3602,'b','s[3]= “X”  ','908A80EC085E4AB0AEC7092992848387'),(3603,'c','int i = s.length()   ','908A80EC085E4AB0AEC7092992848387'),(3604,'d','s = s + 10 ','908A80EC085E4AB0AEC7092992848387'),(3605,'a','m.length()    ','C7DCF27B756D4CC18CC2DEAF6DEBC532'),(3606,'b','m.length   ','C7DCF27B756D4CC18CC2DEAF6DEBC532'),(3607,'c','m.length()+1   ','C7DCF27B756D4CC18CC2DEAF6DEBC532'),(3608,'d','m.length-1','C7DCF27B756D4CC18CC2DEAF6DEBC532'),(3609,'a','const   ','62F28AE7A3664CB79BED79E730FA1D77'),(3610,'b','NULL  ','62F28AE7A3664CB79BED79E730FA1D77'),(3611,'c','false   ','62F28AE7A3664CB79BED79E730FA1D77'),(3612,'d','this  ','62F28AE7A3664CB79BED79E730FA1D77'),(3613,'a','一旦一个线程被创建，它就立即开始运行。  ','8256DAB3DBE14B98A7C537FC28D76E5F'),(3614,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','8256DAB3DBE14B98A7C537FC28D76E5F'),(3615,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','8256DAB3DBE14B98A7C537FC28D76E5F'),(3616,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','8256DAB3DBE14B98A7C537FC28D76E5F'),(3617,'a','编译错误 ','9EF38305650842FB85394DA6D1A46EA0'),(3618,'b','程序可以通过编译，运行后文件company.txt没有任何改变','9EF38305650842FB85394DA6D1A46EA0'),(3619,'c','程序可以通过编译，运行后文件company.txt的长度变为0','9EF38305650842FB85394DA6D1A46EA0'),(3620,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','9EF38305650842FB85394DA6D1A46EA0'),(3621,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','852F76DA2073465C847D5693152356FA'),(3622,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','852F76DA2073465C847D5693152356FA'),(3623,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','852F76DA2073465C847D5693152356FA'),(3624,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','852F76DA2073465C847D5693152356FA'),(3625,'a','通过调用stop()方法而停止的线程。 ','A6E4413B7CBF44B2A5D2A50F5FA27076'),(3626,'b','通过调用sleep()方法而停止的线程。 ','A6E4413B7CBF44B2A5D2A50F5FA27076'),(3627,'c','通过调用wait()方法而停止的线程。 ','A6E4413B7CBF44B2A5D2A50F5FA27076'),(3628,'d','通过调用suspend()方法而停止的线程。 ','A6E4413B7CBF44B2A5D2A50F5FA27076'),(3629,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','CE05EB019C8A4EC0A8CF188BB9DCB648'),(3630,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','CE05EB019C8A4EC0A8CF188BB9DCB648'),(3631,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','CE05EB019C8A4EC0A8CF188BB9DCB648'),(3632,'d','new InputStreamReader(\"1.dat\") ; ','CE05EB019C8A4EC0A8CF188BB9DCB648'),(3633,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','4C5E0A40957A48C39CB85958577E4994'),(3634,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','4C5E0A40957A48C39CB85958577E4994'),(3635,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','4C5E0A40957A48C39CB85958577E4994'),(3636,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','4C5E0A40957A48C39CB85958577E4994'),(3637,'a','s>>>=3   ','757AD1D494B94519BC03443347011325'),(3638,'b','s[3]= “X”  ','757AD1D494B94519BC03443347011325'),(3639,'c','int i = s.length()   ','757AD1D494B94519BC03443347011325'),(3640,'d','s = s + 10 ','757AD1D494B94519BC03443347011325'),(3641,'a','编译错误 ','024CE98B628C4D3D881C30D98196982C'),(3642,'b','实现向文件record.dat追加写入字符a ','024CE98B628C4D3D881C30D98196982C'),(3643,'c','实现向文件record.dat覆盖写入字符a ','024CE98B628C4D3D881C30D98196982C'),(3644,'d','文件record.dat无任何内容 ','024CE98B628C4D3D881C30D98196982C'),(3645,'a','public void method( int m){...}     ','C5F7E3D877BD492AB2BC86817A9B77CD'),(3646,'b','public int method(){...} ','C5F7E3D877BD492AB2BC86817A9B77CD'),(3647,'c','public void method2(){...}    ','C5F7E3D877BD492AB2BC86817A9B77CD'),(3648,'d','public int method(int m，float f ){...} ','C5F7E3D877BD492AB2BC86817A9B77CD'),(3649,'a','long 1 = 4990  ','0504A7BB1F134AD286FD8CA7CA31759E'),(3650,'b','int i = 4L  ','0504A7BB1F134AD286FD8CA7CA31759E'),(3651,'c','float f =1.1  ','0504A7BB1F134AD286FD8CA7CA31759E'),(3652,'d','double d = 34.4','0504A7BB1F134AD286FD8CA7CA31759E'),(3653,'a','第3行抛出异常 ','5879DC37332E44919C45BCB889E580FC'),(3654,'b','第1行抛出异常 ','5879DC37332E44919C45BCB889E580FC'),(3655,'c','第5行抛出异常 ','5879DC37332E44919C45BCB889E580FC'),(3656,'d','第3行代码成功执行 ','5879DC37332E44919C45BCB889E580FC'),(3657,'a','将private int m改为 protected int m  ','04A4028A95844785935C780C9DB74A53'),(3658,'b','将private int m改为 public int m    ','04A4028A95844785935C780C9DB74A53'),(3659,'c','将private int m改为 static int m     ','04A4028A95844785935C780C9DB74A53'),(3660,'d','将private int m改为int m ','04A4028A95844785935C780C9DB74A53'),(3661,'a','输出Exception ','6CDFE8F6B700401AA8745C3B0DC272EF'),(3662,'b','输出A,B,Exception ','6CDFE8F6B700401AA8745C3B0DC272EF'),(3663,'c','编译失败 ','6CDFE8F6B700401AA8745C3B0DC272EF'),(3664,'d','在运行时抛出NullPointerException异常 ','6CDFE8F6B700401AA8745C3B0DC272EF'),(3665,'a','输出：test ','1E9BF6CCC36648C9962463A1C1B2B09F'),(3666,'b','输出：Exception ','1E9BF6CCC36648C9962463A1C1B2B09F'),(3667,'c','编译失败 ','1E9BF6CCC36648C9962463A1C1B2B09F'),(3668,'d','输出：NullPointerException ','1E9BF6CCC36648C9962463A1C1B2B09F'),(3669,'a','编译错误 ','6FA02E0CD577441595BC5412F065817C'),(3670,'b','实现向文件record.dat追加写入字符a ','6FA02E0CD577441595BC5412F065817C'),(3671,'c','实现向文件record.dat覆盖写入字符a ','6FA02E0CD577441595BC5412F065817C'),(3672,'d','文件record.dat无任何内容 ','6FA02E0CD577441595BC5412F065817C'),(3673,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','BAC57760D094472299A1A521C2C0C298'),(3674,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','BAC57760D094472299A1A521C2C0C298'),(3675,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','BAC57760D094472299A1A521C2C0C298'),(3676,'d','new InputStreamReader(\"1.dat\") ; ','BAC57760D094472299A1A521C2C0C298'),(3677,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','02EC582ABC144C839AE1A5962726A7D2'),(3678,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','02EC582ABC144C839AE1A5962726A7D2'),(3679,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','02EC582ABC144C839AE1A5962726A7D2'),(3680,'d','new InputStreamReader(\"dat\") ; ','02EC582ABC144C839AE1A5962726A7D2'),(3681,'a','const   ','57EF3BE1298845C588A767D5FAEEAFBD'),(3682,'b','NULL  ','57EF3BE1298845C588A767D5FAEEAFBD'),(3683,'c','false   ','57EF3BE1298845C588A767D5FAEEAFBD'),(3684,'d','this  ','57EF3BE1298845C588A767D5FAEEAFBD'),(3685,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','A32AEE8A60FD474EA251E4D233FBE12E'),(3686,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','A32AEE8A60FD474EA251E4D233FBE12E'),(3687,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','A32AEE8A60FD474EA251E4D233FBE12E'),(3688,'d','new InputStreamReader(\"dat\") ; ','A32AEE8A60FD474EA251E4D233FBE12E'),(3689,'a','const   ','1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(3690,'b','NULL  ','1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(3691,'c','false   ','1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(3692,'d','this  ','1CD68ACD821A4BA1A2EE4E8A8A6FEF8F'),(3693,'a','编译错误 ','54DFAD28A6E04C439CEE332C7FF3E75C'),(3694,'b','程序可以通过编译，运行后文件company.txt没有任何改变','54DFAD28A6E04C439CEE332C7FF3E75C'),(3695,'c','程序可以通过编译，运行后文件company.txt的长度变为0','54DFAD28A6E04C439CEE332C7FF3E75C'),(3696,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','54DFAD28A6E04C439CEE332C7FF3E75C'),(3697,'a','栈是非线性结构        ','71AB3318078E49FAA5554D2F12FFEE48'),(3698,'b','栈是一种树状结构 ','71AB3318078E49FAA5554D2F12FFEE48'),(3699,'c','栈具有先进先出的特征  ','71AB3318078E49FAA5554D2F12FFEE48'),(3700,'d','栈具有后进先出的特征 ','71AB3318078E49FAA5554D2F12FFEE48'),(3701,'a','编译错误 ','C79378050CBC42CDA37AAB7972E2CD9D'),(3702,'b','实现向文件record.dat追加写入字符a ','C79378050CBC42CDA37AAB7972E2CD9D'),(3703,'c','实现向文件record.dat覆盖写入字符a ','C79378050CBC42CDA37AAB7972E2CD9D'),(3704,'d','文件record.dat无任何内容 ','C79378050CBC42CDA37AAB7972E2CD9D'),(3705,'a','第3行抛出异常 ','D537C851221A46D98DB6776091F8E571'),(3706,'b','第1行抛出异常 ','D537C851221A46D98DB6776091F8E571'),(3707,'c','第5行抛出异常 ','D537C851221A46D98DB6776091F8E571'),(3708,'d','第3行代码成功执行 ','D537C851221A46D98DB6776091F8E571'),(3709,'a','将private int m改为 protected int m  ','7D0474B3E4FD4E809AD9238C64F1EE62'),(3710,'b','将private int m改为 public int m    ','7D0474B3E4FD4E809AD9238C64F1EE62'),(3711,'c','将private int m改为 static int m     ','7D0474B3E4FD4E809AD9238C64F1EE62'),(3712,'d','将private int m改为int m ','7D0474B3E4FD4E809AD9238C64F1EE62'),(3713,'a','s>>>=3   ','EA6813301FCC43538DF356CB5A1B8A6F'),(3714,'b','s[3]= “X”  ','EA6813301FCC43538DF356CB5A1B8A6F'),(3715,'c','int i = s.length()   ','EA6813301FCC43538DF356CB5A1B8A6F'),(3716,'d','s = s + 10 ','EA6813301FCC43538DF356CB5A1B8A6F'),(3717,'a','名为dtThread的线程为守护线程 ','0E1C9D489C774D03863E069C49F81CE5'),(3718,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','0E1C9D489C774D03863E069C49F81CE5'),(3719,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','0E1C9D489C774D03863E069C49F81CE5'),(3720,'d','main线程是守护线程 ','0E1C9D489C774D03863E069C49F81CE5'),(3721,'a','5.0','63CBB2E07E3244678AF540F65F466919'),(3722,'b','4.0','63CBB2E07E3244678AF540F65F466919'),(3723,'c','6.0','63CBB2E07E3244678AF540F65F466919'),(3724,'d','finished','63CBB2E07E3244678AF540F65F466919'),(3725,'a','long 1 = 4990  ','B5BBF42AF8214339B290FC03DC28EBAA'),(3726,'b','int i = 4L  ','B5BBF42AF8214339B290FC03DC28EBAA'),(3727,'c','float f =1.1  ','B5BBF42AF8214339B290FC03DC28EBAA'),(3728,'d','double d = 34.4','B5BBF42AF8214339B290FC03DC28EBAA'),(3729,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','CBF94654BCE8403483579FC6C6307BCB'),(3730,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','CBF94654BCE8403483579FC6C6307BCB'),(3731,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','CBF94654BCE8403483579FC6C6307BCB'),(3732,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','CBF94654BCE8403483579FC6C6307BCB'),(3733,'a','sleep方法 ','078FFB388D2247C782BAB0AC771092A9'),(3734,'b','IO等待 ','078FFB388D2247C782BAB0AC771092A9'),(3735,'c','yield方法 ','078FFB388D2247C782BAB0AC771092A9'),(3736,'d','wait方法 ','078FFB388D2247C782BAB0AC771092A9'),(3737,'a','m.length()    ','47C4BDDA23B748D7B0823483717163D4'),(3738,'b','m.length   ','47C4BDDA23B748D7B0823483717163D4'),(3739,'c','m.length()+1   ','47C4BDDA23B748D7B0823483717163D4'),(3740,'d','m.length-1','47C4BDDA23B748D7B0823483717163D4'),(3741,'a','输出Exception ','4C84A3529A1C42AD9B7314722E90FB45'),(3742,'b','输出A,B,Exception ','4C84A3529A1C42AD9B7314722E90FB45'),(3743,'c','编译失败 ','4C84A3529A1C42AD9B7314722E90FB45'),(3744,'d','在运行时抛出NullPointerException异常 ','4C84A3529A1C42AD9B7314722E90FB45'),(3745,'a','输出：test ','4D4E4BE3FB2D40B3AD56D685772D76BF'),(3746,'b','输出：Exception ','4D4E4BE3FB2D40B3AD56D685772D76BF'),(3747,'c','编译失败 ','4D4E4BE3FB2D40B3AD56D685772D76BF'),(3748,'d','输出：NullPointerException ','4D4E4BE3FB2D40B3AD56D685772D76BF'),(3749,'a','将private int m改为 protected int m  ','B0B6F2FE273C4D3D86B5A30D1A6EF076'),(3750,'b','将private int m改为 public int m    ','B0B6F2FE273C4D3D86B5A30D1A6EF076'),(3751,'c','将private int m改为 static int m     ','B0B6F2FE273C4D3D86B5A30D1A6EF076'),(3752,'d','将private int m改为int m ','B0B6F2FE273C4D3D86B5A30D1A6EF076'),(3753,'a','Output is null.             ','540A6A5C87CC4EC99C7CDC30D629EC23'),(3754,'b','Output is 0 ','540A6A5C87CC4EC99C7CDC30D629EC23'),(3755,'c','编译时报错 ','540A6A5C87CC4EC99C7CDC30D629EC23'),(3756,'d','运行时报错','540A6A5C87CC4EC99C7CDC30D629EC23'),(3757,'a','编译错误 ','96EC57D4BFEB47769A2C09507F2ABFC5'),(3758,'b','抛出运行时异常 ','96EC57D4BFEB47769A2C09507F2ABFC5'),(3759,'c','输出：bar ','96EC57D4BFEB47769A2C09507F2ABFC5'),(3760,'d','代码正常运行，但是无输出 ','96EC57D4BFEB47769A2C09507F2ABFC5'),(3761,'a','编译错误 ','5DDF9F25890D4FF392644BBC735DCD7A'),(3762,'b','抛出运行时异常 ','5DDF9F25890D4FF392644BBC735DCD7A'),(3763,'c','输出：bar ','5DDF9F25890D4FF392644BBC735DCD7A'),(3764,'d','代码正常运行，但是无输出 ','5DDF9F25890D4FF392644BBC735DCD7A'),(3765,'a','名为dtThread的线程为守护线程 ','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(3766,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(3767,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(3768,'d','main线程是守护线程 ','C79C4DC5F66543A5A78AFE7DAEDF3DBB'),(3769,'a','sleep方法 ','D6609FA578754C77BF08E5C5158C3C55'),(3770,'b','IO等待 ','D6609FA578754C77BF08E5C5158C3C55'),(3771,'c','yield方法 ','D6609FA578754C77BF08E5C5158C3C55'),(3772,'d','wait方法 ','D6609FA578754C77BF08E5C5158C3C55'),(3773,'a','private synchronized Object o; ','568D4745298047DBB255B73E61B7EB73'),(3774,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','568D4745298047DBB255B73E61B7EB73'),(3775,'c','public synchronized void go() { /* code here */ } ','568D4745298047DBB255B73E61B7EB73'),(3776,'d','private synchronized(this) void go() { /* code here */ } ','568D4745298047DBB255B73E61B7EB73'),(3777,'a','Output is null.             ','AC7E0D0B358245DBAE503B16DB7CCA98'),(3778,'b','Output is 0 ','AC7E0D0B358245DBAE503B16DB7CCA98'),(3779,'c','编译时报错 ','AC7E0D0B358245DBAE503B16DB7CCA98'),(3780,'d','运行时报错','AC7E0D0B358245DBAE503B16DB7CCA98'),(3781,'a','编译错误 ','63FBAAA7188B4B8EABA1657645A73FE1'),(3782,'b','实现向文件record.dat追加写入字符a ','63FBAAA7188B4B8EABA1657645A73FE1'),(3783,'c','实现向文件record.dat覆盖写入字符a ','63FBAAA7188B4B8EABA1657645A73FE1'),(3784,'d','文件record.dat无任何内容 ','63FBAAA7188B4B8EABA1657645A73FE1'),(3785,'a','m.length()    ','B42101106B1A4427ABD5830DE2862C73'),(3786,'b','m.length   ','B42101106B1A4427ABD5830DE2862C73'),(3787,'c','m.length()+1   ','B42101106B1A4427ABD5830DE2862C73'),(3788,'d','m.length-1','B42101106B1A4427ABD5830DE2862C73'),(3789,'a','输出Exception ','B05B38C6A9314D59BD85EB40E2D0B4CF'),(3790,'b','输出A,B,Exception ','B05B38C6A9314D59BD85EB40E2D0B4CF'),(3791,'c','编译失败 ','B05B38C6A9314D59BD85EB40E2D0B4CF'),(3792,'d','在运行时抛出NullPointerException异常 ','B05B38C6A9314D59BD85EB40E2D0B4CF'),(3793,'a','5.0','A4FD8B6880C44CE38651469A23EED233'),(3794,'b','4.0','A4FD8B6880C44CE38651469A23EED233'),(3795,'c','6.0','A4FD8B6880C44CE38651469A23EED233'),(3796,'d','finished','A4FD8B6880C44CE38651469A23EED233'),(3797,'a','编译错误 ','F97283AD17A94F358B7BA73FBACF95CE'),(3798,'b','抛出运行时异常 ','F97283AD17A94F358B7BA73FBACF95CE'),(3799,'c','输出：bar ','F97283AD17A94F358B7BA73FBACF95CE'),(3800,'d','代码正常运行，但是无输出 ','F97283AD17A94F358B7BA73FBACF95CE'),(3801,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','045D8C8628C742018180B2C2092000F5'),(3802,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','045D8C8628C742018180B2C2092000F5'),(3803,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','045D8C8628C742018180B2C2092000F5'),(3804,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','045D8C8628C742018180B2C2092000F5'),(3805,'a','输出：4 ','5087D7A57CF64EFFA049F4BEDDEFA162'),(3806,'b','在运行时抛出NullPointerException异常 ','5087D7A57CF64EFFA049F4BEDDEFA162'),(3807,'c','在运行时抛出NumberFormatException异常 ','5087D7A57CF64EFFA049F4BEDDEFA162'),(3808,'d','在运行时抛出IllegalStateException异常 ','5087D7A57CF64EFFA049F4BEDDEFA162'),(3809,'a','编译错误 ','AED7FF5036E94F89A3601D15F1C29959'),(3810,'b','实现向文件record.dat追加写入字符a ','AED7FF5036E94F89A3601D15F1C29959'),(3811,'c','实现向文件record.dat覆盖写入字符a ','AED7FF5036E94F89A3601D15F1C29959'),(3812,'d','文件record.dat无任何内容 ','AED7FF5036E94F89A3601D15F1C29959'),(3813,'a','private synchronized Object o; ','8A8142C34AD24DE4B6358FC6AC18938F'),(3814,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','8A8142C34AD24DE4B6358FC6AC18938F'),(3815,'c','public synchronized void go() { /* code here */ } ','8A8142C34AD24DE4B6358FC6AC18938F'),(3816,'d','private synchronized(this) void go() { /* code here */ } ','8A8142C34AD24DE4B6358FC6AC18938F'),(3817,'a','long 1 = 4990  ','1F3FBE72591F475AB969A4F8EF4E2C60'),(3818,'b','int i = 4L  ','1F3FBE72591F475AB969A4F8EF4E2C60'),(3819,'c','float f =1.1  ','1F3FBE72591F475AB969A4F8EF4E2C60'),(3820,'d','double d = 34.4','1F3FBE72591F475AB969A4F8EF4E2C60'),(3821,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','A54F2711DFE34E4E9CA401134288C91D'),(3822,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','A54F2711DFE34E4E9CA401134288C91D'),(3823,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','A54F2711DFE34E4E9CA401134288C91D'),(3824,'d','new InputStreamReader(\"dat\") ; ','A54F2711DFE34E4E9CA401134288C91D'),(3825,'a','名为dtThread的线程为守护线程 ','653AF4E8D2A14A5D9BEC74C434E4D68B'),(3826,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','653AF4E8D2A14A5D9BEC74C434E4D68B'),(3827,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','653AF4E8D2A14A5D9BEC74C434E4D68B'),(3828,'d','main线程是守护线程 ','653AF4E8D2A14A5D9BEC74C434E4D68B'),(3829,'a','public void method( int m){...}     ','87BEB1C026074995862847610484E7AF'),(3830,'b','public int method(){...} ','87BEB1C026074995862847610484E7AF'),(3831,'c','public void method2(){...}    ','87BEB1C026074995862847610484E7AF'),(3832,'d','public int method(int m，float f ){...} ','87BEB1C026074995862847610484E7AF'),(3833,'a','栈是非线性结构        ','7076C9D204BF49FBB92AAA7277B38ED0'),(3834,'b','栈是一种树状结构 ','7076C9D204BF49FBB92AAA7277B38ED0'),(3835,'c','栈具有先进先出的特征  ','7076C9D204BF49FBB92AAA7277B38ED0'),(3836,'d','栈具有后进先出的特征 ','7076C9D204BF49FBB92AAA7277B38ED0'),(3837,'a','栈是非线性结构        ','81E6E99EC5A24830A2C530F91C38ABAC'),(3838,'b','栈是一种树状结构 ','81E6E99EC5A24830A2C530F91C38ABAC'),(3839,'c','栈具有先进先出的特征  ','81E6E99EC5A24830A2C530F91C38ABAC'),(3840,'d','栈具有后进先出的特征 ','81E6E99EC5A24830A2C530F91C38ABAC'),(3841,'a','通过调用stop()方法而停止的线程。 ','15C50F987BAA495F8881A71259A22E2A'),(3842,'b','通过调用sleep()方法而停止的线程。 ','15C50F987BAA495F8881A71259A22E2A'),(3843,'c','通过调用wait()方法而停止的线程。 ','15C50F987BAA495F8881A71259A22E2A'),(3844,'d','通过调用suspend()方法而停止的线程。 ','15C50F987BAA495F8881A71259A22E2A'),(3845,'a','编译错误 ','7B9A73BE7B9E417EAC73DA069CD728C5'),(3846,'b','实现向文件record.dat追加写入字符a ','7B9A73BE7B9E417EAC73DA069CD728C5'),(3847,'c','实现向文件record.dat覆盖写入字符a ','7B9A73BE7B9E417EAC73DA069CD728C5'),(3848,'d','文件record.dat无任何内容 ','7B9A73BE7B9E417EAC73DA069CD728C5'),(3849,'a','InputStreamReader','BF71E4E2100443888F7017A215D0EDDD'),(3850,'b','BufferedReader','BF71E4E2100443888F7017A215D0EDDD'),(3851,'c','FileInputStream','BF71E4E2100443888F7017A215D0EDDD'),(3852,'d','InputStream','BF71E4E2100443888F7017A215D0EDDD'),(3853,'a','输出：4 ','19D0E4AB948F454185705481CF21931D'),(3854,'b','在运行时抛出NullPointerException异常 ','19D0E4AB948F454185705481CF21931D'),(3855,'c','在运行时抛出NumberFormatException异常 ','19D0E4AB948F454185705481CF21931D'),(3856,'d','在运行时抛出IllegalStateException异常 ','19D0E4AB948F454185705481CF21931D'),(3857,'a','输出：4 ','B9389C4D870D4434B9B4A5EFB28D845A'),(3858,'b','在运行时抛出NullPointerException异常 ','B9389C4D870D4434B9B4A5EFB28D845A'),(3859,'c','在运行时抛出NumberFormatException异常 ','B9389C4D870D4434B9B4A5EFB28D845A'),(3860,'d','在运行时抛出IllegalStateException异常 ','B9389C4D870D4434B9B4A5EFB28D845A'),(3861,'a','start()    ','D5BC53403A504EE087798448704A8D3D'),(3862,'b','init()    ','D5BC53403A504EE087798448704A8D3D'),(3863,'c','run()    ','D5BC53403A504EE087798448704A8D3D'),(3864,'d','main()  ','D5BC53403A504EE087798448704A8D3D'),(3865,'a','Output is null.             ','4DA5EB8FAF7B486888DE6396DAA20F10'),(3866,'b','Output is 0 ','4DA5EB8FAF7B486888DE6396DAA20F10'),(3867,'c','编译时报错 ','4DA5EB8FAF7B486888DE6396DAA20F10'),(3868,'d','运行时报错','4DA5EB8FAF7B486888DE6396DAA20F10'),(3869,'a','编译错误 ','15E1CB05FC584DBBB285870255A56FE7'),(3870,'b','程序可以通过编译，运行后文件company.txt没有任何改变','15E1CB05FC584DBBB285870255A56FE7'),(3871,'c','程序可以通过编译，运行后文件company.txt的长度变为0','15E1CB05FC584DBBB285870255A56FE7'),(3872,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','15E1CB05FC584DBBB285870255A56FE7'),(3873,'a','一旦一个线程被创建，它就立即开始运行。  ','B81C34972A854BA0A3DFC01452426EC7'),(3874,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','B81C34972A854BA0A3DFC01452426EC7'),(3875,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','B81C34972A854BA0A3DFC01452426EC7'),(3876,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','B81C34972A854BA0A3DFC01452426EC7'),(3877,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','D4BE8BDA77FE4847AC14112E841C5A8F'),(3878,'b','垃圾收集将检查并释放不在使用的内存  ','D4BE8BDA77FE4847AC14112E841C5A8F'),(3879,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','D4BE8BDA77FE4847AC14112E841C5A8F'),(3880,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','D4BE8BDA77FE4847AC14112E841C5A8F'),(3881,'a','InputStreamReader','B4CACB1D109C492BA9A9D9896893BECE'),(3882,'b','BufferedReader','B4CACB1D109C492BA9A9D9896893BECE'),(3883,'c','FileInputStream','B4CACB1D109C492BA9A9D9896893BECE'),(3884,'d','InputStream','B4CACB1D109C492BA9A9D9896893BECE'),(3885,'a','InputStreamReader','DF346032A4BA45CB84F751E6B8C520B1'),(3886,'b','BufferedReader','DF346032A4BA45CB84F751E6B8C520B1'),(3887,'c','FileInputStream','DF346032A4BA45CB84F751E6B8C520B1'),(3888,'d','InputStream','DF346032A4BA45CB84F751E6B8C520B1'),(3889,'a','start()    ','CE213BFD587341DBB6BE9E3CC48C622C'),(3890,'b','init()    ','CE213BFD587341DBB6BE9E3CC48C622C'),(3891,'c','run()    ','CE213BFD587341DBB6BE9E3CC48C622C'),(3892,'d','main()  ','CE213BFD587341DBB6BE9E3CC48C622C'),(3893,'a','start()    ','841C28A31A474814A7274D551B88E105'),(3894,'b','init()    ','841C28A31A474814A7274D551B88E105'),(3895,'c','run()    ','841C28A31A474814A7274D551B88E105'),(3896,'d','main()  ','841C28A31A474814A7274D551B88E105'),(3897,'a','输出：test ','458514E21CEA46949A398E823F66A43D'),(3898,'b','输出：Exception ','458514E21CEA46949A398E823F66A43D'),(3899,'c','编译失败 ','458514E21CEA46949A398E823F66A43D'),(3900,'d','输出：NullPointerException ','458514E21CEA46949A398E823F66A43D'),(3901,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','42EF937022E541409542B7DB395AAAA0'),(3902,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','42EF937022E541409542B7DB395AAAA0'),(3903,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','42EF937022E541409542B7DB395AAAA0'),(3904,'d','new InputStreamReader(\"1.dat\") ; ','42EF937022E541409542B7DB395AAAA0'),(3905,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','EAB90D4E56C840A5A3F04D416F26AED7'),(3906,'b','垃圾收集将检查并释放不在使用的内存  ','EAB90D4E56C840A5A3F04D416F26AED7'),(3907,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','EAB90D4E56C840A5A3F04D416F26AED7'),(3908,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','EAB90D4E56C840A5A3F04D416F26AED7'),(3909,'a','编译错误 ','0CA93240428A402C9144B742CAAE165D'),(3910,'b','抛出运行时异常 ','0CA93240428A402C9144B742CAAE165D'),(3911,'c','输出：bar ','0CA93240428A402C9144B742CAAE165D'),(3912,'d','代码正常运行，但是无输出 ','0CA93240428A402C9144B742CAAE165D'),(3913,'a','编译错误 ','AF4F177B66164781B6408D303F86810C'),(3914,'b','程序可以通过编译，运行后文件company.txt没有任何改变','AF4F177B66164781B6408D303F86810C'),(3915,'c','程序可以通过编译，运行后文件company.txt的长度变为0','AF4F177B66164781B6408D303F86810C'),(3916,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','AF4F177B66164781B6408D303F86810C'),(3917,'a','编译错误 ','57F009EAB72D4617870D4E86CB898E61'),(3918,'b','实现向文件record.dat追加写入字符a ','57F009EAB72D4617870D4E86CB898E61'),(3919,'c','实现向文件record.dat覆盖写入字符a ','57F009EAB72D4617870D4E86CB898E61'),(3920,'d','文件record.dat无任何内容 ','57F009EAB72D4617870D4E86CB898E61'),(3921,'a','输出：4 ','EEAA379F31DC470C979F6559DBE4E49D'),(3922,'b','在运行时抛出NullPointerException异常 ','EEAA379F31DC470C979F6559DBE4E49D'),(3923,'c','在运行时抛出NumberFormatException异常 ','EEAA379F31DC470C979F6559DBE4E49D'),(3924,'d','在运行时抛出IllegalStateException异常 ','EEAA379F31DC470C979F6559DBE4E49D'),(3925,'a','输出：4 ','264C3E77D7C74A65A54D7AE14D8ABEB5'),(3926,'b','在运行时抛出NullPointerException异常 ','264C3E77D7C74A65A54D7AE14D8ABEB5'),(3927,'c','在运行时抛出NumberFormatException异常 ','264C3E77D7C74A65A54D7AE14D8ABEB5'),(3928,'d','在运行时抛出IllegalStateException异常 ','264C3E77D7C74A65A54D7AE14D8ABEB5'),(3929,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','07CFADE87C7D4A93BF61D3F2D1AB0435'),(3930,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','07CFADE87C7D4A93BF61D3F2D1AB0435'),(3931,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','07CFADE87C7D4A93BF61D3F2D1AB0435'),(3932,'d','new InputStreamReader(\"1.dat\") ; ','07CFADE87C7D4A93BF61D3F2D1AB0435'),(3933,'a','通过调用stop()方法而停止的线程。 ','AF6F0E141EC142B9A89238371A01088E'),(3934,'b','通过调用sleep()方法而停止的线程。 ','AF6F0E141EC142B9A89238371A01088E'),(3935,'c','通过调用wait()方法而停止的线程。 ','AF6F0E141EC142B9A89238371A01088E'),(3936,'d','通过调用suspend()方法而停止的线程。 ','AF6F0E141EC142B9A89238371A01088E'),(3937,'a','start()    ','A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(3938,'b','init()    ','A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(3939,'c','run()    ','A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(3940,'d','main()  ','A6DD8F625AEC4DFC858A0AFCB1AB2C22'),(3941,'a','第3行抛出异常 ','8ADC4E8C77704976AF6D5FDF24DCEFDC'),(3942,'b','第1行抛出异常 ','8ADC4E8C77704976AF6D5FDF24DCEFDC'),(3943,'c','第5行抛出异常 ','8ADC4E8C77704976AF6D5FDF24DCEFDC'),(3944,'d','第3行代码成功执行 ','8ADC4E8C77704976AF6D5FDF24DCEFDC'),(3945,'a','一旦一个线程被创建，它就立即开始运行。  ','18AAF3C9FD7A409B95537D0B00CA04FD'),(3946,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','18AAF3C9FD7A409B95537D0B00CA04FD'),(3947,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','18AAF3C9FD7A409B95537D0B00CA04FD'),(3948,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','18AAF3C9FD7A409B95537D0B00CA04FD'),(3949,'a','输出Exception ','538F95F7DB924A9C83F6A406B11A0C88'),(3950,'b','输出A,B,Exception ','538F95F7DB924A9C83F6A406B11A0C88'),(3951,'c','编译失败 ','538F95F7DB924A9C83F6A406B11A0C88'),(3952,'d','在运行时抛出NullPointerException异常 ','538F95F7DB924A9C83F6A406B11A0C88'),(3953,'a','编译错误 ','C322AC8EE90B462B8F7CBC30475A63A4'),(3954,'b','抛出运行时异常 ','C322AC8EE90B462B8F7CBC30475A63A4'),(3955,'c','输出：bar ','C322AC8EE90B462B8F7CBC30475A63A4'),(3956,'d','代码正常运行，但是无输出 ','C322AC8EE90B462B8F7CBC30475A63A4'),(3957,'a','const   ','5D2D3F19A2D7417F851101DB6C69EA50'),(3958,'b','NULL  ','5D2D3F19A2D7417F851101DB6C69EA50'),(3959,'c','false   ','5D2D3F19A2D7417F851101DB6C69EA50'),(3960,'d','this  ','5D2D3F19A2D7417F851101DB6C69EA50'),(3961,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','FF328EB4F05344059CD477D79A3F3756'),(3962,'b','垃圾收集将检查并释放不在使用的内存  ','FF328EB4F05344059CD477D79A3F3756'),(3963,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','FF328EB4F05344059CD477D79A3F3756'),(3964,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','FF328EB4F05344059CD477D79A3F3756'),(3965,'a','编译错误 ','984F4DB6953E4901B44D41F4B237219B'),(3966,'b','实现向文件record.dat追加写入字符a ','984F4DB6953E4901B44D41F4B237219B'),(3967,'c','实现向文件record.dat覆盖写入字符a ','984F4DB6953E4901B44D41F4B237219B'),(3968,'d','文件record.dat无任何内容 ','984F4DB6953E4901B44D41F4B237219B'),(3969,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','A11DDB9986C1462A8F88DF4025A813F8'),(3970,'b','垃圾收集将检查并释放不在使用的内存  ','A11DDB9986C1462A8F88DF4025A813F8'),(3971,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','A11DDB9986C1462A8F88DF4025A813F8'),(3972,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','A11DDB9986C1462A8F88DF4025A813F8'),(3973,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','CF688CC154204D41AF8B7BE2E9325206'),(3974,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','CF688CC154204D41AF8B7BE2E9325206'),(3975,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','CF688CC154204D41AF8B7BE2E9325206'),(3976,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','CF688CC154204D41AF8B7BE2E9325206'),(3977,'a','一旦一个线程被创建，它就立即开始运行。  ','2D3350F3DC2F49BC91842BF028CEB6BD'),(3978,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','2D3350F3DC2F49BC91842BF028CEB6BD'),(3979,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','2D3350F3DC2F49BC91842BF028CEB6BD'),(3980,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','2D3350F3DC2F49BC91842BF028CEB6BD'),(3981,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','30F8BB727A8A4A03A41CC55C34CC4A34'),(3982,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','30F8BB727A8A4A03A41CC55C34CC4A34'),(3983,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','30F8BB727A8A4A03A41CC55C34CC4A34'),(3984,'d','new InputStreamReader(\"dat\") ; ','30F8BB727A8A4A03A41CC55C34CC4A34'),(3985,'a','private synchronized Object o; ','C5A72355D986431998AFAB25C24A1BC7'),(3986,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','C5A72355D986431998AFAB25C24A1BC7'),(3987,'c','public synchronized void go() { /* code here */ } ','C5A72355D986431998AFAB25C24A1BC7'),(3988,'d','private synchronized(this) void go() { /* code here */ } ','C5A72355D986431998AFAB25C24A1BC7'),(3989,'a','sleep方法 ','6399DD9F92C243B19CB9630D77CE4E57'),(3990,'b','IO等待 ','6399DD9F92C243B19CB9630D77CE4E57'),(3991,'c','yield方法 ','6399DD9F92C243B19CB9630D77CE4E57'),(3992,'d','wait方法 ','6399DD9F92C243B19CB9630D77CE4E57'),(3993,'a','Output is null.             ','8DEF217850E7425E8F63CDEA64E965BB'),(3994,'b','Output is 0 ','8DEF217850E7425E8F63CDEA64E965BB'),(3995,'c','编译时报错 ','8DEF217850E7425E8F63CDEA64E965BB'),(3996,'d','运行时报错','8DEF217850E7425E8F63CDEA64E965BB'),(3997,'a','m.length()    ','2C902492655A4D45ADBF1414F2F22A69'),(3998,'b','m.length   ','2C902492655A4D45ADBF1414F2F22A69'),(3999,'c','m.length()+1   ','2C902492655A4D45ADBF1414F2F22A69'),(4000,'d','m.length-1','2C902492655A4D45ADBF1414F2F22A69'),(4001,'a','long 1 = 4990  ','7C2B55E5DDC443389212B3ED4D1982D9'),(4002,'b','int i = 4L  ','7C2B55E5DDC443389212B3ED4D1982D9'),(4003,'c','float f =1.1  ','7C2B55E5DDC443389212B3ED4D1982D9'),(4004,'d','double d = 34.4','7C2B55E5DDC443389212B3ED4D1982D9'),(4005,'a','sleep方法 ','9E565542D2C4426F9C93BDD402FF9B7C'),(4006,'b','IO等待 ','9E565542D2C4426F9C93BDD402FF9B7C'),(4007,'c','yield方法 ','9E565542D2C4426F9C93BDD402FF9B7C'),(4008,'d','wait方法 ','9E565542D2C4426F9C93BDD402FF9B7C'),(4009,'a','编译错误 ','501B24E92D88480C9BD8DA17FDCAA073'),(4010,'b','程序可以通过编译，运行后文件company.txt没有任何改变','501B24E92D88480C9BD8DA17FDCAA073'),(4011,'c','程序可以通过编译，运行后文件company.txt的长度变为0','501B24E92D88480C9BD8DA17FDCAA073'),(4012,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','501B24E92D88480C9BD8DA17FDCAA073'),(4013,'a','输出：test ','995A1117E9E84428A976E20C3701002A'),(4014,'b','输出：Exception ','995A1117E9E84428A976E20C3701002A'),(4015,'c','编译失败 ','995A1117E9E84428A976E20C3701002A'),(4016,'d','输出：NullPointerException ','995A1117E9E84428A976E20C3701002A'),(4017,'a','编译错误 ','DD84DD927AEA4E7497D2112A1238F726'),(4018,'b','抛出运行时异常 ','DD84DD927AEA4E7497D2112A1238F726'),(4019,'c','输出：sleep ','DD84DD927AEA4E7497D2112A1238F726'),(4020,'d','代码正常运行，但是无输出 ','DD84DD927AEA4E7497D2112A1238F726'),(4021,'a','s>>>=3   ','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(4022,'b','s[3]= “X”  ','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(4023,'c','int i = s.length()   ','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(4024,'d','s = s + 10 ','36ACF9D0A6BA46F2A726DD3D0E0A9FB9'),(4025,'a','第3行抛出异常 ','45BCA083FBEE417C85D9A8FCB72D3218'),(4026,'b','第1行抛出异常 ','45BCA083FBEE417C85D9A8FCB72D3218'),(4027,'c','第5行抛出异常 ','45BCA083FBEE417C85D9A8FCB72D3218'),(4028,'d','第3行代码成功执行 ','45BCA083FBEE417C85D9A8FCB72D3218'),(4029,'a','5.0','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(4030,'b','4.0','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(4031,'c','6.0','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(4032,'d','finished','3EF12E00F8644DA9ACE62A96B3A8DFFD'),(4033,'a','s>>>=3   ','2EB316C6176A43F9AAB28179E2D102E3'),(4034,'b','s[3]= “X”  ','2EB316C6176A43F9AAB28179E2D102E3'),(4035,'c','int i = s.length()   ','2EB316C6176A43F9AAB28179E2D102E3'),(4036,'d','s = s + 10 ','2EB316C6176A43F9AAB28179E2D102E3'),(4037,'a','public void method( int m){...}     ','D0A1111E66FA40CF83F38723C1F2E243'),(4038,'b','public int method(){...} ','D0A1111E66FA40CF83F38723C1F2E243'),(4039,'c','public void method2(){...}    ','D0A1111E66FA40CF83F38723C1F2E243'),(4040,'d','public int method(int m，float f ){...} ','D0A1111E66FA40CF83F38723C1F2E243'),(4041,'a','m.length()    ','E6074C379FC64361BF5E26FC42DE09B8'),(4042,'b','m.length   ','E6074C379FC64361BF5E26FC42DE09B8'),(4043,'c','m.length()+1   ','E6074C379FC64361BF5E26FC42DE09B8'),(4044,'d','m.length-1','E6074C379FC64361BF5E26FC42DE09B8'),(4045,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(4046,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(4047,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(4048,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','3F3C2A44EEB643B3BA7F47CD6D5E62AA'),(4049,'a','编译错误 ','5583044BC4BE4658BDBCDFB09F4888D8'),(4050,'b','实现向文件record.dat追加写入字符a ','5583044BC4BE4658BDBCDFB09F4888D8'),(4051,'c','实现向文件record.dat覆盖写入字符a ','5583044BC4BE4658BDBCDFB09F4888D8'),(4052,'d','文件record.dat无任何内容 ','5583044BC4BE4658BDBCDFB09F4888D8'),(4053,'a','start()    ','9FA981DED83B4AC494357F78CBE8D82A'),(4054,'b','init()    ','9FA981DED83B4AC494357F78CBE8D82A'),(4055,'c','run()    ','9FA981DED83B4AC494357F78CBE8D82A'),(4056,'d','main()  ','9FA981DED83B4AC494357F78CBE8D82A'),(4057,'a','编译错误 ','97A24EFBAA8043708AA7E3196C8DD36C'),(4058,'b','实现向文件record.dat追加写入字符a ','97A24EFBAA8043708AA7E3196C8DD36C'),(4059,'c','实现向文件record.dat覆盖写入字符a ','97A24EFBAA8043708AA7E3196C8DD36C'),(4060,'d','文件record.dat无任何内容 ','97A24EFBAA8043708AA7E3196C8DD36C'),(4061,'a','将private int m改为 protected int m  ','09A4554A2A894F67AB29EC161ED0AD94'),(4062,'b','将private int m改为 public int m    ','09A4554A2A894F67AB29EC161ED0AD94'),(4063,'c','将private int m改为 static int m     ','09A4554A2A894F67AB29EC161ED0AD94'),(4064,'d','将private int m改为int m ','09A4554A2A894F67AB29EC161ED0AD94'),(4065,'a','编译错误 ','8193D4AE48644B4FBDF8A9CA36244CEA'),(4066,'b','实现向文件record.dat追加写入字符a ','8193D4AE48644B4FBDF8A9CA36244CEA'),(4067,'c','实现向文件record.dat覆盖写入字符a ','8193D4AE48644B4FBDF8A9CA36244CEA'),(4068,'d','文件record.dat无任何内容 ','8193D4AE48644B4FBDF8A9CA36244CEA'),(4069,'a','5.0','713912F5E46346328118DC9E610F552E'),(4070,'b','4.0','713912F5E46346328118DC9E610F552E'),(4071,'c','6.0','713912F5E46346328118DC9E610F552E'),(4072,'d','finished','713912F5E46346328118DC9E610F552E'),(4073,'a','通过调用stop()方法而停止的线程。 ','85369AE2C3894B0DBA0A8CF1BF9696AC'),(4074,'b','通过调用sleep()方法而停止的线程。 ','85369AE2C3894B0DBA0A8CF1BF9696AC'),(4075,'c','通过调用wait()方法而停止的线程。 ','85369AE2C3894B0DBA0A8CF1BF9696AC'),(4076,'d','通过调用suspend()方法而停止的线程。 ','85369AE2C3894B0DBA0A8CF1BF9696AC'),(4077,'a','编译错误 ','F82A50997800481EBF83F8841EA0966A'),(4078,'b','抛出运行时异常 ','F82A50997800481EBF83F8841EA0966A'),(4079,'c','输出：bar ','F82A50997800481EBF83F8841EA0966A'),(4080,'d','代码正常运行，但是无输出 ','F82A50997800481EBF83F8841EA0966A'),(4081,'a','编译错误 ','876C19BA1A644AE09B59FF21D3D0BF20'),(4082,'b','抛出运行时异常 ','876C19BA1A644AE09B59FF21D3D0BF20'),(4083,'c','输出：sleep ','876C19BA1A644AE09B59FF21D3D0BF20'),(4084,'d','代码正常运行，但是无输出 ','876C19BA1A644AE09B59FF21D3D0BF20'),(4085,'a','sleep方法 ','CB375B3254C24F86940623F97D4964C7'),(4086,'b','IO等待 ','CB375B3254C24F86940623F97D4964C7'),(4087,'c','yield方法 ','CB375B3254C24F86940623F97D4964C7'),(4088,'d','wait方法 ','CB375B3254C24F86940623F97D4964C7'),(4089,'a','将private int m改为 protected int m  ','428316A7473843298FBD06B2451F7960'),(4090,'b','将private int m改为 public int m    ','428316A7473843298FBD06B2451F7960'),(4091,'c','将private int m改为 static int m     ','428316A7473843298FBD06B2451F7960'),(4092,'d','将private int m改为int m ','428316A7473843298FBD06B2451F7960'),(4093,'a','Output is null.             ','63C38F3C6C8743358657ED4F97DAAC92'),(4094,'b','Output is 0 ','63C38F3C6C8743358657ED4F97DAAC92'),(4095,'c','编译时报错 ','63C38F3C6C8743358657ED4F97DAAC92'),(4096,'d','运行时报错','63C38F3C6C8743358657ED4F97DAAC92'),(4097,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','AA5086CF642A47FF835942F0B91B2E96'),(4098,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','AA5086CF642A47FF835942F0B91B2E96'),(4099,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','AA5086CF642A47FF835942F0B91B2E96'),(4100,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','AA5086CF642A47FF835942F0B91B2E96'),(4101,'a','名为dtThread的线程为守护线程 ','B23EF313E63946E2BBBD12223102C69A'),(4102,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','B23EF313E63946E2BBBD12223102C69A'),(4103,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','B23EF313E63946E2BBBD12223102C69A'),(4104,'d','main线程是守护线程 ','B23EF313E63946E2BBBD12223102C69A'),(4105,'a','private synchronized Object o; ','6106E40EF34841518AC57C37111CED16'),(4106,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','6106E40EF34841518AC57C37111CED16'),(4107,'c','public synchronized void go() { /* code here */ } ','6106E40EF34841518AC57C37111CED16'),(4108,'d','private synchronized(this) void go() { /* code here */ } ','6106E40EF34841518AC57C37111CED16'),(4109,'a','一旦一个线程被创建，它就立即开始运行。  ','2FF97CAE7008449CAB06D72F3203CBBD'),(4110,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','2FF97CAE7008449CAB06D72F3203CBBD'),(4111,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','2FF97CAE7008449CAB06D72F3203CBBD'),(4112,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','2FF97CAE7008449CAB06D72F3203CBBD'),(4113,'a','输出：4 ','A56FE711FAFD42F687F7965CCB5E9E1D'),(4114,'b','在运行时抛出NullPointerException异常 ','A56FE711FAFD42F687F7965CCB5E9E1D'),(4115,'c','在运行时抛出NumberFormatException异常 ','A56FE711FAFD42F687F7965CCB5E9E1D'),(4116,'d','在运行时抛出IllegalStateException异常 ','A56FE711FAFD42F687F7965CCB5E9E1D'),(4117,'a','InputStreamReader','D351981F52454075B38A8BBD17130695'),(4118,'b','BufferedReader','D351981F52454075B38A8BBD17130695'),(4119,'c','FileInputStream','D351981F52454075B38A8BBD17130695'),(4120,'d','InputStream','D351981F52454075B38A8BBD17130695'),(4121,'a','输出Exception ','B1D4185AEDBB46DBA02C56353547049B'),(4122,'b','输出A,B,Exception ','B1D4185AEDBB46DBA02C56353547049B'),(4123,'c','编译失败 ','B1D4185AEDBB46DBA02C56353547049B'),(4124,'d','在运行时抛出NullPointerException异常 ','B1D4185AEDBB46DBA02C56353547049B'),(4125,'a','long 1 = 4990  ','6698F9521A344EC0964FFFDDD42EC889'),(4126,'b','int i = 4L  ','6698F9521A344EC0964FFFDDD42EC889'),(4127,'c','float f =1.1  ','6698F9521A344EC0964FFFDDD42EC889'),(4128,'d','double d = 34.4','6698F9521A344EC0964FFFDDD42EC889'),(4129,'a','public void method( int m){...}     ','34756F5E0EE640A7A5F24B1C035831B5'),(4130,'b','public int method(){...} ','34756F5E0EE640A7A5F24B1C035831B5'),(4131,'c','public void method2(){...}    ','34756F5E0EE640A7A5F24B1C035831B5'),(4132,'d','public int method(int m，float f ){...} ','34756F5E0EE640A7A5F24B1C035831B5'),(4133,'a','名为dtThread的线程为守护线程 ','1D660E6E977B41D887BAA72BA7D82329'),(4134,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','1D660E6E977B41D887BAA72BA7D82329'),(4135,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','1D660E6E977B41D887BAA72BA7D82329'),(4136,'d','main线程是守护线程 ','1D660E6E977B41D887BAA72BA7D82329'),(4137,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','E3A90239DF874BD883EBC1D805A03DAC'),(4138,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','E3A90239DF874BD883EBC1D805A03DAC'),(4139,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','E3A90239DF874BD883EBC1D805A03DAC'),(4140,'d','new InputStreamReader(\"dat\") ; ','E3A90239DF874BD883EBC1D805A03DAC'),(4141,'a','栈是非线性结构        ','764A8B7CDA5848EDAA5863C0FDD9B179'),(4142,'b','栈是一种树状结构 ','764A8B7CDA5848EDAA5863C0FDD9B179'),(4143,'c','栈具有先进先出的特征  ','764A8B7CDA5848EDAA5863C0FDD9B179'),(4144,'d','栈具有后进先出的特征 ','764A8B7CDA5848EDAA5863C0FDD9B179'),(4145,'a','m.length()    ','C9588B688CA445078A926C8D252487AF'),(4146,'b','m.length   ','C9588B688CA445078A926C8D252487AF'),(4147,'c','m.length()+1   ','C9588B688CA445078A926C8D252487AF'),(4148,'d','m.length-1','C9588B688CA445078A926C8D252487AF'),(4149,'a','编译错误 ','6D27985CDB994BCEB691CAD52D8DFF95'),(4150,'b','实现向文件record.dat追加写入字符a ','6D27985CDB994BCEB691CAD52D8DFF95'),(4151,'c','实现向文件record.dat覆盖写入字符a ','6D27985CDB994BCEB691CAD52D8DFF95'),(4152,'d','文件record.dat无任何内容 ','6D27985CDB994BCEB691CAD52D8DFF95'),(4153,'a','const   ','7512F0CBEAC945EFB5F0123F97F54D88'),(4154,'b','NULL  ','7512F0CBEAC945EFB5F0123F97F54D88'),(4155,'c','false   ','7512F0CBEAC945EFB5F0123F97F54D88'),(4156,'d','this  ','7512F0CBEAC945EFB5F0123F97F54D88'),(4157,'a','s>>>=3   ','BDF349BCA1394593B1851DD7F624D3B0'),(4158,'b','s[3]= “X”  ','BDF349BCA1394593B1851DD7F624D3B0'),(4159,'c','int i = s.length()   ','BDF349BCA1394593B1851DD7F624D3B0'),(4160,'d','s = s + 10 ','BDF349BCA1394593B1851DD7F624D3B0'),(4161,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','2248B08C238F4318AFC4D31A13568876'),(4162,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','2248B08C238F4318AFC4D31A13568876'),(4163,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','2248B08C238F4318AFC4D31A13568876'),(4164,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','2248B08C238F4318AFC4D31A13568876'),(4165,'a','编译错误 ','9D4B6C71FF364B1382B511C5A0CD05CB'),(4166,'b','程序可以通过编译，运行后文件company.txt没有任何改变','9D4B6C71FF364B1382B511C5A0CD05CB'),(4167,'c','程序可以通过编译，运行后文件company.txt的长度变为0','9D4B6C71FF364B1382B511C5A0CD05CB'),(4168,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','9D4B6C71FF364B1382B511C5A0CD05CB'),(4169,'a','start()    ','4D2A4EAD46104AC798BBDC5D0B3E4698'),(4170,'b','init()    ','4D2A4EAD46104AC798BBDC5D0B3E4698'),(4171,'c','run()    ','4D2A4EAD46104AC798BBDC5D0B3E4698'),(4172,'d','main()  ','4D2A4EAD46104AC798BBDC5D0B3E4698'),(4173,'a','5.0','312A61C4E17740EAA9C7D2DAD637858B'),(4174,'b','4.0','312A61C4E17740EAA9C7D2DAD637858B'),(4175,'c','6.0','312A61C4E17740EAA9C7D2DAD637858B'),(4176,'d','finished','312A61C4E17740EAA9C7D2DAD637858B'),(4177,'a','通过调用stop()方法而停止的线程。 ','A65B0F53E4B04E91BF77E0C4A945686A'),(4178,'b','通过调用sleep()方法而停止的线程。 ','A65B0F53E4B04E91BF77E0C4A945686A'),(4179,'c','通过调用wait()方法而停止的线程。 ','A65B0F53E4B04E91BF77E0C4A945686A'),(4180,'d','通过调用suspend()方法而停止的线程。 ','A65B0F53E4B04E91BF77E0C4A945686A'),(4181,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(4182,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(4183,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(4184,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','7678BD8B551B4ABAA1AEA6D6B7D2B8E5'),(4185,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','7D2A7A91D8E849828F8A26BA90A2F3DF'),(4186,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','7D2A7A91D8E849828F8A26BA90A2F3DF'),(4187,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','7D2A7A91D8E849828F8A26BA90A2F3DF'),(4188,'d','new InputStreamReader(\"1.dat\") ; ','7D2A7A91D8E849828F8A26BA90A2F3DF'),(4189,'a','栈是非线性结构        ','D9264BD53FC5479CA3621E774007C4D6'),(4190,'b','栈是一种树状结构 ','D9264BD53FC5479CA3621E774007C4D6'),(4191,'c','栈具有先进先出的特征  ','D9264BD53FC5479CA3621E774007C4D6'),(4192,'d','栈具有后进先出的特征 ','D9264BD53FC5479CA3621E774007C4D6'),(4193,'a','public void method( int m){...}     ','63AB8F5ECAA44DA98E349BDB678F0F37'),(4194,'b','public int method(){...} ','63AB8F5ECAA44DA98E349BDB678F0F37'),(4195,'c','public void method2(){...}    ','63AB8F5ECAA44DA98E349BDB678F0F37'),(4196,'d','public int method(int m，float f ){...} ','63AB8F5ECAA44DA98E349BDB678F0F37'),(4197,'a','输出Exception ','8D543E1694A74A9FBE6FC5998FB9915E'),(4198,'b','输出A,B,Exception ','8D543E1694A74A9FBE6FC5998FB9915E'),(4199,'c','编译失败 ','8D543E1694A74A9FBE6FC5998FB9915E'),(4200,'d','在运行时抛出NullPointerException异常 ','8D543E1694A74A9FBE6FC5998FB9915E'),(4201,'a','long 1 = 4990  ','5B2756250E7447BA92124C11C1B48534'),(4202,'b','int i = 4L  ','5B2756250E7447BA92124C11C1B48534'),(4203,'c','float f =1.1  ','5B2756250E7447BA92124C11C1B48534'),(4204,'d','double d = 34.4','5B2756250E7447BA92124C11C1B48534'),(4205,'a','Output is null.             ','8E3A0710EDBA4065929590F25D6EE32A'),(4206,'b','Output is 0 ','8E3A0710EDBA4065929590F25D6EE32A'),(4207,'c','编译时报错 ','8E3A0710EDBA4065929590F25D6EE32A'),(4208,'d','运行时报错','8E3A0710EDBA4065929590F25D6EE32A'),(4209,'a','InputStreamReader','6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(4210,'b','BufferedReader','6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(4211,'c','FileInputStream','6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(4212,'d','InputStream','6C02E46D87D64D1E98D9CFB2ABB1DBC1'),(4213,'a','将private int m改为 protected int m  ','D9DD8C5678FF469089B52CC20AA2AC43'),(4214,'b','将private int m改为 public int m    ','D9DD8C5678FF469089B52CC20AA2AC43'),(4215,'c','将private int m改为 static int m     ','D9DD8C5678FF469089B52CC20AA2AC43'),(4216,'d','将private int m改为int m ','D9DD8C5678FF469089B52CC20AA2AC43'),(4217,'a','编译错误 ','56F7E21CF56E4836B0E6DF0BB955C5FE'),(4218,'b','抛出运行时异常 ','56F7E21CF56E4836B0E6DF0BB955C5FE'),(4219,'c','输出：sleep ','56F7E21CF56E4836B0E6DF0BB955C5FE'),(4220,'d','代码正常运行，但是无输出 ','56F7E21CF56E4836B0E6DF0BB955C5FE'),(4221,'a','m.length()    ','57E84310FD9A4D4EB9A1CBF867EAC295'),(4222,'b','m.length   ','57E84310FD9A4D4EB9A1CBF867EAC295'),(4223,'c','m.length()+1   ','57E84310FD9A4D4EB9A1CBF867EAC295'),(4224,'d','m.length-1','57E84310FD9A4D4EB9A1CBF867EAC295'),(4225,'a','public void method( int m){...}     ','91FF9D799B564C9F95B189C0FFF6E0A9'),(4226,'b','public int method(){...} ','91FF9D799B564C9F95B189C0FFF6E0A9'),(4227,'c','public void method2(){...}    ','91FF9D799B564C9F95B189C0FFF6E0A9'),(4228,'d','public int method(int m，float f ){...} ','91FF9D799B564C9F95B189C0FFF6E0A9'),(4229,'a','start()    ','830B4A82C02C44C0A6E2372C1F5B8BB3'),(4230,'b','init()    ','830B4A82C02C44C0A6E2372C1F5B8BB3'),(4231,'c','run()    ','830B4A82C02C44C0A6E2372C1F5B8BB3'),(4232,'d','main()  ','830B4A82C02C44C0A6E2372C1F5B8BB3'),(4233,'a','编译错误 ','921B6660CAE0477595E7A5BE9EE25E6F'),(4234,'b','实现向文件record.dat追加写入字符a ','921B6660CAE0477595E7A5BE9EE25E6F'),(4235,'c','实现向文件record.dat覆盖写入字符a ','921B6660CAE0477595E7A5BE9EE25E6F'),(4236,'d','文件record.dat无任何内容 ','921B6660CAE0477595E7A5BE9EE25E6F'),(4237,'a','InputStreamReader','2FDA6B3787244961AF6001F574545E64'),(4238,'b','BufferedReader','2FDA6B3787244961AF6001F574545E64'),(4239,'c','FileInputStream','2FDA6B3787244961AF6001F574545E64'),(4240,'d','InputStream','2FDA6B3787244961AF6001F574545E64'),(4241,'a','通过调用stop()方法而停止的线程。 ','8E5934A4316C43A0818300E54F770628'),(4242,'b','通过调用sleep()方法而停止的线程。 ','8E5934A4316C43A0818300E54F770628'),(4243,'c','通过调用wait()方法而停止的线程。 ','8E5934A4316C43A0818300E54F770628'),(4244,'d','通过调用suspend()方法而停止的线程。 ','8E5934A4316C43A0818300E54F770628'),(4245,'a','private synchronized Object o; ','59C78793EE824224AE8075755AF9896C'),(4246,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','59C78793EE824224AE8075755AF9896C'),(4247,'c','public synchronized void go() { /* code here */ } ','59C78793EE824224AE8075755AF9896C'),(4248,'d','private synchronized(this) void go() { /* code here */ } ','59C78793EE824224AE8075755AF9896C'),(4249,'a','long 1 = 4990  ','B69E338B93B144749C51624C22853441'),(4250,'b','int i = 4L  ','B69E338B93B144749C51624C22853441'),(4251,'c','float f =1.1  ','B69E338B93B144749C51624C22853441'),(4252,'d','double d = 34.4','B69E338B93B144749C51624C22853441'),(4253,'a','一旦一个线程被创建，它就立即开始运行。  ','4745AB44A1E84A4DAD8399FC7210CE6C'),(4254,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','4745AB44A1E84A4DAD8399FC7210CE6C'),(4255,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','4745AB44A1E84A4DAD8399FC7210CE6C'),(4256,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','4745AB44A1E84A4DAD8399FC7210CE6C'),(4257,'a','第3行抛出异常 ','42503013F61240109E2FC90D689E6137'),(4258,'b','第1行抛出异常 ','42503013F61240109E2FC90D689E6137'),(4259,'c','第5行抛出异常 ','42503013F61240109E2FC90D689E6137'),(4260,'d','第3行代码成功执行 ','42503013F61240109E2FC90D689E6137'),(4261,'a','编译错误 ','E82FEAD8687A449697A0EA04D1593815'),(4262,'b','抛出运行时异常 ','E82FEAD8687A449697A0EA04D1593815'),(4263,'c','输出：sleep ','E82FEAD8687A449697A0EA04D1593815'),(4264,'d','代码正常运行，但是无输出 ','E82FEAD8687A449697A0EA04D1593815'),(4265,'a','InputStreamReader','F618DFEDE50E4833914C16E557D4DE80'),(4266,'b','BufferedReader','F618DFEDE50E4833914C16E557D4DE80'),(4267,'c','FileInputStream','F618DFEDE50E4833914C16E557D4DE80'),(4268,'d','InputStream','F618DFEDE50E4833914C16E557D4DE80'),(4269,'a','start()    ','125D8E65A6664A2284CAEAA0EFF7D56B'),(4270,'b','init()    ','125D8E65A6664A2284CAEAA0EFF7D56B'),(4271,'c','run()    ','125D8E65A6664A2284CAEAA0EFF7D56B'),(4272,'d','main()  ','125D8E65A6664A2284CAEAA0EFF7D56B'),(4273,'a','private synchronized Object o; ','07B64BF8C1BC43D5BD1C0DFA7B80D523'),(4274,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','07B64BF8C1BC43D5BD1C0DFA7B80D523'),(4275,'c','public synchronized void go() { /* code here */ } ','07B64BF8C1BC43D5BD1C0DFA7B80D523'),(4276,'d','private synchronized(this) void go() { /* code here */ } ','07B64BF8C1BC43D5BD1C0DFA7B80D523'),(4277,'a','编译错误 ','7E97CC25138F41F3930150DEAAA7F718'),(4278,'b','抛出运行时异常 ','7E97CC25138F41F3930150DEAAA7F718'),(4279,'c','输出：bar ','7E97CC25138F41F3930150DEAAA7F718'),(4280,'d','代码正常运行，但是无输出 ','7E97CC25138F41F3930150DEAAA7F718'),(4281,'a','一旦一个线程被创建，它就立即开始运行。  ','5237406AF0E64A1B87AFA78C97521742'),(4282,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','5237406AF0E64A1B87AFA78C97521742'),(4283,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','5237406AF0E64A1B87AFA78C97521742'),(4284,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','5237406AF0E64A1B87AFA78C97521742'),(4285,'a','private synchronized Object o; ','95FAEC7CD2004FE38565189C8153D58B'),(4286,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','95FAEC7CD2004FE38565189C8153D58B'),(4287,'c','public synchronized void go() { /* code here */ } ','95FAEC7CD2004FE38565189C8153D58B'),(4288,'d','private synchronized(this) void go() { /* code here */ } ','95FAEC7CD2004FE38565189C8153D58B'),(4289,'a','名为dtThread的线程为守护线程 ','0EAA9324F9F04EFCAA69F5B6E732503A'),(4290,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','0EAA9324F9F04EFCAA69F5B6E732503A'),(4291,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','0EAA9324F9F04EFCAA69F5B6E732503A'),(4292,'d','main线程是守护线程 ','0EAA9324F9F04EFCAA69F5B6E732503A'),(4293,'a','编译错误 ','0C211E5F953F4DE3BBC66268ACDFDC00'),(4294,'b','实现向文件record.dat追加写入字符a ','0C211E5F953F4DE3BBC66268ACDFDC00'),(4295,'c','实现向文件record.dat覆盖写入字符a ','0C211E5F953F4DE3BBC66268ACDFDC00'),(4296,'d','文件record.dat无任何内容 ','0C211E5F953F4DE3BBC66268ACDFDC00'),(4297,'a','通过调用stop()方法而停止的线程。 ','0F0BB2075E6A440DBD6277011E29DF2D'),(4298,'b','通过调用sleep()方法而停止的线程。 ','0F0BB2075E6A440DBD6277011E29DF2D'),(4299,'c','通过调用wait()方法而停止的线程。 ','0F0BB2075E6A440DBD6277011E29DF2D'),(4300,'d','通过调用suspend()方法而停止的线程。 ','0F0BB2075E6A440DBD6277011E29DF2D'),(4301,'a','第3行抛出异常 ','5BDCB6173CD24C00A54D76CC75DD7D21'),(4302,'b','第1行抛出异常 ','5BDCB6173CD24C00A54D76CC75DD7D21'),(4303,'c','第5行抛出异常 ','5BDCB6173CD24C00A54D76CC75DD7D21'),(4304,'d','第3行代码成功执行 ','5BDCB6173CD24C00A54D76CC75DD7D21'),(4305,'a','s>>>=3   ','D979ECDC0C434C238ACB528CEA9996E0'),(4306,'b','s[3]= “X”  ','D979ECDC0C434C238ACB528CEA9996E0'),(4307,'c','int i = s.length()   ','D979ECDC0C434C238ACB528CEA9996E0'),(4308,'d','s = s + 10 ','D979ECDC0C434C238ACB528CEA9996E0'),(4309,'a','const   ','FE9B4DA45A7A4EA3870A3D448A5A27ED'),(4310,'b','NULL  ','FE9B4DA45A7A4EA3870A3D448A5A27ED'),(4311,'c','false   ','FE9B4DA45A7A4EA3870A3D448A5A27ED'),(4312,'d','this  ','FE9B4DA45A7A4EA3870A3D448A5A27ED'),(4313,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','2DD703ADD11048D291BE7A9D6C33D77A'),(4314,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','2DD703ADD11048D291BE7A9D6C33D77A'),(4315,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','2DD703ADD11048D291BE7A9D6C33D77A'),(4316,'d','new InputStreamReader(\"1.dat\") ; ','2DD703ADD11048D291BE7A9D6C33D77A'),(4317,'a','第3行抛出异常 ','0D3E23B1871040EB83BA3E43F31C7249'),(4318,'b','第1行抛出异常 ','0D3E23B1871040EB83BA3E43F31C7249'),(4319,'c','第5行抛出异常 ','0D3E23B1871040EB83BA3E43F31C7249'),(4320,'d','第3行代码成功执行 ','0D3E23B1871040EB83BA3E43F31C7249'),(4321,'a','将private int m改为 protected int m  ','2B2A1FC2DDB84E38911106F21A45266D'),(4322,'b','将private int m改为 public int m    ','2B2A1FC2DDB84E38911106F21A45266D'),(4323,'c','将private int m改为 static int m     ','2B2A1FC2DDB84E38911106F21A45266D'),(4324,'d','将private int m改为int m ','2B2A1FC2DDB84E38911106F21A45266D'),(4325,'a','编译错误 ','848B4A69E2534C10AD366D2805124925'),(4326,'b','抛出运行时异常 ','848B4A69E2534C10AD366D2805124925'),(4327,'c','输出：sleep ','848B4A69E2534C10AD366D2805124925'),(4328,'d','代码正常运行，但是无输出 ','848B4A69E2534C10AD366D2805124925'),(4329,'a','输出Exception ','588B398B2C2E43CE828BFD0B0E174CCE'),(4330,'b','输出A,B,Exception ','588B398B2C2E43CE828BFD0B0E174CCE'),(4331,'c','编译失败 ','588B398B2C2E43CE828BFD0B0E174CCE'),(4332,'d','在运行时抛出NullPointerException异常 ','588B398B2C2E43CE828BFD0B0E174CCE'),(4333,'a','Output is null.             ','2F33726699C144E48CB7C76A856256EA'),(4334,'b','Output is 0 ','2F33726699C144E48CB7C76A856256EA'),(4335,'c','编译时报错 ','2F33726699C144E48CB7C76A856256EA'),(4336,'d','运行时报错','2F33726699C144E48CB7C76A856256EA'),(4337,'a','一旦一个线程被创建，它就立即开始运行。  ','F341A225A1B84DAD8C38EDE74F65CA7A'),(4338,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','F341A225A1B84DAD8C38EDE74F65CA7A'),(4339,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','F341A225A1B84DAD8C38EDE74F65CA7A'),(4340,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','F341A225A1B84DAD8C38EDE74F65CA7A'),(4341,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','507CFBA7AD0F4BDBB09406719D56DC3C'),(4342,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','507CFBA7AD0F4BDBB09406719D56DC3C'),(4343,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','507CFBA7AD0F4BDBB09406719D56DC3C'),(4344,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','507CFBA7AD0F4BDBB09406719D56DC3C'),(4345,'a','将private int m改为 protected int m  ','2FA9DDEBB8D84DBA876E5B559C3A6F43'),(4346,'b','将private int m改为 public int m    ','2FA9DDEBB8D84DBA876E5B559C3A6F43'),(4347,'c','将private int m改为 static int m     ','2FA9DDEBB8D84DBA876E5B559C3A6F43'),(4348,'d','将private int m改为int m ','2FA9DDEBB8D84DBA876E5B559C3A6F43'),(4349,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','BA0623754560439BB0F402CE83AE52F4'),(4350,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','BA0623754560439BB0F402CE83AE52F4'),(4351,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','BA0623754560439BB0F402CE83AE52F4'),(4352,'d','new InputStreamReader(\"dat\") ; ','BA0623754560439BB0F402CE83AE52F4'),(4353,'a','s>>>=3   ','6FF9DA87D8854B6087901269F82BB8C3'),(4354,'b','s[3]= “X”  ','6FF9DA87D8854B6087901269F82BB8C3'),(4355,'c','int i = s.length()   ','6FF9DA87D8854B6087901269F82BB8C3'),(4356,'d','s = s + 10 ','6FF9DA87D8854B6087901269F82BB8C3'),(4357,'a','long 1 = 4990  ','32808EFF6EBD40A7ADE6EA42932D76AD'),(4358,'b','int i = 4L  ','32808EFF6EBD40A7ADE6EA42932D76AD'),(4359,'c','float f =1.1  ','32808EFF6EBD40A7ADE6EA42932D76AD'),(4360,'d','double d = 34.4','32808EFF6EBD40A7ADE6EA42932D76AD'),(4361,'a','输出Exception ','EC1652EC2A37468391FCB4F7A12CA465'),(4362,'b','输出A,B,Exception ','EC1652EC2A37468391FCB4F7A12CA465'),(4363,'c','编译失败 ','EC1652EC2A37468391FCB4F7A12CA465'),(4364,'d','在运行时抛出NullPointerException异常 ','EC1652EC2A37468391FCB4F7A12CA465'),(4365,'a','编译错误 ','85381E73235347BABA8FE2C7D6AA8575'),(4366,'b','抛出运行时异常 ','85381E73235347BABA8FE2C7D6AA8575'),(4367,'c','输出：bar ','85381E73235347BABA8FE2C7D6AA8575'),(4368,'d','代码正常运行，但是无输出 ','85381E73235347BABA8FE2C7D6AA8575'),(4369,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','EB3CF51FAA444DDAA10DF6B2DF898FBE'),(4370,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','EB3CF51FAA444DDAA10DF6B2DF898FBE'),(4371,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','EB3CF51FAA444DDAA10DF6B2DF898FBE'),(4372,'d','new InputStreamReader(\"1.dat\") ; ','EB3CF51FAA444DDAA10DF6B2DF898FBE'),(4373,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','992C1621A1AD4390B7948389B822B379'),(4374,'b','垃圾收集将检查并释放不在使用的内存  ','992C1621A1AD4390B7948389B822B379'),(4375,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','992C1621A1AD4390B7948389B822B379'),(4376,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','992C1621A1AD4390B7948389B822B379'),(4377,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','8889C1666DA5478B9BBE4EE0CB27C752'),(4378,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','8889C1666DA5478B9BBE4EE0CB27C752'),(4379,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','8889C1666DA5478B9BBE4EE0CB27C752'),(4380,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','8889C1666DA5478B9BBE4EE0CB27C752'),(4381,'a','栈是非线性结构        ','FACE3F397BDD400DBCD8A65D48D4B34D'),(4382,'b','栈是一种树状结构 ','FACE3F397BDD400DBCD8A65D48D4B34D'),(4383,'c','栈具有先进先出的特征  ','FACE3F397BDD400DBCD8A65D48D4B34D'),(4384,'d','栈具有后进先出的特征 ','FACE3F397BDD400DBCD8A65D48D4B34D'),(4385,'a','编译错误 ','DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(4386,'b','程序可以通过编译，运行后文件company.txt没有任何改变','DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(4387,'c','程序可以通过编译，运行后文件company.txt的长度变为0','DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(4388,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','DE10A8EBDE8149F2BDD6CA84EE88BFD5'),(4389,'a','InputStreamReader','C9ED16F8AFCA48B58D30C465AA251572'),(4390,'b','BufferedReader','C9ED16F8AFCA48B58D30C465AA251572'),(4391,'c','FileInputStream','C9ED16F8AFCA48B58D30C465AA251572'),(4392,'d','InputStream','C9ED16F8AFCA48B58D30C465AA251572'),(4393,'a','const   ','50EA8CAD9F1C457797794D09A18E574E'),(4394,'b','NULL  ','50EA8CAD9F1C457797794D09A18E574E'),(4395,'c','false   ','50EA8CAD9F1C457797794D09A18E574E'),(4396,'d','this  ','50EA8CAD9F1C457797794D09A18E574E'),(4397,'a','编译错误 ','BBE54DA41275455A97BE8AA214F44FE1'),(4398,'b','实现向文件record.dat追加写入字符a ','BBE54DA41275455A97BE8AA214F44FE1'),(4399,'c','实现向文件record.dat覆盖写入字符a ','BBE54DA41275455A97BE8AA214F44FE1'),(4400,'d','文件record.dat无任何内容 ','BBE54DA41275455A97BE8AA214F44FE1'),(4401,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','21AC3DAD00964F8F9A199136F07C35E8'),(4402,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','21AC3DAD00964F8F9A199136F07C35E8'),(4403,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','21AC3DAD00964F8F9A199136F07C35E8'),(4404,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','21AC3DAD00964F8F9A199136F07C35E8'),(4405,'a','输出：test ','64DB87B316BB4CA7A4B466B9F3860978'),(4406,'b','输出：Exception ','64DB87B316BB4CA7A4B466B9F3860978'),(4407,'c','编译失败 ','64DB87B316BB4CA7A4B466B9F3860978'),(4408,'d','输出：NullPointerException ','64DB87B316BB4CA7A4B466B9F3860978'),(4409,'a','long 1 = 4990  ','E6E31C640E584486A7CEF620BC9D3320'),(4410,'b','int i = 4L  ','E6E31C640E584486A7CEF620BC9D3320'),(4411,'c','float f =1.1  ','E6E31C640E584486A7CEF620BC9D3320'),(4412,'d','double d = 34.4','E6E31C640E584486A7CEF620BC9D3320'),(4413,'a','输出：test ','F2E94965759944C5AC98BB548476DEC9'),(4414,'b','输出：Exception ','F2E94965759944C5AC98BB548476DEC9'),(4415,'c','编译失败 ','F2E94965759944C5AC98BB548476DEC9'),(4416,'d','输出：NullPointerException ','F2E94965759944C5AC98BB548476DEC9'),(4417,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','67121C4B66C0486ABDBDE2C88BFAD0F8'),(4418,'b','垃圾收集将检查并释放不在使用的内存  ','67121C4B66C0486ABDBDE2C88BFAD0F8'),(4419,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','67121C4B66C0486ABDBDE2C88BFAD0F8'),(4420,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','67121C4B66C0486ABDBDE2C88BFAD0F8'),(4421,'a','编译错误 ','3EBF6814453340B2A2B61CA8DD0E4463'),(4422,'b','抛出运行时异常 ','3EBF6814453340B2A2B61CA8DD0E4463'),(4423,'c','输出：sleep ','3EBF6814453340B2A2B61CA8DD0E4463'),(4424,'d','代码正常运行，但是无输出 ','3EBF6814453340B2A2B61CA8DD0E4463'),(4425,'a','输出Exception ','96B053B715C2420893AE229AA76D611E'),(4426,'b','输出A,B,Exception ','96B053B715C2420893AE229AA76D611E'),(4427,'c','编译失败 ','96B053B715C2420893AE229AA76D611E'),(4428,'d','在运行时抛出NullPointerException异常 ','96B053B715C2420893AE229AA76D611E'),(4429,'a','栈是非线性结构        ','CD50264C40BB436CA9074CB0B8EC6259'),(4430,'b','栈是一种树状结构 ','CD50264C40BB436CA9074CB0B8EC6259'),(4431,'c','栈具有先进先出的特征  ','CD50264C40BB436CA9074CB0B8EC6259'),(4432,'d','栈具有后进先出的特征 ','CD50264C40BB436CA9074CB0B8EC6259'),(4433,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','9AFF39DB01CE451984A72F03FAAD0D2E'),(4434,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','9AFF39DB01CE451984A72F03FAAD0D2E'),(4435,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','9AFF39DB01CE451984A72F03FAAD0D2E'),(4436,'d','new InputStreamReader(\"1.dat\") ; ','9AFF39DB01CE451984A72F03FAAD0D2E'),(4437,'a','编译错误 ','8EB75F2B747347EC8B02E1D5AF61D47B'),(4438,'b','程序可以通过编译，运行后文件company.txt没有任何改变','8EB75F2B747347EC8B02E1D5AF61D47B'),(4439,'c','程序可以通过编译，运行后文件company.txt的长度变为0','8EB75F2B747347EC8B02E1D5AF61D47B'),(4440,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','8EB75F2B747347EC8B02E1D5AF61D47B'),(4441,'a','编译错误 ','948F7B7A3FCE4EF98E72049FB08F9B3D'),(4442,'b','实现向文件record.dat追加写入字符a ','948F7B7A3FCE4EF98E72049FB08F9B3D'),(4443,'c','实现向文件record.dat覆盖写入字符a ','948F7B7A3FCE4EF98E72049FB08F9B3D'),(4444,'d','文件record.dat无任何内容 ','948F7B7A3FCE4EF98E72049FB08F9B3D'),(4445,'a','编译错误 ','813DFF9649A7465FB621A7A5D2682467'),(4446,'b','实现向文件record.dat追加写入字符a ','813DFF9649A7465FB621A7A5D2682467'),(4447,'c','实现向文件record.dat覆盖写入字符a ','813DFF9649A7465FB621A7A5D2682467'),(4448,'d','文件record.dat无任何内容 ','813DFF9649A7465FB621A7A5D2682467'),(4449,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','47AD197D959C4A16AD817FBE3DDDA7F5'),(4450,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','47AD197D959C4A16AD817FBE3DDDA7F5'),(4451,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','47AD197D959C4A16AD817FBE3DDDA7F5'),(4452,'d','new InputStreamReader(\"dat\") ; ','47AD197D959C4A16AD817FBE3DDDA7F5'),(4453,'a','const   ','14EC3A99C1C84B0D8139501430EA6AFD'),(4454,'b','NULL  ','14EC3A99C1C84B0D8139501430EA6AFD'),(4455,'c','false   ','14EC3A99C1C84B0D8139501430EA6AFD'),(4456,'d','this  ','14EC3A99C1C84B0D8139501430EA6AFD'),(4457,'a','m.length()    ','B046E932274B4F4DBEDAD15BBABEF4AE'),(4458,'b','m.length   ','B046E932274B4F4DBEDAD15BBABEF4AE'),(4459,'c','m.length()+1   ','B046E932274B4F4DBEDAD15BBABEF4AE'),(4460,'d','m.length-1','B046E932274B4F4DBEDAD15BBABEF4AE'),(4461,'a','sleep方法 ','C93DAFA1ADAA4735A05AE9F95241EDC6'),(4462,'b','IO等待 ','C93DAFA1ADAA4735A05AE9F95241EDC6'),(4463,'c','yield方法 ','C93DAFA1ADAA4735A05AE9F95241EDC6'),(4464,'d','wait方法 ','C93DAFA1ADAA4735A05AE9F95241EDC6'),(4465,'a','5.0','BFE462F80A874FE1A7F5819C26A5A140'),(4466,'b','4.0','BFE462F80A874FE1A7F5819C26A5A140'),(4467,'c','6.0','BFE462F80A874FE1A7F5819C26A5A140'),(4468,'d','finished','BFE462F80A874FE1A7F5819C26A5A140'),(4469,'a','输出：4 ','9C154B1EF7BF4A078CCA3656BB158699'),(4470,'b','在运行时抛出NullPointerException异常 ','9C154B1EF7BF4A078CCA3656BB158699'),(4471,'c','在运行时抛出NumberFormatException异常 ','9C154B1EF7BF4A078CCA3656BB158699'),(4472,'d','在运行时抛出IllegalStateException异常 ','9C154B1EF7BF4A078CCA3656BB158699'),(4473,'a','sleep方法 ','5EC69CE7407948D3805A8999B4CAC654'),(4474,'b','IO等待 ','5EC69CE7407948D3805A8999B4CAC654'),(4475,'c','yield方法 ','5EC69CE7407948D3805A8999B4CAC654'),(4476,'d','wait方法 ','5EC69CE7407948D3805A8999B4CAC654'),(4477,'a','public void method( int m){...}     ','587C362DCCC14B5BA46D1A7A893479FE'),(4478,'b','public int method(){...} ','587C362DCCC14B5BA46D1A7A893479FE'),(4479,'c','public void method2(){...}    ','587C362DCCC14B5BA46D1A7A893479FE'),(4480,'d','public int method(int m，float f ){...} ','587C362DCCC14B5BA46D1A7A893479FE'),(4481,'a','public void method( int m){...}     ','25F3FBA293764D94A9394C2729C79972'),(4482,'b','public int method(){...} ','25F3FBA293764D94A9394C2729C79972'),(4483,'c','public void method2(){...}    ','25F3FBA293764D94A9394C2729C79972'),(4484,'d','public int method(int m，float f ){...} ','25F3FBA293764D94A9394C2729C79972'),(4485,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','97D7CA30B1E344869E8619DEABD156F4'),(4486,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','97D7CA30B1E344869E8619DEABD156F4'),(4487,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','97D7CA30B1E344869E8619DEABD156F4'),(4488,'d','new InputStreamReader(\"dat\") ; ','97D7CA30B1E344869E8619DEABD156F4'),(4489,'a','sleep方法 ','C1381A4661A64CBAAEE49D6BD7D049DF'),(4490,'b','IO等待 ','C1381A4661A64CBAAEE49D6BD7D049DF'),(4491,'c','yield方法 ','C1381A4661A64CBAAEE49D6BD7D049DF'),(4492,'d','wait方法 ','C1381A4661A64CBAAEE49D6BD7D049DF'),(4493,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','AD684B6DEE7148FDA9468A12E44EF9E9'),(4494,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','AD684B6DEE7148FDA9468A12E44EF9E9'),(4495,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','AD684B6DEE7148FDA9468A12E44EF9E9'),(4496,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','AD684B6DEE7148FDA9468A12E44EF9E9'),(4497,'a','编译错误 ','C0B87C72595E4299B1C68A0B63865C06'),(4498,'b','抛出运行时异常 ','C0B87C72595E4299B1C68A0B63865C06'),(4499,'c','输出：bar ','C0B87C72595E4299B1C68A0B63865C06'),(4500,'d','代码正常运行，但是无输出 ','C0B87C72595E4299B1C68A0B63865C06'),(4501,'a','start()    ','09365560EE224D558C2BE30364DC9051'),(4502,'b','init()    ','09365560EE224D558C2BE30364DC9051'),(4503,'c','run()    ','09365560EE224D558C2BE30364DC9051'),(4504,'d','main()  ','09365560EE224D558C2BE30364DC9051'),(4505,'a','5.0','14249FAA35E343A49C0835A82CC9773F'),(4506,'b','4.0','14249FAA35E343A49C0835A82CC9773F'),(4507,'c','6.0','14249FAA35E343A49C0835A82CC9773F'),(4508,'d','finished','14249FAA35E343A49C0835A82CC9773F'),(4509,'a','名为dtThread的线程为守护线程 ','F477C34F8ADD4FDDBC100BE6F1009C9F'),(4510,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','F477C34F8ADD4FDDBC100BE6F1009C9F'),(4511,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','F477C34F8ADD4FDDBC100BE6F1009C9F'),(4512,'d','main线程是守护线程 ','F477C34F8ADD4FDDBC100BE6F1009C9F'),(4513,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','A29048802E814634AA73AB5D72E69447'),(4514,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','A29048802E814634AA73AB5D72E69447'),(4515,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','A29048802E814634AA73AB5D72E69447'),(4516,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','A29048802E814634AA73AB5D72E69447'),(4517,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','F57FE2EB0EA542AB9472778821BAD7A3'),(4518,'b','垃圾收集将检查并释放不在使用的内存  ','F57FE2EB0EA542AB9472778821BAD7A3'),(4519,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','F57FE2EB0EA542AB9472778821BAD7A3'),(4520,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','F57FE2EB0EA542AB9472778821BAD7A3'),(4521,'a','s>>>=3   ','2D99730DF6CD407A9718DA57BC5ECE2C'),(4522,'b','s[3]= “X”  ','2D99730DF6CD407A9718DA57BC5ECE2C'),(4523,'c','int i = s.length()   ','2D99730DF6CD407A9718DA57BC5ECE2C'),(4524,'d','s = s + 10 ','2D99730DF6CD407A9718DA57BC5ECE2C'),(4525,'a','输出：test ','45504D0AAFC84F2FB878934036685865'),(4526,'b','输出：Exception ','45504D0AAFC84F2FB878934036685865'),(4527,'c','编译失败 ','45504D0AAFC84F2FB878934036685865'),(4528,'d','输出：NullPointerException ','45504D0AAFC84F2FB878934036685865'),(4529,'a','通过调用stop()方法而停止的线程。 ','149386A467344D2A8B43AED0EF7C089E'),(4530,'b','通过调用sleep()方法而停止的线程。 ','149386A467344D2A8B43AED0EF7C089E'),(4531,'c','通过调用wait()方法而停止的线程。 ','149386A467344D2A8B43AED0EF7C089E'),(4532,'d','通过调用suspend()方法而停止的线程。 ','149386A467344D2A8B43AED0EF7C089E'),(4533,'a','编译错误 ','F3B2EE9EDD4749109584A5C9D68414AD'),(4534,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F3B2EE9EDD4749109584A5C9D68414AD'),(4535,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F3B2EE9EDD4749109584A5C9D68414AD'),(4536,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F3B2EE9EDD4749109584A5C9D68414AD'),(4537,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','B0FA93EE9B63405CB5D268C2AC54F94A'),(4538,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','B0FA93EE9B63405CB5D268C2AC54F94A'),(4539,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','B0FA93EE9B63405CB5D268C2AC54F94A'),(4540,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','B0FA93EE9B63405CB5D268C2AC54F94A'),(4541,'a','Output is null.             ','45FDBE15934249F1BB9BAD516FBEE325'),(4542,'b','Output is 0 ','45FDBE15934249F1BB9BAD516FBEE325'),(4543,'c','编译时报错 ','45FDBE15934249F1BB9BAD516FBEE325'),(4544,'d','运行时报错','45FDBE15934249F1BB9BAD516FBEE325'),(4545,'a','long 1 = 4990  ','FEEDF1B3BF504333B4FFF0680D2B03C1'),(4546,'b','int i = 4L  ','FEEDF1B3BF504333B4FFF0680D2B03C1'),(4547,'c','float f =1.1  ','FEEDF1B3BF504333B4FFF0680D2B03C1'),(4548,'d','double d = 34.4','FEEDF1B3BF504333B4FFF0680D2B03C1'),(4549,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','A84749A9745C4F948392595C675C019B'),(4550,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','A84749A9745C4F948392595C675C019B'),(4551,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','A84749A9745C4F948392595C675C019B'),(4552,'d','new InputStreamReader(\"dat\") ; ','A84749A9745C4F948392595C675C019B'),(4553,'a','第3行抛出异常 ','E9A3A125A0404FDFB6011742DB6DB6B9'),(4554,'b','第1行抛出异常 ','E9A3A125A0404FDFB6011742DB6DB6B9'),(4555,'c','第5行抛出异常 ','E9A3A125A0404FDFB6011742DB6DB6B9'),(4556,'d','第3行代码成功执行 ','E9A3A125A0404FDFB6011742DB6DB6B9'),(4557,'a','m.length()    ','9B29B0874B4C4AE08E514C328B2187CD'),(4558,'b','m.length   ','9B29B0874B4C4AE08E514C328B2187CD'),(4559,'c','m.length()+1   ','9B29B0874B4C4AE08E514C328B2187CD'),(4560,'d','m.length-1','9B29B0874B4C4AE08E514C328B2187CD'),(4561,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','E3F3949B95CD43599E1E7B3AD55E4F4D'),(4562,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','E3F3949B95CD43599E1E7B3AD55E4F4D'),(4563,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','E3F3949B95CD43599E1E7B3AD55E4F4D'),(4564,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','E3F3949B95CD43599E1E7B3AD55E4F4D'),(4565,'a','编译错误 ','A8C86230C4DF425887ECCAAEB5CC02C6'),(4566,'b','抛出运行时异常 ','A8C86230C4DF425887ECCAAEB5CC02C6'),(4567,'c','输出：bar ','A8C86230C4DF425887ECCAAEB5CC02C6'),(4568,'d','代码正常运行，但是无输出 ','A8C86230C4DF425887ECCAAEB5CC02C6'),(4569,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','F01DAA2BBFD2443FAE096B23884C24AE'),(4570,'b','垃圾收集将检查并释放不在使用的内存  ','F01DAA2BBFD2443FAE096B23884C24AE'),(4571,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','F01DAA2BBFD2443FAE096B23884C24AE'),(4572,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','F01DAA2BBFD2443FAE096B23884C24AE'),(4573,'a','InputStreamReader','2E262AAD34AC48829568882086D7202F'),(4574,'b','BufferedReader','2E262AAD34AC48829568882086D7202F'),(4575,'c','FileInputStream','2E262AAD34AC48829568882086D7202F'),(4576,'d','InputStream','2E262AAD34AC48829568882086D7202F'),(4577,'a','将private int m改为 protected int m  ','6BB2AD5611C542409938D024EC097EE7'),(4578,'b','将private int m改为 public int m    ','6BB2AD5611C542409938D024EC097EE7'),(4579,'c','将private int m改为 static int m     ','6BB2AD5611C542409938D024EC097EE7'),(4580,'d','将private int m改为int m ','6BB2AD5611C542409938D024EC097EE7'),(4581,'a','Output is null.             ','DB99F657D4E44E369C3A9E4A0A46791A'),(4582,'b','Output is 0 ','DB99F657D4E44E369C3A9E4A0A46791A'),(4583,'c','编译时报错 ','DB99F657D4E44E369C3A9E4A0A46791A'),(4584,'d','运行时报错','DB99F657D4E44E369C3A9E4A0A46791A'),(4585,'a','编译错误 ','54596B78F8E14FB790FCA3624ADBA8C7'),(4586,'b','实现向文件record.dat追加写入字符a ','54596B78F8E14FB790FCA3624ADBA8C7'),(4587,'c','实现向文件record.dat覆盖写入字符a ','54596B78F8E14FB790FCA3624ADBA8C7'),(4588,'d','文件record.dat无任何内容 ','54596B78F8E14FB790FCA3624ADBA8C7'),(4589,'a','public void method( int m){...}     ','EAC5B4E23C194EA28FD27E9880D8E20A'),(4590,'b','public int method(){...} ','EAC5B4E23C194EA28FD27E9880D8E20A'),(4591,'c','public void method2(){...}    ','EAC5B4E23C194EA28FD27E9880D8E20A'),(4592,'d','public int method(int m，float f ){...} ','EAC5B4E23C194EA28FD27E9880D8E20A'),(4593,'a','public void method( int m){...}     ','1030CC74D14B4403918928BAB6809B31'),(4594,'b','public int method(){...} ','1030CC74D14B4403918928BAB6809B31'),(4595,'c','public void method2(){...}    ','1030CC74D14B4403918928BAB6809B31'),(4596,'d','public int method(int m，float f ){...} ','1030CC74D14B4403918928BAB6809B31'),(4597,'a','public void method( int m){...}     ','D6F6401553564E08A4E581FF84397848'),(4598,'b','public int method(){...} ','D6F6401553564E08A4E581FF84397848'),(4599,'c','public void method2(){...}    ','D6F6401553564E08A4E581FF84397848'),(4600,'d','public int method(int m，float f ){...} ','D6F6401553564E08A4E581FF84397848'),(4601,'a','一旦一个线程被创建，它就立即开始运行。  ','BD896FBFACFC4B36AF0FE24DECEBDC19'),(4602,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','BD896FBFACFC4B36AF0FE24DECEBDC19'),(4603,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','BD896FBFACFC4B36AF0FE24DECEBDC19'),(4604,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','BD896FBFACFC4B36AF0FE24DECEBDC19'),(4605,'a','将private int m改为 protected int m  ','F65F5369D2AC474689AAE38FFF7C932B'),(4606,'b','将private int m改为 public int m    ','F65F5369D2AC474689AAE38FFF7C932B'),(4607,'c','将private int m改为 static int m     ','F65F5369D2AC474689AAE38FFF7C932B'),(4608,'d','将private int m改为int m ','F65F5369D2AC474689AAE38FFF7C932B'),(4609,'a','private synchronized Object o; ','15E755B3282C4516811D36F9B0545C22'),(4610,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','15E755B3282C4516811D36F9B0545C22'),(4611,'c','public synchronized void go() { /* code here */ } ','15E755B3282C4516811D36F9B0545C22'),(4612,'d','private synchronized(this) void go() { /* code here */ } ','15E755B3282C4516811D36F9B0545C22'),(4613,'a','一旦一个线程被创建，它就立即开始运行。  ','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(4614,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(4615,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(4616,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','BE2B369CE4C24FC3BFFCC852DC7E46A2'),(4617,'a','通过调用stop()方法而停止的线程。 ','5D8E662FC59B439B8A68D3D318B47F80'),(4618,'b','通过调用sleep()方法而停止的线程。 ','5D8E662FC59B439B8A68D3D318B47F80'),(4619,'c','通过调用wait()方法而停止的线程。 ','5D8E662FC59B439B8A68D3D318B47F80'),(4620,'d','通过调用suspend()方法而停止的线程。 ','5D8E662FC59B439B8A68D3D318B47F80'),(4621,'a','编译错误 ','2DD6A8444DD84E3C81DFD05EED3DC320'),(4622,'b','实现向文件record.dat追加写入字符a ','2DD6A8444DD84E3C81DFD05EED3DC320'),(4623,'c','实现向文件record.dat覆盖写入字符a ','2DD6A8444DD84E3C81DFD05EED3DC320'),(4624,'d','文件record.dat无任何内容 ','2DD6A8444DD84E3C81DFD05EED3DC320'),(4625,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','5A0CE621D2F64D7E90B7ACDD84782F0D'),(4626,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','5A0CE621D2F64D7E90B7ACDD84782F0D'),(4627,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','5A0CE621D2F64D7E90B7ACDD84782F0D'),(4628,'d','new InputStreamReader(\"1.dat\") ; ','5A0CE621D2F64D7E90B7ACDD84782F0D'),(4629,'a','sleep方法 ','8F87953473BE47C59C6CBA463610D189'),(4630,'b','IO等待 ','8F87953473BE47C59C6CBA463610D189'),(4631,'c','yield方法 ','8F87953473BE47C59C6CBA463610D189'),(4632,'d','wait方法 ','8F87953473BE47C59C6CBA463610D189'),(4633,'a','start()    ','37DF54D7E16343ED847816BB63989CC5'),(4634,'b','init()    ','37DF54D7E16343ED847816BB63989CC5'),(4635,'c','run()    ','37DF54D7E16343ED847816BB63989CC5'),(4636,'d','main()  ','37DF54D7E16343ED847816BB63989CC5'),(4637,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','A0BBAE12E8C149038CB4C140C9BA58B3'),(4638,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','A0BBAE12E8C149038CB4C140C9BA58B3'),(4639,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','A0BBAE12E8C149038CB4C140C9BA58B3'),(4640,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','A0BBAE12E8C149038CB4C140C9BA58B3'),(4641,'a','private synchronized Object o; ','0D11249964FD4A75BC97E2010A771B4A'),(4642,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','0D11249964FD4A75BC97E2010A771B4A'),(4643,'c','public synchronized void go() { /* code here */ } ','0D11249964FD4A75BC97E2010A771B4A'),(4644,'d','private synchronized(this) void go() { /* code here */ } ','0D11249964FD4A75BC97E2010A771B4A'),(4645,'a','Output is null.             ','F9436FC4DBEA4FDBA5200454D7C5327A'),(4646,'b','Output is 0 ','F9436FC4DBEA4FDBA5200454D7C5327A'),(4647,'c','编译时报错 ','F9436FC4DBEA4FDBA5200454D7C5327A'),(4648,'d','运行时报错','F9436FC4DBEA4FDBA5200454D7C5327A'),(4649,'a','输出：4 ','56838134CD794ACAA44586DBF5F3B959'),(4650,'b','在运行时抛出NullPointerException异常 ','56838134CD794ACAA44586DBF5F3B959'),(4651,'c','在运行时抛出NumberFormatException异常 ','56838134CD794ACAA44586DBF5F3B959'),(4652,'d','在运行时抛出IllegalStateException异常 ','56838134CD794ACAA44586DBF5F3B959'),(4653,'a','名为dtThread的线程为守护线程 ','384941E85F064F08A4083AEA6B0D8817'),(4654,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','384941E85F064F08A4083AEA6B0D8817'),(4655,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','384941E85F064F08A4083AEA6B0D8817'),(4656,'d','main线程是守护线程 ','384941E85F064F08A4083AEA6B0D8817'),(4657,'a','编译错误 ','5A9716CE20D1462680A593B6C5B89CEB'),(4658,'b','程序可以通过编译，运行后文件company.txt没有任何改变','5A9716CE20D1462680A593B6C5B89CEB'),(4659,'c','程序可以通过编译，运行后文件company.txt的长度变为0','5A9716CE20D1462680A593B6C5B89CEB'),(4660,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','5A9716CE20D1462680A593B6C5B89CEB'),(4661,'a','编译错误 ','A1CD728328734A96A8655BB21E7B378A'),(4662,'b','实现向文件record.dat追加写入字符a ','A1CD728328734A96A8655BB21E7B378A'),(4663,'c','实现向文件record.dat覆盖写入字符a ','A1CD728328734A96A8655BB21E7B378A'),(4664,'d','文件record.dat无任何内容 ','A1CD728328734A96A8655BB21E7B378A'),(4665,'a','编译错误 ','0AA606B630FD45FD842E0407601799B3'),(4666,'b','实现向文件record.dat追加写入字符a ','0AA606B630FD45FD842E0407601799B3'),(4667,'c','实现向文件record.dat覆盖写入字符a ','0AA606B630FD45FD842E0407601799B3'),(4668,'d','文件record.dat无任何内容 ','0AA606B630FD45FD842E0407601799B3'),(4669,'a','输出：4 ','52A6E4E1F52447D1B4E94DFBAFFE4500'),(4670,'b','在运行时抛出NullPointerException异常 ','52A6E4E1F52447D1B4E94DFBAFFE4500'),(4671,'c','在运行时抛出NumberFormatException异常 ','52A6E4E1F52447D1B4E94DFBAFFE4500'),(4672,'d','在运行时抛出IllegalStateException异常 ','52A6E4E1F52447D1B4E94DFBAFFE4500'),(4673,'a','const   ','A6B8AFDB00714456914F07751B3FB1A0'),(4674,'b','NULL  ','A6B8AFDB00714456914F07751B3FB1A0'),(4675,'c','false   ','A6B8AFDB00714456914F07751B3FB1A0'),(4676,'d','this  ','A6B8AFDB00714456914F07751B3FB1A0'),(4677,'a','输出：test ','1C100AA2C8024D98897499F8209C5AF4'),(4678,'b','输出：Exception ','1C100AA2C8024D98897499F8209C5AF4'),(4679,'c','编译失败 ','1C100AA2C8024D98897499F8209C5AF4'),(4680,'d','输出：NullPointerException ','1C100AA2C8024D98897499F8209C5AF4'),(4681,'a','const   ','4C6F72C4C8B14C7ABC4199A389B65481'),(4682,'b','NULL  ','4C6F72C4C8B14C7ABC4199A389B65481'),(4683,'c','false   ','4C6F72C4C8B14C7ABC4199A389B65481'),(4684,'d','this  ','4C6F72C4C8B14C7ABC4199A389B65481'),(4685,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','F0DB9D7F36304DA5A6461A92E257B375'),(4686,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','F0DB9D7F36304DA5A6461A92E257B375'),(4687,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','F0DB9D7F36304DA5A6461A92E257B375'),(4688,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','F0DB9D7F36304DA5A6461A92E257B375'),(4689,'a','sleep方法 ','3D1A14ECFFA0406584B905BA2F690773'),(4690,'b','IO等待 ','3D1A14ECFFA0406584B905BA2F690773'),(4691,'c','yield方法 ','3D1A14ECFFA0406584B905BA2F690773'),(4692,'d','wait方法 ','3D1A14ECFFA0406584B905BA2F690773'),(4693,'a','输出Exception ','739E8ABCE7C64F2C83E502206109DFDB'),(4694,'b','输出A,B,Exception ','739E8ABCE7C64F2C83E502206109DFDB'),(4695,'c','编译失败 ','739E8ABCE7C64F2C83E502206109DFDB'),(4696,'d','在运行时抛出NullPointerException异常 ','739E8ABCE7C64F2C83E502206109DFDB'),(4697,'a','通过调用stop()方法而停止的线程。 ','E38F2EBDBC434FB1918C4828583DB36A'),(4698,'b','通过调用sleep()方法而停止的线程。 ','E38F2EBDBC434FB1918C4828583DB36A'),(4699,'c','通过调用wait()方法而停止的线程。 ','E38F2EBDBC434FB1918C4828583DB36A'),(4700,'d','通过调用suspend()方法而停止的线程。 ','E38F2EBDBC434FB1918C4828583DB36A'),(4701,'a','m.length()    ','191292A230724D4EB6F19FEAEABC3278'),(4702,'b','m.length   ','191292A230724D4EB6F19FEAEABC3278'),(4703,'c','m.length()+1   ','191292A230724D4EB6F19FEAEABC3278'),(4704,'d','m.length-1','191292A230724D4EB6F19FEAEABC3278'),(4705,'a','编译错误 ','4844E0394ED7459292ABAE08E6EF78CD'),(4706,'b','实现向文件record.dat追加写入字符a ','4844E0394ED7459292ABAE08E6EF78CD'),(4707,'c','实现向文件record.dat覆盖写入字符a ','4844E0394ED7459292ABAE08E6EF78CD'),(4708,'d','文件record.dat无任何内容 ','4844E0394ED7459292ABAE08E6EF78CD'),(4709,'a','s>>>=3   ','34C5617C9A8B46A9AB391DBA635EE335'),(4710,'b','s[3]= “X”  ','34C5617C9A8B46A9AB391DBA635EE335'),(4711,'c','int i = s.length()   ','34C5617C9A8B46A9AB391DBA635EE335'),(4712,'d','s = s + 10 ','34C5617C9A8B46A9AB391DBA635EE335'),(4713,'a','第3行抛出异常 ','6D16485C782647E6BAD95B07B3ADFC17'),(4714,'b','第1行抛出异常 ','6D16485C782647E6BAD95B07B3ADFC17'),(4715,'c','第5行抛出异常 ','6D16485C782647E6BAD95B07B3ADFC17'),(4716,'d','第3行代码成功执行 ','6D16485C782647E6BAD95B07B3ADFC17'),(4717,'a','编译错误 ','1D0190BAE74B4ADB9BB11A2EE0B76055'),(4718,'b','实现向文件record.dat追加写入字符a ','1D0190BAE74B4ADB9BB11A2EE0B76055'),(4719,'c','实现向文件record.dat覆盖写入字符a ','1D0190BAE74B4ADB9BB11A2EE0B76055'),(4720,'d','文件record.dat无任何内容 ','1D0190BAE74B4ADB9BB11A2EE0B76055'),(4721,'a','名为dtThread的线程为守护线程 ','A75A32CCEE03492E90F11BF8C9B64057'),(4722,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','A75A32CCEE03492E90F11BF8C9B64057'),(4723,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','A75A32CCEE03492E90F11BF8C9B64057'),(4724,'d','main线程是守护线程 ','A75A32CCEE03492E90F11BF8C9B64057'),(4725,'a','通过调用stop()方法而停止的线程。 ','CB673174F5CA450290C914D6BD2F851E'),(4726,'b','通过调用sleep()方法而停止的线程。 ','CB673174F5CA450290C914D6BD2F851E'),(4727,'c','通过调用wait()方法而停止的线程。 ','CB673174F5CA450290C914D6BD2F851E'),(4728,'d','通过调用suspend()方法而停止的线程。 ','CB673174F5CA450290C914D6BD2F851E'),(4729,'a','栈是非线性结构        ','D95BDD7369DE4DF4AF0CA6665ABC1B06'),(4730,'b','栈是一种树状结构 ','D95BDD7369DE4DF4AF0CA6665ABC1B06'),(4731,'c','栈具有先进先出的特征  ','D95BDD7369DE4DF4AF0CA6665ABC1B06'),(4732,'d','栈具有后进先出的特征 ','D95BDD7369DE4DF4AF0CA6665ABC1B06'),(4733,'a','5.0','AC30E75DE43745BC85CBCDD915D9F1B8'),(4734,'b','4.0','AC30E75DE43745BC85CBCDD915D9F1B8'),(4735,'c','6.0','AC30E75DE43745BC85CBCDD915D9F1B8'),(4736,'d','finished','AC30E75DE43745BC85CBCDD915D9F1B8'),(4737,'a','m.length()    ','CB75519CBDEE40A787C87C7166B8052D'),(4738,'b','m.length   ','CB75519CBDEE40A787C87C7166B8052D'),(4739,'c','m.length()+1   ','CB75519CBDEE40A787C87C7166B8052D'),(4740,'d','m.length-1','CB75519CBDEE40A787C87C7166B8052D'),(4741,'a','Output is null.             ','D439C38591184F2983CAD78714385D7B'),(4742,'b','Output is 0 ','D439C38591184F2983CAD78714385D7B'),(4743,'c','编译时报错 ','D439C38591184F2983CAD78714385D7B'),(4744,'d','运行时报错','D439C38591184F2983CAD78714385D7B'),(4745,'a','输出Exception ','F1530F13F5A14DEA9F91746A872DD4C6'),(4746,'b','输出A,B,Exception ','F1530F13F5A14DEA9F91746A872DD4C6'),(4747,'c','编译失败 ','F1530F13F5A14DEA9F91746A872DD4C6'),(4748,'d','在运行时抛出NullPointerException异常 ','F1530F13F5A14DEA9F91746A872DD4C6'),(4749,'a','编译错误 ','F5254E1EB9FA40C0A33494D306C600D1'),(4750,'b','抛出运行时异常 ','F5254E1EB9FA40C0A33494D306C600D1'),(4751,'c','输出：sleep ','F5254E1EB9FA40C0A33494D306C600D1'),(4752,'d','代码正常运行，但是无输出 ','F5254E1EB9FA40C0A33494D306C600D1'),(4753,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','DEDFE4A171E141459A1430AF359CC194'),(4754,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','DEDFE4A171E141459A1430AF359CC194'),(4755,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','DEDFE4A171E141459A1430AF359CC194'),(4756,'d','new InputStreamReader(\"1.dat\") ; ','DEDFE4A171E141459A1430AF359CC194'),(4757,'a','s>>>=3   ','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(4758,'b','s[3]= “X”  ','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(4759,'c','int i = s.length()   ','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(4760,'d','s = s + 10 ','3E8A67E3B22B4665B2F7BE8B4A00FE6D'),(4761,'a','栈是非线性结构        ','DE65B6DBF034456A9C46D143E0C594DA'),(4762,'b','栈是一种树状结构 ','DE65B6DBF034456A9C46D143E0C594DA'),(4763,'c','栈具有先进先出的特征  ','DE65B6DBF034456A9C46D143E0C594DA'),(4764,'d','栈具有后进先出的特征 ','DE65B6DBF034456A9C46D143E0C594DA'),(4765,'a','start()    ','BC43E962D27248CFA70EDE6E1DC6E0AF'),(4766,'b','init()    ','BC43E962D27248CFA70EDE6E1DC6E0AF'),(4767,'c','run()    ','BC43E962D27248CFA70EDE6E1DC6E0AF'),(4768,'d','main()  ','BC43E962D27248CFA70EDE6E1DC6E0AF'),(4769,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','9E1D56FA615D42BA8734B31FACFD32DF'),(4770,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','9E1D56FA615D42BA8734B31FACFD32DF'),(4771,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','9E1D56FA615D42BA8734B31FACFD32DF'),(4772,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','9E1D56FA615D42BA8734B31FACFD32DF'),(4773,'a','long 1 = 4990  ','3D5B2245D815422DAB789D69EBA0F590'),(4774,'b','int i = 4L  ','3D5B2245D815422DAB789D69EBA0F590'),(4775,'c','float f =1.1  ','3D5B2245D815422DAB789D69EBA0F590'),(4776,'d','double d = 34.4','3D5B2245D815422DAB789D69EBA0F590'),(4777,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','1061C923799E4CD68CB4D7DDE2C92FFF'),(4778,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','1061C923799E4CD68CB4D7DDE2C92FFF'),(4779,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','1061C923799E4CD68CB4D7DDE2C92FFF'),(4780,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','1061C923799E4CD68CB4D7DDE2C92FFF'),(4781,'a','栈是非线性结构        ','DA984EA888EB4427A3F91FD8658FC24A'),(4782,'b','栈是一种树状结构 ','DA984EA888EB4427A3F91FD8658FC24A'),(4783,'c','栈具有先进先出的特征  ','DA984EA888EB4427A3F91FD8658FC24A'),(4784,'d','栈具有后进先出的特征 ','DA984EA888EB4427A3F91FD8658FC24A'),(4785,'a','编译错误 ','F6BFE1D6183344C5B76596F9A0F5594E'),(4786,'b','抛出运行时异常 ','F6BFE1D6183344C5B76596F9A0F5594E'),(4787,'c','输出：sleep ','F6BFE1D6183344C5B76596F9A0F5594E'),(4788,'d','代码正常运行，但是无输出 ','F6BFE1D6183344C5B76596F9A0F5594E'),(4789,'a','InputStreamReader','DCABE90E97B24CC09AA85C70D6999F4D'),(4790,'b','BufferedReader','DCABE90E97B24CC09AA85C70D6999F4D'),(4791,'c','FileInputStream','DCABE90E97B24CC09AA85C70D6999F4D'),(4792,'d','InputStream','DCABE90E97B24CC09AA85C70D6999F4D'),(4793,'a','名为dtThread的线程为守护线程 ','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(4794,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(4795,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(4796,'d','main线程是守护线程 ','AFC9B76CE4EE4DED9B67B783EEF78E2F'),(4797,'a','输出：4 ','9E2CEBB34C624D5A986A93F7805F2615'),(4798,'b','在运行时抛出NullPointerException异常 ','9E2CEBB34C624D5A986A93F7805F2615'),(4799,'c','在运行时抛出NumberFormatException异常 ','9E2CEBB34C624D5A986A93F7805F2615'),(4800,'d','在运行时抛出IllegalStateException异常 ','9E2CEBB34C624D5A986A93F7805F2615'),(4801,'a','sleep方法 ','8E628AAEE22341B7BE46FD612B8A19CC'),(4802,'b','IO等待 ','8E628AAEE22341B7BE46FD612B8A19CC'),(4803,'c','yield方法 ','8E628AAEE22341B7BE46FD612B8A19CC'),(4804,'d','wait方法 ','8E628AAEE22341B7BE46FD612B8A19CC'),(4805,'a','const   ','47B51A629F9A4C13895B84F3788801F9'),(4806,'b','NULL  ','47B51A629F9A4C13895B84F3788801F9'),(4807,'c','false   ','47B51A629F9A4C13895B84F3788801F9'),(4808,'d','this  ','47B51A629F9A4C13895B84F3788801F9'),(4809,'a','5.0','C0E1D38F453048669840CC9C1F7C7BCB'),(4810,'b','4.0','C0E1D38F453048669840CC9C1F7C7BCB'),(4811,'c','6.0','C0E1D38F453048669840CC9C1F7C7BCB'),(4812,'d','finished','C0E1D38F453048669840CC9C1F7C7BCB'),(4813,'a','start()    ','0C3B3A0A7F484C81B514BE6594A93479'),(4814,'b','init()    ','0C3B3A0A7F484C81B514BE6594A93479'),(4815,'c','run()    ','0C3B3A0A7F484C81B514BE6594A93479'),(4816,'d','main()  ','0C3B3A0A7F484C81B514BE6594A93479'),(4817,'a','s>>>=3   ','A17D3EF310BA41A49665FA0D873E9C27'),(4818,'b','s[3]= “X”  ','A17D3EF310BA41A49665FA0D873E9C27'),(4819,'c','int i = s.length()   ','A17D3EF310BA41A49665FA0D873E9C27'),(4820,'d','s = s + 10 ','A17D3EF310BA41A49665FA0D873E9C27'),(4821,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','346501B7F0034B7DBAA2884AB5E658C0'),(4822,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','346501B7F0034B7DBAA2884AB5E658C0'),(4823,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','346501B7F0034B7DBAA2884AB5E658C0'),(4824,'d','new InputStreamReader(\"dat\") ; ','346501B7F0034B7DBAA2884AB5E658C0'),(4825,'a','将private int m改为 protected int m  ','75557D048F23453692EE5E12B2BF12C2'),(4826,'b','将private int m改为 public int m    ','75557D048F23453692EE5E12B2BF12C2'),(4827,'c','将private int m改为 static int m     ','75557D048F23453692EE5E12B2BF12C2'),(4828,'d','将private int m改为int m ','75557D048F23453692EE5E12B2BF12C2'),(4829,'a','输出：test ','EF97015C5FF4418DBF4C60636754774D'),(4830,'b','输出：Exception ','EF97015C5FF4418DBF4C60636754774D'),(4831,'c','编译失败 ','EF97015C5FF4418DBF4C60636754774D'),(4832,'d','输出：NullPointerException ','EF97015C5FF4418DBF4C60636754774D'),(4833,'a','编译错误 ','CB9A2970FDEC4B3DB457B7DD10E217E5'),(4834,'b','抛出运行时异常 ','CB9A2970FDEC4B3DB457B7DD10E217E5'),(4835,'c','输出：bar ','CB9A2970FDEC4B3DB457B7DD10E217E5'),(4836,'d','代码正常运行，但是无输出 ','CB9A2970FDEC4B3DB457B7DD10E217E5'),(4837,'a','编译错误 ','D3894E7D8A2946B693456DAA0C3C20D6'),(4838,'b','抛出运行时异常 ','D3894E7D8A2946B693456DAA0C3C20D6'),(4839,'c','输出：bar ','D3894E7D8A2946B693456DAA0C3C20D6'),(4840,'d','代码正常运行，但是无输出 ','D3894E7D8A2946B693456DAA0C3C20D6'),(4841,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','8C7A9B90249941579E5DD04FA1BB81CE'),(4842,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','8C7A9B90249941579E5DD04FA1BB81CE'),(4843,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','8C7A9B90249941579E5DD04FA1BB81CE'),(4844,'d','new InputStreamReader(\"dat\") ; ','8C7A9B90249941579E5DD04FA1BB81CE'),(4845,'a','第3行抛出异常 ','221F3BC52966430F8EADA646C3655437'),(4846,'b','第1行抛出异常 ','221F3BC52966430F8EADA646C3655437'),(4847,'c','第5行抛出异常 ','221F3BC52966430F8EADA646C3655437'),(4848,'d','第3行代码成功执行 ','221F3BC52966430F8EADA646C3655437'),(4849,'a','long 1 = 4990  ','56BD5CEF222246169FF1BD500FF1663D'),(4850,'b','int i = 4L  ','56BD5CEF222246169FF1BD500FF1663D'),(4851,'c','float f =1.1  ','56BD5CEF222246169FF1BD500FF1663D'),(4852,'d','double d = 34.4','56BD5CEF222246169FF1BD500FF1663D'),(4853,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','976867BEC19E4ED1B01104CCCA6C021A'),(4854,'b','垃圾收集将检查并释放不在使用的内存  ','976867BEC19E4ED1B01104CCCA6C021A'),(4855,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','976867BEC19E4ED1B01104CCCA6C021A'),(4856,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','976867BEC19E4ED1B01104CCCA6C021A'),(4857,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','73A0A1A36EF544889F7D0FAE6B1303C6'),(4858,'b','垃圾收集将检查并释放不在使用的内存  ','73A0A1A36EF544889F7D0FAE6B1303C6'),(4859,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','73A0A1A36EF544889F7D0FAE6B1303C6'),(4860,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','73A0A1A36EF544889F7D0FAE6B1303C6'),(4861,'a','编译错误 ','1A8AD3DD69614D70A8828207DC42A4A3'),(4862,'b','程序可以通过编译，运行后文件company.txt没有任何改变','1A8AD3DD69614D70A8828207DC42A4A3'),(4863,'c','程序可以通过编译，运行后文件company.txt的长度变为0','1A8AD3DD69614D70A8828207DC42A4A3'),(4864,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','1A8AD3DD69614D70A8828207DC42A4A3'),(4865,'a','编译错误 ','F55B96C279084E78BE760C277A7C277C'),(4866,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F55B96C279084E78BE760C277A7C277C'),(4867,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F55B96C279084E78BE760C277A7C277C'),(4868,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F55B96C279084E78BE760C277A7C277C'),(4869,'a','输出Exception ','729421F8CA9343018D5E1ECB53AE7CEB'),(4870,'b','输出A,B,Exception ','729421F8CA9343018D5E1ECB53AE7CEB'),(4871,'c','编译失败 ','729421F8CA9343018D5E1ECB53AE7CEB'),(4872,'d','在运行时抛出NullPointerException异常 ','729421F8CA9343018D5E1ECB53AE7CEB'),(4873,'a','编译错误 ','4A7E5B92AA2B48259664DBA8DC424C96'),(4874,'b','实现向文件record.dat追加写入字符a ','4A7E5B92AA2B48259664DBA8DC424C96'),(4875,'c','实现向文件record.dat覆盖写入字符a ','4A7E5B92AA2B48259664DBA8DC424C96'),(4876,'d','文件record.dat无任何内容 ','4A7E5B92AA2B48259664DBA8DC424C96'),(4877,'a','名为dtThread的线程为守护线程 ','A1C803209B8546C1A33B31943018ED7C'),(4878,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','A1C803209B8546C1A33B31943018ED7C'),(4879,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','A1C803209B8546C1A33B31943018ED7C'),(4880,'d','main线程是守护线程 ','A1C803209B8546C1A33B31943018ED7C'),(4881,'a','start()    ','012BACAA617C40A2A4517011CEB40162'),(4882,'b','init()    ','012BACAA617C40A2A4517011CEB40162'),(4883,'c','run()    ','012BACAA617C40A2A4517011CEB40162'),(4884,'d','main()  ','012BACAA617C40A2A4517011CEB40162'),(4885,'a','编译错误 ','3DFBBBFF5CFD4E199A30E323001804D8'),(4886,'b','抛出运行时异常 ','3DFBBBFF5CFD4E199A30E323001804D8'),(4887,'c','输出：bar ','3DFBBBFF5CFD4E199A30E323001804D8'),(4888,'d','代码正常运行，但是无输出 ','3DFBBBFF5CFD4E199A30E323001804D8'),(4889,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','D53236B8A89043B7AD78EBED3EDF7082'),(4890,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','D53236B8A89043B7AD78EBED3EDF7082'),(4891,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','D53236B8A89043B7AD78EBED3EDF7082'),(4892,'d','new InputStreamReader(\"1.dat\") ; ','D53236B8A89043B7AD78EBED3EDF7082'),(4893,'a','名为dtThread的线程为守护线程 ','651CA25F1CC74C74BA88D50F92FCD370'),(4894,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','651CA25F1CC74C74BA88D50F92FCD370'),(4895,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','651CA25F1CC74C74BA88D50F92FCD370'),(4896,'d','main线程是守护线程 ','651CA25F1CC74C74BA88D50F92FCD370'),(4897,'a','通过调用stop()方法而停止的线程。 ','7B09CBC415AA4D048D3E843210CDA105'),(4898,'b','通过调用sleep()方法而停止的线程。 ','7B09CBC415AA4D048D3E843210CDA105'),(4899,'c','通过调用wait()方法而停止的线程。 ','7B09CBC415AA4D048D3E843210CDA105'),(4900,'d','通过调用suspend()方法而停止的线程。 ','7B09CBC415AA4D048D3E843210CDA105'),(4901,'a','Output is null.             ','8AACE908A00A4802B59C6B36BB9337A5'),(4902,'b','Output is 0 ','8AACE908A00A4802B59C6B36BB9337A5'),(4903,'c','编译时报错 ','8AACE908A00A4802B59C6B36BB9337A5'),(4904,'d','运行时报错','8AACE908A00A4802B59C6B36BB9337A5'),(4905,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','698FA9F0F43F434094BA4681A58667ED'),(4906,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','698FA9F0F43F434094BA4681A58667ED'),(4907,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','698FA9F0F43F434094BA4681A58667ED'),(4908,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','698FA9F0F43F434094BA4681A58667ED'),(4909,'a','一旦一个线程被创建，它就立即开始运行。  ','B3D28145006843BC8660825F4EFDC0FD'),(4910,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','B3D28145006843BC8660825F4EFDC0FD'),(4911,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','B3D28145006843BC8660825F4EFDC0FD'),(4912,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','B3D28145006843BC8660825F4EFDC0FD'),(4913,'a','const   ','E7812629EC4C4DAE879ED824F4582BC6'),(4914,'b','NULL  ','E7812629EC4C4DAE879ED824F4582BC6'),(4915,'c','false   ','E7812629EC4C4DAE879ED824F4582BC6'),(4916,'d','this  ','E7812629EC4C4DAE879ED824F4582BC6'),(4917,'a','Output is null.             ','8403CD89494B4B51A66E35F0949DFC51'),(4918,'b','Output is 0 ','8403CD89494B4B51A66E35F0949DFC51'),(4919,'c','编译时报错 ','8403CD89494B4B51A66E35F0949DFC51'),(4920,'d','运行时报错','8403CD89494B4B51A66E35F0949DFC51'),(4921,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','EB10B321FAE0463494F8B91973F66BFC'),(4922,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','EB10B321FAE0463494F8B91973F66BFC'),(4923,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','EB10B321FAE0463494F8B91973F66BFC'),(4924,'d','new InputStreamReader(\"dat\") ; ','EB10B321FAE0463494F8B91973F66BFC'),(4925,'a','编译错误 ','06B62452BFDA488F8277E2377225094E'),(4926,'b','实现向文件record.dat追加写入字符a ','06B62452BFDA488F8277E2377225094E'),(4927,'c','实现向文件record.dat覆盖写入字符a ','06B62452BFDA488F8277E2377225094E'),(4928,'d','文件record.dat无任何内容 ','06B62452BFDA488F8277E2377225094E'),(4929,'a','栈是非线性结构        ','7689021DD2A24554B3BAC8AA4953DED4'),(4930,'b','栈是一种树状结构 ','7689021DD2A24554B3BAC8AA4953DED4'),(4931,'c','栈具有先进先出的特征  ','7689021DD2A24554B3BAC8AA4953DED4'),(4932,'d','栈具有后进先出的特征 ','7689021DD2A24554B3BAC8AA4953DED4'),(4933,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','2820C6BC8B3F424FB97315663FD8C1A5'),(4934,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','2820C6BC8B3F424FB97315663FD8C1A5'),(4935,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','2820C6BC8B3F424FB97315663FD8C1A5'),(4936,'d','new InputStreamReader(\"1.dat\") ; ','2820C6BC8B3F424FB97315663FD8C1A5'),(4937,'a','private synchronized Object o; ','ABCE4CAA7ED044F590B67CA7844D4FEA'),(4938,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','ABCE4CAA7ED044F590B67CA7844D4FEA'),(4939,'c','public synchronized void go() { /* code here */ } ','ABCE4CAA7ED044F590B67CA7844D4FEA'),(4940,'d','private synchronized(this) void go() { /* code here */ } ','ABCE4CAA7ED044F590B67CA7844D4FEA'),(4941,'a','public void method( int m){...}     ','294E033CD952474D9A32D06EF34617D3'),(4942,'b','public int method(){...} ','294E033CD952474D9A32D06EF34617D3'),(4943,'c','public void method2(){...}    ','294E033CD952474D9A32D06EF34617D3'),(4944,'d','public int method(int m，float f ){...} ','294E033CD952474D9A32D06EF34617D3'),(4945,'a','栈是非线性结构        ','5D6D0FD2CB5A455F8C76A0A11532CF66'),(4946,'b','栈是一种树状结构 ','5D6D0FD2CB5A455F8C76A0A11532CF66'),(4947,'c','栈具有先进先出的特征  ','5D6D0FD2CB5A455F8C76A0A11532CF66'),(4948,'d','栈具有后进先出的特征 ','5D6D0FD2CB5A455F8C76A0A11532CF66'),(4949,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','897BD3412267477AB1935B5DD3F4DFCA'),(4950,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','897BD3412267477AB1935B5DD3F4DFCA'),(4951,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','897BD3412267477AB1935B5DD3F4DFCA'),(4952,'d','new InputStreamReader(\"dat\") ; ','897BD3412267477AB1935B5DD3F4DFCA'),(4953,'a','输出：test ','7A07815398B14618990E1043254B8682'),(4954,'b','输出：Exception ','7A07815398B14618990E1043254B8682'),(4955,'c','编译失败 ','7A07815398B14618990E1043254B8682'),(4956,'d','输出：NullPointerException ','7A07815398B14618990E1043254B8682'),(4957,'a','5.0','3D408F5678ED46029E6D7AD970BB6F76'),(4958,'b','4.0','3D408F5678ED46029E6D7AD970BB6F76'),(4959,'c','6.0','3D408F5678ED46029E6D7AD970BB6F76'),(4960,'d','finished','3D408F5678ED46029E6D7AD970BB6F76'),(4961,'a','编译错误 ','583614F7F5E24075950DFF8D840677A7'),(4962,'b','抛出运行时异常 ','583614F7F5E24075950DFF8D840677A7'),(4963,'c','输出：sleep ','583614F7F5E24075950DFF8D840677A7'),(4964,'d','代码正常运行，但是无输出 ','583614F7F5E24075950DFF8D840677A7'),(4965,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','10F9B5A04C0C4511B15ACF8EE633E7EF'),(4966,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','10F9B5A04C0C4511B15ACF8EE633E7EF'),(4967,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','10F9B5A04C0C4511B15ACF8EE633E7EF'),(4968,'d','new InputStreamReader(\"dat\") ; ','10F9B5A04C0C4511B15ACF8EE633E7EF'),(4969,'a','编译错误 ','ED392F1DB8AF42629A1AC48B77852BA4'),(4970,'b','抛出运行时异常 ','ED392F1DB8AF42629A1AC48B77852BA4'),(4971,'c','输出：sleep ','ED392F1DB8AF42629A1AC48B77852BA4'),(4972,'d','代码正常运行，但是无输出 ','ED392F1DB8AF42629A1AC48B77852BA4'),(4973,'a','start()    ','D2094108BBD742918B7192DFE388C362'),(4974,'b','init()    ','D2094108BBD742918B7192DFE388C362'),(4975,'c','run()    ','D2094108BBD742918B7192DFE388C362'),(4976,'d','main()  ','D2094108BBD742918B7192DFE388C362'),(4977,'a','const   ','CA06ADDDE87149E589A31571DDAACE58'),(4978,'b','NULL  ','CA06ADDDE87149E589A31571DDAACE58'),(4979,'c','false   ','CA06ADDDE87149E589A31571DDAACE58'),(4980,'d','this  ','CA06ADDDE87149E589A31571DDAACE58'),(4981,'a','const   ','A0165EE57DC146FFB022C4842AF19FD7'),(4982,'b','NULL  ','A0165EE57DC146FFB022C4842AF19FD7'),(4983,'c','false   ','A0165EE57DC146FFB022C4842AF19FD7'),(4984,'d','this  ','A0165EE57DC146FFB022C4842AF19FD7'),(4985,'a','输出：4 ','C7FE7511D00141BD92F7EEF608D2540E'),(4986,'b','在运行时抛出NullPointerException异常 ','C7FE7511D00141BD92F7EEF608D2540E'),(4987,'c','在运行时抛出NumberFormatException异常 ','C7FE7511D00141BD92F7EEF608D2540E'),(4988,'d','在运行时抛出IllegalStateException异常 ','C7FE7511D00141BD92F7EEF608D2540E'),(4989,'a','编译错误 ','443E423B23044DC79F1E5F9129931BBA'),(4990,'b','程序可以通过编译，运行后文件company.txt没有任何改变','443E423B23044DC79F1E5F9129931BBA'),(4991,'c','程序可以通过编译，运行后文件company.txt的长度变为0','443E423B23044DC79F1E5F9129931BBA'),(4992,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','443E423B23044DC79F1E5F9129931BBA'),(4993,'a','一旦一个线程被创建，它就立即开始运行。  ','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(4994,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(4995,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(4996,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','34FC7A14DE6E4BD890BC2ECFC8CB1849'),(4997,'a','Output is null.             ','5642346732C54350A6709F11A6877E04'),(4998,'b','Output is 0 ','5642346732C54350A6709F11A6877E04'),(4999,'c','编译时报错 ','5642346732C54350A6709F11A6877E04'),(5000,'d','运行时报错','5642346732C54350A6709F11A6877E04'),(5001,'a','输出：4 ','7B896485FF384634BCF54E74AAB236F3'),(5002,'b','在运行时抛出NullPointerException异常 ','7B896485FF384634BCF54E74AAB236F3'),(5003,'c','在运行时抛出NumberFormatException异常 ','7B896485FF384634BCF54E74AAB236F3'),(5004,'d','在运行时抛出IllegalStateException异常 ','7B896485FF384634BCF54E74AAB236F3'),(5005,'a','编译错误 ','F926C0ECC64F43C4AA43CC5686AD96AB'),(5006,'b','实现向文件record.dat追加写入字符a ','F926C0ECC64F43C4AA43CC5686AD96AB'),(5007,'c','实现向文件record.dat覆盖写入字符a ','F926C0ECC64F43C4AA43CC5686AD96AB'),(5008,'d','文件record.dat无任何内容 ','F926C0ECC64F43C4AA43CC5686AD96AB'),(5009,'a','5.0','56B14E4D8D754A16923B7B38661874E7'),(5010,'b','4.0','56B14E4D8D754A16923B7B38661874E7'),(5011,'c','6.0','56B14E4D8D754A16923B7B38661874E7'),(5012,'d','finished','56B14E4D8D754A16923B7B38661874E7'),(5013,'a','private synchronized Object o; ','4ED97386374A4CB399BAE75B3B7F04A5'),(5014,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','4ED97386374A4CB399BAE75B3B7F04A5'),(5015,'c','public synchronized void go() { /* code here */ } ','4ED97386374A4CB399BAE75B3B7F04A5'),(5016,'d','private synchronized(this) void go() { /* code here */ } ','4ED97386374A4CB399BAE75B3B7F04A5'),(5017,'a','栈是非线性结构        ','34A4550373814A4583565D0D27D12DA9'),(5018,'b','栈是一种树状结构 ','34A4550373814A4583565D0D27D12DA9'),(5019,'c','栈具有先进先出的特征  ','34A4550373814A4583565D0D27D12DA9'),(5020,'d','栈具有后进先出的特征 ','34A4550373814A4583565D0D27D12DA9'),(5021,'a','将private int m改为 protected int m  ','AFD5C03FAF6E461E993EF0AA6D30AFA6'),(5022,'b','将private int m改为 public int m    ','AFD5C03FAF6E461E993EF0AA6D30AFA6'),(5023,'c','将private int m改为 static int m     ','AFD5C03FAF6E461E993EF0AA6D30AFA6'),(5024,'d','将private int m改为int m ','AFD5C03FAF6E461E993EF0AA6D30AFA6'),(5025,'a','第3行抛出异常 ','FEECD17C25834D1EBE40E0AB8D27A0D1'),(5026,'b','第1行抛出异常 ','FEECD17C25834D1EBE40E0AB8D27A0D1'),(5027,'c','第5行抛出异常 ','FEECD17C25834D1EBE40E0AB8D27A0D1'),(5028,'d','第3行代码成功执行 ','FEECD17C25834D1EBE40E0AB8D27A0D1'),(5029,'a','start()    ','261E0E19DD0D4B92AD9E25A10E6EA246'),(5030,'b','init()    ','261E0E19DD0D4B92AD9E25A10E6EA246'),(5031,'c','run()    ','261E0E19DD0D4B92AD9E25A10E6EA246'),(5032,'d','main()  ','261E0E19DD0D4B92AD9E25A10E6EA246'),(5033,'a','long 1 = 4990  ','D75DC562C2F843269B5C45EB350FA3AD'),(5034,'b','int i = 4L  ','D75DC562C2F843269B5C45EB350FA3AD'),(5035,'c','float f =1.1  ','D75DC562C2F843269B5C45EB350FA3AD'),(5036,'d','double d = 34.4','D75DC562C2F843269B5C45EB350FA3AD'),(5037,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','B430246C092F424BABB7E12F228C94AD'),(5038,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','B430246C092F424BABB7E12F228C94AD'),(5039,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','B430246C092F424BABB7E12F228C94AD'),(5040,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','B430246C092F424BABB7E12F228C94AD'),(5041,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','585205C658C8488C986B6C7C0B4FB646'),(5042,'b','垃圾收集将检查并释放不在使用的内存  ','585205C658C8488C986B6C7C0B4FB646'),(5043,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','585205C658C8488C986B6C7C0B4FB646'),(5044,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','585205C658C8488C986B6C7C0B4FB646'),(5045,'a','名为dtThread的线程为守护线程 ','C34688C8BAB54B9F99110787BDD9A0CC'),(5046,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C34688C8BAB54B9F99110787BDD9A0CC'),(5047,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C34688C8BAB54B9F99110787BDD9A0CC'),(5048,'d','main线程是守护线程 ','C34688C8BAB54B9F99110787BDD9A0CC'),(5049,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','FC77DDEB56204E76A5B9003B14839238'),(5050,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','FC77DDEB56204E76A5B9003B14839238'),(5051,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','FC77DDEB56204E76A5B9003B14839238'),(5052,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','FC77DDEB56204E76A5B9003B14839238'),(5053,'a','InputStreamReader','6E1833096598439F8115640B1764BC22'),(5054,'b','BufferedReader','6E1833096598439F8115640B1764BC22'),(5055,'c','FileInputStream','6E1833096598439F8115640B1764BC22'),(5056,'d','InputStream','6E1833096598439F8115640B1764BC22'),(5057,'a','5.0','2E49CB6268D949F5A077E9250E6A8296'),(5058,'b','4.0','2E49CB6268D949F5A077E9250E6A8296'),(5059,'c','6.0','2E49CB6268D949F5A077E9250E6A8296'),(5060,'d','finished','2E49CB6268D949F5A077E9250E6A8296'),(5061,'a','输出Exception ','95F8508EB1314785809D067307E311ED'),(5062,'b','输出A,B,Exception ','95F8508EB1314785809D067307E311ED'),(5063,'c','编译失败 ','95F8508EB1314785809D067307E311ED'),(5064,'d','在运行时抛出NullPointerException异常 ','95F8508EB1314785809D067307E311ED'),(5065,'a','long 1 = 4990  ','83CD58B0C68446B19CC3E52C7191D5DB'),(5066,'b','int i = 4L  ','83CD58B0C68446B19CC3E52C7191D5DB'),(5067,'c','float f =1.1  ','83CD58B0C68446B19CC3E52C7191D5DB'),(5068,'d','double d = 34.4','83CD58B0C68446B19CC3E52C7191D5DB'),(5069,'a','输出：4 ','BA09CF4A268E46719BB1562C1071BFAC'),(5070,'b','在运行时抛出NullPointerException异常 ','BA09CF4A268E46719BB1562C1071BFAC'),(5071,'c','在运行时抛出NumberFormatException异常 ','BA09CF4A268E46719BB1562C1071BFAC'),(5072,'d','在运行时抛出IllegalStateException异常 ','BA09CF4A268E46719BB1562C1071BFAC'),(5073,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','82D854D78657472481799FA7E7C4AF6C'),(5074,'b','垃圾收集将检查并释放不在使用的内存  ','82D854D78657472481799FA7E7C4AF6C'),(5075,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','82D854D78657472481799FA7E7C4AF6C'),(5076,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','82D854D78657472481799FA7E7C4AF6C'),(5077,'a','long 1 = 4990  ','57EFE093388D41A48EEEE53F4B337170'),(5078,'b','int i = 4L  ','57EFE093388D41A48EEEE53F4B337170'),(5079,'c','float f =1.1  ','57EFE093388D41A48EEEE53F4B337170'),(5080,'d','double d = 34.4','57EFE093388D41A48EEEE53F4B337170'),(5081,'a','一旦一个线程被创建，它就立即开始运行。  ','4A04D4A64C06440B9B79FA621B91F0CF'),(5082,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','4A04D4A64C06440B9B79FA621B91F0CF'),(5083,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','4A04D4A64C06440B9B79FA621B91F0CF'),(5084,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','4A04D4A64C06440B9B79FA621B91F0CF'),(5085,'a','m.length()    ','1A26D4793DA74C28B14AD677DC2EEC36'),(5086,'b','m.length   ','1A26D4793DA74C28B14AD677DC2EEC36'),(5087,'c','m.length()+1   ','1A26D4793DA74C28B14AD677DC2EEC36'),(5088,'d','m.length-1','1A26D4793DA74C28B14AD677DC2EEC36'),(5089,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','D09CC07D43CB4D46A02088AB1F1BD8BF'),(5090,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','D09CC07D43CB4D46A02088AB1F1BD8BF'),(5091,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','D09CC07D43CB4D46A02088AB1F1BD8BF'),(5092,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','D09CC07D43CB4D46A02088AB1F1BD8BF'),(5093,'a','s>>>=3   ','4836E60430AC414E8D592776A6628EB6'),(5094,'b','s[3]= “X”  ','4836E60430AC414E8D592776A6628EB6'),(5095,'c','int i = s.length()   ','4836E60430AC414E8D592776A6628EB6'),(5096,'d','s = s + 10 ','4836E60430AC414E8D592776A6628EB6'),(5097,'a','编译错误 ','1387D86A022F454C906DBFACB326C66A'),(5098,'b','抛出运行时异常 ','1387D86A022F454C906DBFACB326C66A'),(5099,'c','输出：sleep ','1387D86A022F454C906DBFACB326C66A'),(5100,'d','代码正常运行，但是无输出 ','1387D86A022F454C906DBFACB326C66A'),(5101,'a','public void method( int m){...}     ','E8C8A99699984B05A25F923CFB885B66'),(5102,'b','public int method(){...} ','E8C8A99699984B05A25F923CFB885B66'),(5103,'c','public void method2(){...}    ','E8C8A99699984B05A25F923CFB885B66'),(5104,'d','public int method(int m，float f ){...} ','E8C8A99699984B05A25F923CFB885B66'),(5105,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','28B6C727DAB3400787950070F088466E'),(5106,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','28B6C727DAB3400787950070F088466E'),(5107,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','28B6C727DAB3400787950070F088466E'),(5108,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','28B6C727DAB3400787950070F088466E'),(5109,'a','sleep方法 ','72A22DC3F9F74DE5B18628DAF6B9F341'),(5110,'b','IO等待 ','72A22DC3F9F74DE5B18628DAF6B9F341'),(5111,'c','yield方法 ','72A22DC3F9F74DE5B18628DAF6B9F341'),(5112,'d','wait方法 ','72A22DC3F9F74DE5B18628DAF6B9F341'),(5113,'a','sleep方法 ','1495AAC7C1DD4327BA0243A778D35D8F'),(5114,'b','IO等待 ','1495AAC7C1DD4327BA0243A778D35D8F'),(5115,'c','yield方法 ','1495AAC7C1DD4327BA0243A778D35D8F'),(5116,'d','wait方法 ','1495AAC7C1DD4327BA0243A778D35D8F'),(5117,'a','将private int m改为 protected int m  ','0E9EABFC29204285B9C562A3829CCF11'),(5118,'b','将private int m改为 public int m    ','0E9EABFC29204285B9C562A3829CCF11'),(5119,'c','将private int m改为 static int m     ','0E9EABFC29204285B9C562A3829CCF11'),(5120,'d','将private int m改为int m ','0E9EABFC29204285B9C562A3829CCF11'),(5121,'a','InputStreamReader','5DF6019386464D37B91B2EC4EADE0604'),(5122,'b','BufferedReader','5DF6019386464D37B91B2EC4EADE0604'),(5123,'c','FileInputStream','5DF6019386464D37B91B2EC4EADE0604'),(5124,'d','InputStream','5DF6019386464D37B91B2EC4EADE0604'),(5125,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','E2F9BB39BD5B47D39E83A9CD402E56C3'),(5126,'b','垃圾收集将检查并释放不在使用的内存  ','E2F9BB39BD5B47D39E83A9CD402E56C3'),(5127,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','E2F9BB39BD5B47D39E83A9CD402E56C3'),(5128,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','E2F9BB39BD5B47D39E83A9CD402E56C3'),(5129,'a','sleep方法 ','6FF6706083574A9DB15B3B7C01E34881'),(5130,'b','IO等待 ','6FF6706083574A9DB15B3B7C01E34881'),(5131,'c','yield方法 ','6FF6706083574A9DB15B3B7C01E34881'),(5132,'d','wait方法 ','6FF6706083574A9DB15B3B7C01E34881'),(5133,'a','m.length()    ','6D4C6A0FE592413FA97FA276C0F115EC'),(5134,'b','m.length   ','6D4C6A0FE592413FA97FA276C0F115EC'),(5135,'c','m.length()+1   ','6D4C6A0FE592413FA97FA276C0F115EC'),(5136,'d','m.length-1','6D4C6A0FE592413FA97FA276C0F115EC'),(5137,'a','编译错误 ','01042551428C4DDDB6EEF28FA03C0265'),(5138,'b','抛出运行时异常 ','01042551428C4DDDB6EEF28FA03C0265'),(5139,'c','输出：bar ','01042551428C4DDDB6EEF28FA03C0265'),(5140,'d','代码正常运行，但是无输出 ','01042551428C4DDDB6EEF28FA03C0265'),(5141,'a','m.length()    ','AF09572A8BAA4C18BC025531D80D273E'),(5142,'b','m.length   ','AF09572A8BAA4C18BC025531D80D273E'),(5143,'c','m.length()+1   ','AF09572A8BAA4C18BC025531D80D273E'),(5144,'d','m.length-1','AF09572A8BAA4C18BC025531D80D273E'),(5145,'a','输出Exception ','A26F14ABB5124E538467296224508BE5'),(5146,'b','输出A,B,Exception ','A26F14ABB5124E538467296224508BE5'),(5147,'c','编译失败 ','A26F14ABB5124E538467296224508BE5'),(5148,'d','在运行时抛出NullPointerException异常 ','A26F14ABB5124E538467296224508BE5'),(5149,'a','编译错误 ','0925C1723A33472F91223278E8B86B05'),(5150,'b','实现向文件record.dat追加写入字符a ','0925C1723A33472F91223278E8B86B05'),(5151,'c','实现向文件record.dat覆盖写入字符a ','0925C1723A33472F91223278E8B86B05'),(5152,'d','文件record.dat无任何内容 ','0925C1723A33472F91223278E8B86B05'),(5153,'a','第3行抛出异常 ','94169FE7526547CBA0CFD18D8C5F0841'),(5154,'b','第1行抛出异常 ','94169FE7526547CBA0CFD18D8C5F0841'),(5155,'c','第5行抛出异常 ','94169FE7526547CBA0CFD18D8C5F0841'),(5156,'d','第3行代码成功执行 ','94169FE7526547CBA0CFD18D8C5F0841'),(5157,'a','第3行抛出异常 ','2248D33C794B45459FCEF31A441DECD3'),(5158,'b','第1行抛出异常 ','2248D33C794B45459FCEF31A441DECD3'),(5159,'c','第5行抛出异常 ','2248D33C794B45459FCEF31A441DECD3'),(5160,'d','第3行代码成功执行 ','2248D33C794B45459FCEF31A441DECD3'),(5161,'a','编译错误 ','8BE9C72252AD42CF9FB5D07A1FA88788'),(5162,'b','程序可以通过编译，运行后文件company.txt没有任何改变','8BE9C72252AD42CF9FB5D07A1FA88788'),(5163,'c','程序可以通过编译，运行后文件company.txt的长度变为0','8BE9C72252AD42CF9FB5D07A1FA88788'),(5164,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','8BE9C72252AD42CF9FB5D07A1FA88788'),(5165,'a','编译错误 ','04CA32B16C3F4074A078E704BE185388'),(5166,'b','程序可以通过编译，运行后文件company.txt没有任何改变','04CA32B16C3F4074A078E704BE185388'),(5167,'c','程序可以通过编译，运行后文件company.txt的长度变为0','04CA32B16C3F4074A078E704BE185388'),(5168,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','04CA32B16C3F4074A078E704BE185388'),(5169,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0202B878BE8347B2811E18F7C5596545'),(5170,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0202B878BE8347B2811E18F7C5596545'),(5171,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0202B878BE8347B2811E18F7C5596545'),(5172,'d','new InputStreamReader(\"1.dat\") ; ','0202B878BE8347B2811E18F7C5596545'),(5173,'a','通过调用stop()方法而停止的线程。 ','087E23C1034B45FEBF489BD434B07054'),(5174,'b','通过调用sleep()方法而停止的线程。 ','087E23C1034B45FEBF489BD434B07054'),(5175,'c','通过调用wait()方法而停止的线程。 ','087E23C1034B45FEBF489BD434B07054'),(5176,'d','通过调用suspend()方法而停止的线程。 ','087E23C1034B45FEBF489BD434B07054'),(5177,'a','编译错误 ','506F8FA7123841098B8FDCC2FE8FE00E'),(5178,'b','实现向文件record.dat追加写入字符a ','506F8FA7123841098B8FDCC2FE8FE00E'),(5179,'c','实现向文件record.dat覆盖写入字符a ','506F8FA7123841098B8FDCC2FE8FE00E'),(5180,'d','文件record.dat无任何内容 ','506F8FA7123841098B8FDCC2FE8FE00E'),(5181,'a','输出Exception ','B00059FA439C476BABB293289CA95AFC'),(5182,'b','输出A,B,Exception ','B00059FA439C476BABB293289CA95AFC'),(5183,'c','编译失败 ','B00059FA439C476BABB293289CA95AFC'),(5184,'d','在运行时抛出NullPointerException异常 ','B00059FA439C476BABB293289CA95AFC'),(5185,'a','s>>>=3   ','558F1A8771AE4633A142D8850103D03F'),(5186,'b','s[3]= “X”  ','558F1A8771AE4633A142D8850103D03F'),(5187,'c','int i = s.length()   ','558F1A8771AE4633A142D8850103D03F'),(5188,'d','s = s + 10 ','558F1A8771AE4633A142D8850103D03F'),(5189,'a','private synchronized Object o; ','CACAFE264F0643D9B6E99D0ED77070DA'),(5190,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','CACAFE264F0643D9B6E99D0ED77070DA'),(5191,'c','public synchronized void go() { /* code here */ } ','CACAFE264F0643D9B6E99D0ED77070DA'),(5192,'d','private synchronized(this) void go() { /* code here */ } ','CACAFE264F0643D9B6E99D0ED77070DA'),(5193,'a','编译错误 ','C35CCB1EC4BA43A4AD7157257EC0DED5'),(5194,'b','抛出运行时异常 ','C35CCB1EC4BA43A4AD7157257EC0DED5'),(5195,'c','输出：bar ','C35CCB1EC4BA43A4AD7157257EC0DED5'),(5196,'d','代码正常运行，但是无输出 ','C35CCB1EC4BA43A4AD7157257EC0DED5'),(5197,'a','5.0','6F94F5D84BA24BAC96DD876A3849723A'),(5198,'b','4.0','6F94F5D84BA24BAC96DD876A3849723A'),(5199,'c','6.0','6F94F5D84BA24BAC96DD876A3849723A'),(5200,'d','finished','6F94F5D84BA24BAC96DD876A3849723A'),(5201,'a','public void method( int m){...}     ','F82D40C9241943A4A641B2F79FD305B2'),(5202,'b','public int method(){...} ','F82D40C9241943A4A641B2F79FD305B2'),(5203,'c','public void method2(){...}    ','F82D40C9241943A4A641B2F79FD305B2'),(5204,'d','public int method(int m，float f ){...} ','F82D40C9241943A4A641B2F79FD305B2'),(5205,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','374D4F7CDC744C4D90CE84744B3567B5'),(5206,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','374D4F7CDC744C4D90CE84744B3567B5'),(5207,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','374D4F7CDC744C4D90CE84744B3567B5'),(5208,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','374D4F7CDC744C4D90CE84744B3567B5'),(5209,'a','将private int m改为 protected int m  ','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(5210,'b','将private int m改为 public int m    ','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(5211,'c','将private int m改为 static int m     ','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(5212,'d','将private int m改为int m ','C07A1EAE35EC4A7E95A3C5FD69A7ADE0'),(5213,'a','栈是非线性结构        ','B1F4913EE82648BBA0787DD3C482182D'),(5214,'b','栈是一种树状结构 ','B1F4913EE82648BBA0787DD3C482182D'),(5215,'c','栈具有先进先出的特征  ','B1F4913EE82648BBA0787DD3C482182D'),(5216,'d','栈具有后进先出的特征 ','B1F4913EE82648BBA0787DD3C482182D'),(5217,'a','start()    ','D5A0908485B749ECA806CA6349688D71'),(5218,'b','init()    ','D5A0908485B749ECA806CA6349688D71'),(5219,'c','run()    ','D5A0908485B749ECA806CA6349688D71'),(5220,'d','main()  ','D5A0908485B749ECA806CA6349688D71'),(5221,'a','private synchronized Object o; ','1A3C99581202446399CD4D2957E435FF'),(5222,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','1A3C99581202446399CD4D2957E435FF'),(5223,'c','public synchronized void go() { /* code here */ } ','1A3C99581202446399CD4D2957E435FF'),(5224,'d','private synchronized(this) void go() { /* code here */ } ','1A3C99581202446399CD4D2957E435FF'),(5225,'a','输出Exception ','7DE0E15458D34E5A94E38537AAAF592A'),(5226,'b','输出A,B,Exception ','7DE0E15458D34E5A94E38537AAAF592A'),(5227,'c','编译失败 ','7DE0E15458D34E5A94E38537AAAF592A'),(5228,'d','在运行时抛出NullPointerException异常 ','7DE0E15458D34E5A94E38537AAAF592A'),(5229,'a','将private int m改为 protected int m  ','19C81852939949A5A45CCEFB5D8EFEED'),(5230,'b','将private int m改为 public int m    ','19C81852939949A5A45CCEFB5D8EFEED'),(5231,'c','将private int m改为 static int m     ','19C81852939949A5A45CCEFB5D8EFEED'),(5232,'d','将private int m改为int m ','19C81852939949A5A45CCEFB5D8EFEED'),(5233,'a','long 1 = 4990  ','3A37AC4828F14215A0196E91E7D39A48'),(5234,'b','int i = 4L  ','3A37AC4828F14215A0196E91E7D39A48'),(5235,'c','float f =1.1  ','3A37AC4828F14215A0196E91E7D39A48'),(5236,'d','double d = 34.4','3A37AC4828F14215A0196E91E7D39A48'),(5237,'a','通过调用stop()方法而停止的线程。 ','BC1E11BE74D645639232359365B6E158'),(5238,'b','通过调用sleep()方法而停止的线程。 ','BC1E11BE74D645639232359365B6E158'),(5239,'c','通过调用wait()方法而停止的线程。 ','BC1E11BE74D645639232359365B6E158'),(5240,'d','通过调用suspend()方法而停止的线程。 ','BC1E11BE74D645639232359365B6E158'),(5241,'a','Output is null.             ','FF47D51182DB4DA09F0E83566DC0E918'),(5242,'b','Output is 0 ','FF47D51182DB4DA09F0E83566DC0E918'),(5243,'c','编译时报错 ','FF47D51182DB4DA09F0E83566DC0E918'),(5244,'d','运行时报错','FF47D51182DB4DA09F0E83566DC0E918'),(5245,'a','一旦一个线程被创建，它就立即开始运行。  ','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(5246,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(5247,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(5248,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','1CBE1B9E5B304E1E96A2AE19AB8986C1'),(5249,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','68020EC47CAD48DFB7E609CD38B9E169'),(5250,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','68020EC47CAD48DFB7E609CD38B9E169'),(5251,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','68020EC47CAD48DFB7E609CD38B9E169'),(5252,'d','new InputStreamReader(\"1.dat\") ; ','68020EC47CAD48DFB7E609CD38B9E169'),(5253,'a','第3行抛出异常 ','493537BAD3CB4F5B942B5813F5B181BE'),(5254,'b','第1行抛出异常 ','493537BAD3CB4F5B942B5813F5B181BE'),(5255,'c','第5行抛出异常 ','493537BAD3CB4F5B942B5813F5B181BE'),(5256,'d','第3行代码成功执行 ','493537BAD3CB4F5B942B5813F5B181BE'),(5257,'a','Output is null.             ','D7131517D818414FA7A4C2AE1993D434'),(5258,'b','Output is 0 ','D7131517D818414FA7A4C2AE1993D434'),(5259,'c','编译时报错 ','D7131517D818414FA7A4C2AE1993D434'),(5260,'d','运行时报错','D7131517D818414FA7A4C2AE1993D434'),(5261,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','D4E1CE0317934DDAA243CDC34E772950'),(5262,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','D4E1CE0317934DDAA243CDC34E772950'),(5263,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','D4E1CE0317934DDAA243CDC34E772950'),(5264,'d','new InputStreamReader(\"dat\") ; ','D4E1CE0317934DDAA243CDC34E772950'),(5265,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','26F585B875EC42F2B59C6ACFEC9B3BFB'),(5266,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','26F585B875EC42F2B59C6ACFEC9B3BFB'),(5267,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','26F585B875EC42F2B59C6ACFEC9B3BFB'),(5268,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','26F585B875EC42F2B59C6ACFEC9B3BFB'),(5269,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','D7BD79657ADD434C98CA8D245C2031DE'),(5270,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','D7BD79657ADD434C98CA8D245C2031DE'),(5271,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','D7BD79657ADD434C98CA8D245C2031DE'),(5272,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','D7BD79657ADD434C98CA8D245C2031DE'),(5273,'a','const   ','3B3296C71C7A43C497E6FD21EA862F38'),(5274,'b','NULL  ','3B3296C71C7A43C497E6FD21EA862F38'),(5275,'c','false   ','3B3296C71C7A43C497E6FD21EA862F38'),(5276,'d','this  ','3B3296C71C7A43C497E6FD21EA862F38'),(5277,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','035E83A54A1D4068A96A9BF266B6EB1E'),(5278,'b','垃圾收集将检查并释放不在使用的内存  ','035E83A54A1D4068A96A9BF266B6EB1E'),(5279,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','035E83A54A1D4068A96A9BF266B6EB1E'),(5280,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','035E83A54A1D4068A96A9BF266B6EB1E'),(5281,'a','输出Exception ','CD719FD7E39848019EB8E25641ECFFBD'),(5282,'b','输出A,B,Exception ','CD719FD7E39848019EB8E25641ECFFBD'),(5283,'c','编译失败 ','CD719FD7E39848019EB8E25641ECFFBD'),(5284,'d','在运行时抛出NullPointerException异常 ','CD719FD7E39848019EB8E25641ECFFBD'),(5285,'a','名为dtThread的线程为守护线程 ','7F08D3C1323143E88C769FB49574361C'),(5286,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','7F08D3C1323143E88C769FB49574361C'),(5287,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','7F08D3C1323143E88C769FB49574361C'),(5288,'d','main线程是守护线程 ','7F08D3C1323143E88C769FB49574361C'),(5289,'a','编译错误 ','075C9025AE5B4D998414DFFEC663F5A1'),(5290,'b','抛出运行时异常 ','075C9025AE5B4D998414DFFEC663F5A1'),(5291,'c','输出：bar ','075C9025AE5B4D998414DFFEC663F5A1'),(5292,'d','代码正常运行，但是无输出 ','075C9025AE5B4D998414DFFEC663F5A1'),(5293,'a','Output is null.             ','F2547990B70E47D3A8331AF838FB71A4'),(5294,'b','Output is 0 ','F2547990B70E47D3A8331AF838FB71A4'),(5295,'c','编译时报错 ','F2547990B70E47D3A8331AF838FB71A4'),(5296,'d','运行时报错','F2547990B70E47D3A8331AF838FB71A4'),(5297,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','AB5DBF5978DF43A1BEB13239407A5D16'),(5298,'b','垃圾收集将检查并释放不在使用的内存  ','AB5DBF5978DF43A1BEB13239407A5D16'),(5299,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','AB5DBF5978DF43A1BEB13239407A5D16'),(5300,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','AB5DBF5978DF43A1BEB13239407A5D16'),(5301,'a','s>>>=3   ','A2CB6CD3363643F8A9DF27F8887991CC'),(5302,'b','s[3]= “X”  ','A2CB6CD3363643F8A9DF27F8887991CC'),(5303,'c','int i = s.length()   ','A2CB6CD3363643F8A9DF27F8887991CC'),(5304,'d','s = s + 10 ','A2CB6CD3363643F8A9DF27F8887991CC'),(5305,'a','m.length()    ','E55BF76712E1438A9FAB1BAC7B0ED7C7'),(5306,'b','m.length   ','E55BF76712E1438A9FAB1BAC7B0ED7C7'),(5307,'c','m.length()+1   ','E55BF76712E1438A9FAB1BAC7B0ED7C7'),(5308,'d','m.length-1','E55BF76712E1438A9FAB1BAC7B0ED7C7'),(5309,'a','输出Exception ','DCF07752DC654BE49752599D5F308BCD'),(5310,'b','输出A,B,Exception ','DCF07752DC654BE49752599D5F308BCD'),(5311,'c','编译失败 ','DCF07752DC654BE49752599D5F308BCD'),(5312,'d','在运行时抛出NullPointerException异常 ','DCF07752DC654BE49752599D5F308BCD'),(5313,'a','编译错误 ','ABAEAD1EE0BA46BC86A2BE85F5800C47'),(5314,'b','实现向文件record.dat追加写入字符a ','ABAEAD1EE0BA46BC86A2BE85F5800C47'),(5315,'c','实现向文件record.dat覆盖写入字符a ','ABAEAD1EE0BA46BC86A2BE85F5800C47'),(5316,'d','文件record.dat无任何内容 ','ABAEAD1EE0BA46BC86A2BE85F5800C47'),(5317,'a','输出：4 ','BC80BD86538641309E6AA25A867B22F1'),(5318,'b','在运行时抛出NullPointerException异常 ','BC80BD86538641309E6AA25A867B22F1'),(5319,'c','在运行时抛出NumberFormatException异常 ','BC80BD86538641309E6AA25A867B22F1'),(5320,'d','在运行时抛出IllegalStateException异常 ','BC80BD86538641309E6AA25A867B22F1'),(5321,'a','5.0','D1E215794BBF46F28A0C37B9D3936242'),(5322,'b','4.0','D1E215794BBF46F28A0C37B9D3936242'),(5323,'c','6.0','D1E215794BBF46F28A0C37B9D3936242'),(5324,'d','finished','D1E215794BBF46F28A0C37B9D3936242'),(5325,'a','输出：4 ','F7317260A183428BA88C3E40C88180D8'),(5326,'b','在运行时抛出NullPointerException异常 ','F7317260A183428BA88C3E40C88180D8'),(5327,'c','在运行时抛出NumberFormatException异常 ','F7317260A183428BA88C3E40C88180D8'),(5328,'d','在运行时抛出IllegalStateException异常 ','F7317260A183428BA88C3E40C88180D8'),(5329,'a','sleep方法 ','85E8B6F7914F4BCE8533F5A58F74684B'),(5330,'b','IO等待 ','85E8B6F7914F4BCE8533F5A58F74684B'),(5331,'c','yield方法 ','85E8B6F7914F4BCE8533F5A58F74684B'),(5332,'d','wait方法 ','85E8B6F7914F4BCE8533F5A58F74684B'),(5333,'a','编译错误 ','6CE2540FA0FF437696713F7EA11C1A6A'),(5334,'b','实现向文件record.dat追加写入字符a ','6CE2540FA0FF437696713F7EA11C1A6A'),(5335,'c','实现向文件record.dat覆盖写入字符a ','6CE2540FA0FF437696713F7EA11C1A6A'),(5336,'d','文件record.dat无任何内容 ','6CE2540FA0FF437696713F7EA11C1A6A'),(5337,'a','s>>>=3   ','CE5C2FD456664E0F9159518082DD8484'),(5338,'b','s[3]= “X”  ','CE5C2FD456664E0F9159518082DD8484'),(5339,'c','int i = s.length()   ','CE5C2FD456664E0F9159518082DD8484'),(5340,'d','s = s + 10 ','CE5C2FD456664E0F9159518082DD8484'),(5341,'a','将private int m改为 protected int m  ','2EEF8A1EF8744402837A20A933F8EA7A'),(5342,'b','将private int m改为 public int m    ','2EEF8A1EF8744402837A20A933F8EA7A'),(5343,'c','将private int m改为 static int m     ','2EEF8A1EF8744402837A20A933F8EA7A'),(5344,'d','将private int m改为int m ','2EEF8A1EF8744402837A20A933F8EA7A'),(5345,'a','一旦一个线程被创建，它就立即开始运行。  ','E06953EB666843B8A1B4665A926F596E'),(5346,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','E06953EB666843B8A1B4665A926F596E'),(5347,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','E06953EB666843B8A1B4665A926F596E'),(5348,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','E06953EB666843B8A1B4665A926F596E'),(5349,'a','private synchronized Object o; ','19BC2D554F7A4B45BD8FF2C68BB40CDA'),(5350,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','19BC2D554F7A4B45BD8FF2C68BB40CDA'),(5351,'c','public synchronized void go() { /* code here */ } ','19BC2D554F7A4B45BD8FF2C68BB40CDA'),(5352,'d','private synchronized(this) void go() { /* code here */ } ','19BC2D554F7A4B45BD8FF2C68BB40CDA'),(5353,'a','通过调用stop()方法而停止的线程。 ','69BD435D4F7D446097303BB071AAA4E9'),(5354,'b','通过调用sleep()方法而停止的线程。 ','69BD435D4F7D446097303BB071AAA4E9'),(5355,'c','通过调用wait()方法而停止的线程。 ','69BD435D4F7D446097303BB071AAA4E9'),(5356,'d','通过调用suspend()方法而停止的线程。 ','69BD435D4F7D446097303BB071AAA4E9'),(5357,'a','编译错误 ','80F46AA531964C008FCDBAEEC9E8DCD9'),(5358,'b','程序可以通过编译，运行后文件company.txt没有任何改变','80F46AA531964C008FCDBAEEC9E8DCD9'),(5359,'c','程序可以通过编译，运行后文件company.txt的长度变为0','80F46AA531964C008FCDBAEEC9E8DCD9'),(5360,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','80F46AA531964C008FCDBAEEC9E8DCD9'),(5361,'a','输出：test ','DE5425318C5045208BB13A5234B80FDD'),(5362,'b','输出：Exception ','DE5425318C5045208BB13A5234B80FDD'),(5363,'c','编译失败 ','DE5425318C5045208BB13A5234B80FDD'),(5364,'d','输出：NullPointerException ','DE5425318C5045208BB13A5234B80FDD'),(5365,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','817049F422604226B0C4102943B7B8F5'),(5366,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','817049F422604226B0C4102943B7B8F5'),(5367,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','817049F422604226B0C4102943B7B8F5'),(5368,'d','new InputStreamReader(\"dat\") ; ','817049F422604226B0C4102943B7B8F5'),(5369,'a','5.0','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(5370,'b','4.0','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(5371,'c','6.0','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(5372,'d','finished','DCBB0AC376EE4FD3B530E6C1CDFBABFB'),(5373,'a','m.length()    ','B0CE4518E47743608AFFBE6B452176B6'),(5374,'b','m.length   ','B0CE4518E47743608AFFBE6B452176B6'),(5375,'c','m.length()+1   ','B0CE4518E47743608AFFBE6B452176B6'),(5376,'d','m.length-1','B0CE4518E47743608AFFBE6B452176B6'),(5377,'a','一旦一个线程被创建，它就立即开始运行。  ','F3D99320CB124B48B4947E01FE4ECC12'),(5378,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','F3D99320CB124B48B4947E01FE4ECC12'),(5379,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','F3D99320CB124B48B4947E01FE4ECC12'),(5380,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','F3D99320CB124B48B4947E01FE4ECC12'),(5381,'a','第3行抛出异常 ','296252C5A1BC4A4D8C816331F23A4B25'),(5382,'b','第1行抛出异常 ','296252C5A1BC4A4D8C816331F23A4B25'),(5383,'c','第5行抛出异常 ','296252C5A1BC4A4D8C816331F23A4B25'),(5384,'d','第3行代码成功执行 ','296252C5A1BC4A4D8C816331F23A4B25'),(5385,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','B177A1C773934FA5B207F8E87D81E6B5'),(5386,'b','垃圾收集将检查并释放不在使用的内存  ','B177A1C773934FA5B207F8E87D81E6B5'),(5387,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','B177A1C773934FA5B207F8E87D81E6B5'),(5388,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','B177A1C773934FA5B207F8E87D81E6B5'),(5389,'a','InputStreamReader','A96CA27F7064453F905BE81905593D6C'),(5390,'b','BufferedReader','A96CA27F7064453F905BE81905593D6C'),(5391,'c','FileInputStream','A96CA27F7064453F905BE81905593D6C'),(5392,'d','InputStream','A96CA27F7064453F905BE81905593D6C'),(5393,'a','编译错误 ','D4F5374AED9E4AA89819D39DB81BBFDE'),(5394,'b','抛出运行时异常 ','D4F5374AED9E4AA89819D39DB81BBFDE'),(5395,'c','输出：sleep ','D4F5374AED9E4AA89819D39DB81BBFDE'),(5396,'d','代码正常运行，但是无输出 ','D4F5374AED9E4AA89819D39DB81BBFDE'),(5397,'a','start()    ','8B30A274598E4C27891E28DB917E5FB0'),(5398,'b','init()    ','8B30A274598E4C27891E28DB917E5FB0'),(5399,'c','run()    ','8B30A274598E4C27891E28DB917E5FB0'),(5400,'d','main()  ','8B30A274598E4C27891E28DB917E5FB0'),(5401,'a','编译错误 ','04E829B1189A4237BEB30337CC370725'),(5402,'b','抛出运行时异常 ','04E829B1189A4237BEB30337CC370725'),(5403,'c','输出：sleep ','04E829B1189A4237BEB30337CC370725'),(5404,'d','代码正常运行，但是无输出 ','04E829B1189A4237BEB30337CC370725'),(5405,'a','编译错误 ','CBB12FB1F0C24107B58F4546E590AE28'),(5406,'b','程序可以通过编译，运行后文件company.txt没有任何改变','CBB12FB1F0C24107B58F4546E590AE28'),(5407,'c','程序可以通过编译，运行后文件company.txt的长度变为0','CBB12FB1F0C24107B58F4546E590AE28'),(5408,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','CBB12FB1F0C24107B58F4546E590AE28'),(5409,'a','编译错误 ','A0FC3A6B57C946A3BBB0E1469E42D17C'),(5410,'b','实现向文件record.dat追加写入字符a ','A0FC3A6B57C946A3BBB0E1469E42D17C'),(5411,'c','实现向文件record.dat覆盖写入字符a ','A0FC3A6B57C946A3BBB0E1469E42D17C'),(5412,'d','文件record.dat无任何内容 ','A0FC3A6B57C946A3BBB0E1469E42D17C'),(5413,'a','public void method( int m){...}     ','19A7323061AB48E0BF088E343C0C93CC'),(5414,'b','public int method(){...} ','19A7323061AB48E0BF088E343C0C93CC'),(5415,'c','public void method2(){...}    ','19A7323061AB48E0BF088E343C0C93CC'),(5416,'d','public int method(int m，float f ){...} ','19A7323061AB48E0BF088E343C0C93CC'),(5417,'a','s>>>=3   ','FAC96053479B458FBE6A152567A52F09'),(5418,'b','s[3]= “X”  ','FAC96053479B458FBE6A152567A52F09'),(5419,'c','int i = s.length()   ','FAC96053479B458FBE6A152567A52F09'),(5420,'d','s = s + 10 ','FAC96053479B458FBE6A152567A52F09'),(5421,'a','编译错误 ','C2BB7761C0234DC6B13417AB8FCBDCF1'),(5422,'b','程序可以通过编译，运行后文件company.txt没有任何改变','C2BB7761C0234DC6B13417AB8FCBDCF1'),(5423,'c','程序可以通过编译，运行后文件company.txt的长度变为0','C2BB7761C0234DC6B13417AB8FCBDCF1'),(5424,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','C2BB7761C0234DC6B13417AB8FCBDCF1'),(5425,'a','sleep方法 ','6203C30573BE454ABB2F60144A74C92E'),(5426,'b','IO等待 ','6203C30573BE454ABB2F60144A74C92E'),(5427,'c','yield方法 ','6203C30573BE454ABB2F60144A74C92E'),(5428,'d','wait方法 ','6203C30573BE454ABB2F60144A74C92E'),(5429,'a','编译错误 ','82A4BFB14D3247A19D05AA6CBE401745'),(5430,'b','实现向文件record.dat追加写入字符a ','82A4BFB14D3247A19D05AA6CBE401745'),(5431,'c','实现向文件record.dat覆盖写入字符a ','82A4BFB14D3247A19D05AA6CBE401745'),(5432,'d','文件record.dat无任何内容 ','82A4BFB14D3247A19D05AA6CBE401745'),(5433,'a','编译错误 ','7248FC8E09944933B0A43E5CFDB3FA9D'),(5434,'b','实现向文件record.dat追加写入字符a ','7248FC8E09944933B0A43E5CFDB3FA9D'),(5435,'c','实现向文件record.dat覆盖写入字符a ','7248FC8E09944933B0A43E5CFDB3FA9D'),(5436,'d','文件record.dat无任何内容 ','7248FC8E09944933B0A43E5CFDB3FA9D'),(5437,'a','编译错误 ','E2C457D841D44B499069F934506C1334'),(5438,'b','抛出运行时异常 ','E2C457D841D44B499069F934506C1334'),(5439,'c','输出：sleep ','E2C457D841D44B499069F934506C1334'),(5440,'d','代码正常运行，但是无输出 ','E2C457D841D44B499069F934506C1334'),(5441,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','5E80109810C04E04A82927858B301F59'),(5442,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','5E80109810C04E04A82927858B301F59'),(5443,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','5E80109810C04E04A82927858B301F59'),(5444,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','5E80109810C04E04A82927858B301F59'),(5445,'a','编译错误 ','61ACC3A755E24A49B5CD75DC007F4706'),(5446,'b','抛出运行时异常 ','61ACC3A755E24A49B5CD75DC007F4706'),(5447,'c','输出：bar ','61ACC3A755E24A49B5CD75DC007F4706'),(5448,'d','代码正常运行，但是无输出 ','61ACC3A755E24A49B5CD75DC007F4706'),(5449,'a','编译错误 ','262CA6B665C443ED977EA506B45378C4'),(5450,'b','抛出运行时异常 ','262CA6B665C443ED977EA506B45378C4'),(5451,'c','输出：bar ','262CA6B665C443ED977EA506B45378C4'),(5452,'d','代码正常运行，但是无输出 ','262CA6B665C443ED977EA506B45378C4'),(5453,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','248D0E879F744F14BE80586A80AB7816'),(5454,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','248D0E879F744F14BE80586A80AB7816'),(5455,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','248D0E879F744F14BE80586A80AB7816'),(5456,'d','new InputStreamReader(\"1.dat\") ; ','248D0E879F744F14BE80586A80AB7816'),(5457,'a','public void method( int m){...}     ','30A1DBE2993F47D08EB77F4043E4E3B8'),(5458,'b','public int method(){...} ','30A1DBE2993F47D08EB77F4043E4E3B8'),(5459,'c','public void method2(){...}    ','30A1DBE2993F47D08EB77F4043E4E3B8'),(5460,'d','public int method(int m，float f ){...} ','30A1DBE2993F47D08EB77F4043E4E3B8'),(5461,'a','名为dtThread的线程为守护线程 ','54542AF7631D4091B12EFE77D5CBA830'),(5462,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','54542AF7631D4091B12EFE77D5CBA830'),(5463,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','54542AF7631D4091B12EFE77D5CBA830'),(5464,'d','main线程是守护线程 ','54542AF7631D4091B12EFE77D5CBA830'),(5465,'a','long 1 = 4990  ','C072CCD1D67E4C4EA755FD7B859866E4'),(5466,'b','int i = 4L  ','C072CCD1D67E4C4EA755FD7B859866E4'),(5467,'c','float f =1.1  ','C072CCD1D67E4C4EA755FD7B859866E4'),(5468,'d','double d = 34.4','C072CCD1D67E4C4EA755FD7B859866E4'),(5469,'a','private synchronized Object o; ','40AC7C9E0EA94B9DBA1EE7B053B8D577'),(5470,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','40AC7C9E0EA94B9DBA1EE7B053B8D577'),(5471,'c','public synchronized void go() { /* code here */ } ','40AC7C9E0EA94B9DBA1EE7B053B8D577'),(5472,'d','private synchronized(this) void go() { /* code here */ } ','40AC7C9E0EA94B9DBA1EE7B053B8D577'),(5473,'a','名为dtThread的线程为守护线程 ','FE67B4B0C78147CB80BAEAB317F51039'),(5474,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','FE67B4B0C78147CB80BAEAB317F51039'),(5475,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','FE67B4B0C78147CB80BAEAB317F51039'),(5476,'d','main线程是守护线程 ','FE67B4B0C78147CB80BAEAB317F51039'),(5477,'a','InputStreamReader','D9B19D53C90245B88013FB25E4D80A2E'),(5478,'b','BufferedReader','D9B19D53C90245B88013FB25E4D80A2E'),(5479,'c','FileInputStream','D9B19D53C90245B88013FB25E4D80A2E'),(5480,'d','InputStream','D9B19D53C90245B88013FB25E4D80A2E'),(5481,'a','start()    ','8A03CE5AEA1F42C188E09A9FCA13C5F5'),(5482,'b','init()    ','8A03CE5AEA1F42C188E09A9FCA13C5F5'),(5483,'c','run()    ','8A03CE5AEA1F42C188E09A9FCA13C5F5'),(5484,'d','main()  ','8A03CE5AEA1F42C188E09A9FCA13C5F5'),(5485,'a','sleep方法 ','DD9843C56183451EB8C70C3FAE3FF4F0'),(5486,'b','IO等待 ','DD9843C56183451EB8C70C3FAE3FF4F0'),(5487,'c','yield方法 ','DD9843C56183451EB8C70C3FAE3FF4F0'),(5488,'d','wait方法 ','DD9843C56183451EB8C70C3FAE3FF4F0'),(5489,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','929F5A6FC2114769933E3E1F59A7895E'),(5490,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','929F5A6FC2114769933E3E1F59A7895E'),(5491,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','929F5A6FC2114769933E3E1F59A7895E'),(5492,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','929F5A6FC2114769933E3E1F59A7895E'),(5493,'a','long 1 = 4990  ','869C550DC2A943029172A31A836FB137'),(5494,'b','int i = 4L  ','869C550DC2A943029172A31A836FB137'),(5495,'c','float f =1.1  ','869C550DC2A943029172A31A836FB137'),(5496,'d','double d = 34.4','869C550DC2A943029172A31A836FB137'),(5497,'a','InputStreamReader','655548DA367440DF9DA3BE3BE74700A7'),(5498,'b','BufferedReader','655548DA367440DF9DA3BE3BE74700A7'),(5499,'c','FileInputStream','655548DA367440DF9DA3BE3BE74700A7'),(5500,'d','InputStream','655548DA367440DF9DA3BE3BE74700A7'),(5501,'a','const   ','3B010524C5E448B7AAE23D60DE30E34D'),(5502,'b','NULL  ','3B010524C5E448B7AAE23D60DE30E34D'),(5503,'c','false   ','3B010524C5E448B7AAE23D60DE30E34D'),(5504,'d','this  ','3B010524C5E448B7AAE23D60DE30E34D'),(5505,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','29FE99226B6F4AAABC53A72B30AEF2D5'),(5506,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','29FE99226B6F4AAABC53A72B30AEF2D5'),(5507,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','29FE99226B6F4AAABC53A72B30AEF2D5'),(5508,'d','new InputStreamReader(\"dat\") ; ','29FE99226B6F4AAABC53A72B30AEF2D5'),(5509,'a','输出：test ','0D4DDF47D69D495681AA7B8AEAA23189'),(5510,'b','输出：Exception ','0D4DDF47D69D495681AA7B8AEAA23189'),(5511,'c','编译失败 ','0D4DDF47D69D495681AA7B8AEAA23189'),(5512,'d','输出：NullPointerException ','0D4DDF47D69D495681AA7B8AEAA23189'),(5513,'a','输出：test ','89F655A2BBB743FA8690F03A2355F362'),(5514,'b','输出：Exception ','89F655A2BBB743FA8690F03A2355F362'),(5515,'c','编译失败 ','89F655A2BBB743FA8690F03A2355F362'),(5516,'d','输出：NullPointerException ','89F655A2BBB743FA8690F03A2355F362'),(5517,'a','start()    ','B8F11DD9DAC64244B577E877BEBFB5FF'),(5518,'b','init()    ','B8F11DD9DAC64244B577E877BEBFB5FF'),(5519,'c','run()    ','B8F11DD9DAC64244B577E877BEBFB5FF'),(5520,'d','main()  ','B8F11DD9DAC64244B577E877BEBFB5FF'),(5521,'a','栈是非线性结构        ','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(5522,'b','栈是一种树状结构 ','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(5523,'c','栈具有先进先出的特征  ','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(5524,'d','栈具有后进先出的特征 ','661A8B281DAA4B5A9B75BAAF27FAD0D6'),(5525,'a','s>>>=3   ','0DA6181FD23F495184AE9128881AB30D'),(5526,'b','s[3]= “X”  ','0DA6181FD23F495184AE9128881AB30D'),(5527,'c','int i = s.length()   ','0DA6181FD23F495184AE9128881AB30D'),(5528,'d','s = s + 10 ','0DA6181FD23F495184AE9128881AB30D'),(5529,'a','sleep方法 ','6911530B0B124AEAA00145929D3BBFD7'),(5530,'b','IO等待 ','6911530B0B124AEAA00145929D3BBFD7'),(5531,'c','yield方法 ','6911530B0B124AEAA00145929D3BBFD7'),(5532,'d','wait方法 ','6911530B0B124AEAA00145929D3BBFD7'),(5533,'a','m.length()    ','2A4F6DA50AE74CC7A337594A78157C01'),(5534,'b','m.length   ','2A4F6DA50AE74CC7A337594A78157C01'),(5535,'c','m.length()+1   ','2A4F6DA50AE74CC7A337594A78157C01'),(5536,'d','m.length-1','2A4F6DA50AE74CC7A337594A78157C01'),(5537,'a','InputStreamReader','B986D98802E6468485A59C0524946414'),(5538,'b','BufferedReader','B986D98802E6468485A59C0524946414'),(5539,'c','FileInputStream','B986D98802E6468485A59C0524946414'),(5540,'d','InputStream','B986D98802E6468485A59C0524946414'),(5541,'a','public void method( int m){...}     ','070536DBD34B45968D6C066D501C7D81'),(5542,'b','public int method(){...} ','070536DBD34B45968D6C066D501C7D81'),(5543,'c','public void method2(){...}    ','070536DBD34B45968D6C066D501C7D81'),(5544,'d','public int method(int m，float f ){...} ','070536DBD34B45968D6C066D501C7D81'),(5545,'a','Output is null.             ','8EFB860529714AC2AB98D0A4791354E2'),(5546,'b','Output is 0 ','8EFB860529714AC2AB98D0A4791354E2'),(5547,'c','编译时报错 ','8EFB860529714AC2AB98D0A4791354E2'),(5548,'d','运行时报错','8EFB860529714AC2AB98D0A4791354E2'),(5549,'a','编译错误 ','C8E37F55ED3B44E3B266094FE7362AA5'),(5550,'b','抛出运行时异常 ','C8E37F55ED3B44E3B266094FE7362AA5'),(5551,'c','输出：sleep ','C8E37F55ED3B44E3B266094FE7362AA5'),(5552,'d','代码正常运行，但是无输出 ','C8E37F55ED3B44E3B266094FE7362AA5'),(5553,'a','long 1 = 4990  ','4B9E29A3F0AC42038F5494CD94FDE71F'),(5554,'b','int i = 4L  ','4B9E29A3F0AC42038F5494CD94FDE71F'),(5555,'c','float f =1.1  ','4B9E29A3F0AC42038F5494CD94FDE71F'),(5556,'d','double d = 34.4','4B9E29A3F0AC42038F5494CD94FDE71F'),(5557,'a','通过调用stop()方法而停止的线程。 ','286D0E3555594C8AA239BE1606877D20'),(5558,'b','通过调用sleep()方法而停止的线程。 ','286D0E3555594C8AA239BE1606877D20'),(5559,'c','通过调用wait()方法而停止的线程。 ','286D0E3555594C8AA239BE1606877D20'),(5560,'d','通过调用suspend()方法而停止的线程。 ','286D0E3555594C8AA239BE1606877D20'),(5561,'a','InputStreamReader','5B1A8371922F4B26B6667A058ACB23BE'),(5562,'b','BufferedReader','5B1A8371922F4B26B6667A058ACB23BE'),(5563,'c','FileInputStream','5B1A8371922F4B26B6667A058ACB23BE'),(5564,'d','InputStream','5B1A8371922F4B26B6667A058ACB23BE'),(5565,'a','编译错误 ','9AFA3223D3674E9AB5794DE660951F02'),(5566,'b','程序可以通过编译，运行后文件company.txt没有任何改变','9AFA3223D3674E9AB5794DE660951F02'),(5567,'c','程序可以通过编译，运行后文件company.txt的长度变为0','9AFA3223D3674E9AB5794DE660951F02'),(5568,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','9AFA3223D3674E9AB5794DE660951F02'),(5569,'a','第3行抛出异常 ','693CE405916248D89973A458EF74B047'),(5570,'b','第1行抛出异常 ','693CE405916248D89973A458EF74B047'),(5571,'c','第5行抛出异常 ','693CE405916248D89973A458EF74B047'),(5572,'d','第3行代码成功执行 ','693CE405916248D89973A458EF74B047'),(5573,'a','第3行抛出异常 ','7696C808CF7D435A846FC77A69848D86'),(5574,'b','第1行抛出异常 ','7696C808CF7D435A846FC77A69848D86'),(5575,'c','第5行抛出异常 ','7696C808CF7D435A846FC77A69848D86'),(5576,'d','第3行代码成功执行 ','7696C808CF7D435A846FC77A69848D86'),(5577,'a','private synchronized Object o; ','A80C6B0EFD98408D905CA3B3BF89A8BB'),(5578,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','A80C6B0EFD98408D905CA3B3BF89A8BB'),(5579,'c','public synchronized void go() { /* code here */ } ','A80C6B0EFD98408D905CA3B3BF89A8BB'),(5580,'d','private synchronized(this) void go() { /* code here */ } ','A80C6B0EFD98408D905CA3B3BF89A8BB'),(5581,'a','编译错误 ','E917096B193346AB8F41C9491B4C8A17'),(5582,'b','实现向文件record.dat追加写入字符a ','E917096B193346AB8F41C9491B4C8A17'),(5583,'c','实现向文件record.dat覆盖写入字符a ','E917096B193346AB8F41C9491B4C8A17'),(5584,'d','文件record.dat无任何内容 ','E917096B193346AB8F41C9491B4C8A17'),(5585,'a','栈是非线性结构        ','1BFB46B8EBB249489CEBA93AA518F88D'),(5586,'b','栈是一种树状结构 ','1BFB46B8EBB249489CEBA93AA518F88D'),(5587,'c','栈具有先进先出的特征  ','1BFB46B8EBB249489CEBA93AA518F88D'),(5588,'d','栈具有后进先出的特征 ','1BFB46B8EBB249489CEBA93AA518F88D'),(5589,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','0640B865AC5B46CB9121C984E2D62017'),(5590,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','0640B865AC5B46CB9121C984E2D62017'),(5591,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','0640B865AC5B46CB9121C984E2D62017'),(5592,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','0640B865AC5B46CB9121C984E2D62017'),(5593,'a','编译错误 ','C29A0DE351E4496BA407B0641D1234CA'),(5594,'b','程序可以通过编译，运行后文件company.txt没有任何改变','C29A0DE351E4496BA407B0641D1234CA'),(5595,'c','程序可以通过编译，运行后文件company.txt的长度变为0','C29A0DE351E4496BA407B0641D1234CA'),(5596,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','C29A0DE351E4496BA407B0641D1234CA'),(5597,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','9138094802F2467EBB1DE62EEC2A1DB2'),(5598,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','9138094802F2467EBB1DE62EEC2A1DB2'),(5599,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','9138094802F2467EBB1DE62EEC2A1DB2'),(5600,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','9138094802F2467EBB1DE62EEC2A1DB2'),(5601,'a','输出Exception ','299E83AE459C4D658A527DF258E063AC'),(5602,'b','输出A,B,Exception ','299E83AE459C4D658A527DF258E063AC'),(5603,'c','编译失败 ','299E83AE459C4D658A527DF258E063AC'),(5604,'d','在运行时抛出NullPointerException异常 ','299E83AE459C4D658A527DF258E063AC'),(5605,'a','名为dtThread的线程为守护线程 ','6561E43E97654FABBF141C7E15F0B49F'),(5606,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','6561E43E97654FABBF141C7E15F0B49F'),(5607,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','6561E43E97654FABBF141C7E15F0B49F'),(5608,'d','main线程是守护线程 ','6561E43E97654FABBF141C7E15F0B49F'),(5609,'a','将private int m改为 protected int m  ','BDEFDAB949C24702A40106A5251ADE2B'),(5610,'b','将private int m改为 public int m    ','BDEFDAB949C24702A40106A5251ADE2B'),(5611,'c','将private int m改为 static int m     ','BDEFDAB949C24702A40106A5251ADE2B'),(5612,'d','将private int m改为int m ','BDEFDAB949C24702A40106A5251ADE2B'),(5613,'a','名为dtThread的线程为守护线程 ','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(5614,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(5615,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(5616,'d','main线程是守护线程 ','41F4EFE9801C4D90B8DE8A63E5C5F71A'),(5617,'a','编译错误 ','74ADF931B41C41428AD755CE6EBB94EA'),(5618,'b','抛出运行时异常 ','74ADF931B41C41428AD755CE6EBB94EA'),(5619,'c','输出：sleep ','74ADF931B41C41428AD755CE6EBB94EA'),(5620,'d','代码正常运行，但是无输出 ','74ADF931B41C41428AD755CE6EBB94EA'),(5621,'a','输出：4 ','8AB7AB739A124F77958C6AA2E8D0F70D'),(5622,'b','在运行时抛出NullPointerException异常 ','8AB7AB739A124F77958C6AA2E8D0F70D'),(5623,'c','在运行时抛出NumberFormatException异常 ','8AB7AB739A124F77958C6AA2E8D0F70D'),(5624,'d','在运行时抛出IllegalStateException异常 ','8AB7AB739A124F77958C6AA2E8D0F70D'),(5625,'a','private synchronized Object o; ','99A6C7CAA93549AB834FAE50C5EECF05'),(5626,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','99A6C7CAA93549AB834FAE50C5EECF05'),(5627,'c','public synchronized void go() { /* code here */ } ','99A6C7CAA93549AB834FAE50C5EECF05'),(5628,'d','private synchronized(this) void go() { /* code here */ } ','99A6C7CAA93549AB834FAE50C5EECF05'),(5629,'a','将private int m改为 protected int m  ','2ED5734A673E4C339FD0B1438DD73B76'),(5630,'b','将private int m改为 public int m    ','2ED5734A673E4C339FD0B1438DD73B76'),(5631,'c','将private int m改为 static int m     ','2ED5734A673E4C339FD0B1438DD73B76'),(5632,'d','将private int m改为int m ','2ED5734A673E4C339FD0B1438DD73B76'),(5633,'a','const   ','93FD18AB5C7C41FABD46B4F985C25C16'),(5634,'b','NULL  ','93FD18AB5C7C41FABD46B4F985C25C16'),(5635,'c','false   ','93FD18AB5C7C41FABD46B4F985C25C16'),(5636,'d','this  ','93FD18AB5C7C41FABD46B4F985C25C16'),(5637,'a','名为dtThread的线程为守护线程 ','EFEF4800716C4E788A54F08A9008C76B'),(5638,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','EFEF4800716C4E788A54F08A9008C76B'),(5639,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','EFEF4800716C4E788A54F08A9008C76B'),(5640,'d','main线程是守护线程 ','EFEF4800716C4E788A54F08A9008C76B'),(5641,'a','s>>>=3   ','F70A348516C44BD595D2CD4B6381FE55'),(5642,'b','s[3]= “X”  ','F70A348516C44BD595D2CD4B6381FE55'),(5643,'c','int i = s.length()   ','F70A348516C44BD595D2CD4B6381FE55'),(5644,'d','s = s + 10 ','F70A348516C44BD595D2CD4B6381FE55'),(5645,'a','通过调用stop()方法而停止的线程。 ','EFC117396B744D1680DEA4C229793E4E'),(5646,'b','通过调用sleep()方法而停止的线程。 ','EFC117396B744D1680DEA4C229793E4E'),(5647,'c','通过调用wait()方法而停止的线程。 ','EFC117396B744D1680DEA4C229793E4E'),(5648,'d','通过调用suspend()方法而停止的线程。 ','EFC117396B744D1680DEA4C229793E4E'),(5649,'a','输出：test ','96ECB3FE612E4FCC83210C5A18943BE6'),(5650,'b','输出：Exception ','96ECB3FE612E4FCC83210C5A18943BE6'),(5651,'c','编译失败 ','96ECB3FE612E4FCC83210C5A18943BE6'),(5652,'d','输出：NullPointerException ','96ECB3FE612E4FCC83210C5A18943BE6'),(5653,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','CB644C9EE5B845138FCA065C4FBD168F'),(5654,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','CB644C9EE5B845138FCA065C4FBD168F'),(5655,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','CB644C9EE5B845138FCA065C4FBD168F'),(5656,'d','new InputStreamReader(\"dat\") ; ','CB644C9EE5B845138FCA065C4FBD168F'),(5657,'a','通过调用stop()方法而停止的线程。 ','0867D52E1F0746ED83B62A04A4A00D98'),(5658,'b','通过调用sleep()方法而停止的线程。 ','0867D52E1F0746ED83B62A04A4A00D98'),(5659,'c','通过调用wait()方法而停止的线程。 ','0867D52E1F0746ED83B62A04A4A00D98'),(5660,'d','通过调用suspend()方法而停止的线程。 ','0867D52E1F0746ED83B62A04A4A00D98'),(5661,'a','long 1 = 4990  ','C0AFDB5D127540A1A3E8937982AA9780'),(5662,'b','int i = 4L  ','C0AFDB5D127540A1A3E8937982AA9780'),(5663,'c','float f =1.1  ','C0AFDB5D127540A1A3E8937982AA9780'),(5664,'d','double d = 34.4','C0AFDB5D127540A1A3E8937982AA9780'),(5665,'a','输出：test ','C1DD9BE59F9A47A5B2C610BEF8F88141'),(5666,'b','输出：Exception ','C1DD9BE59F9A47A5B2C610BEF8F88141'),(5667,'c','编译失败 ','C1DD9BE59F9A47A5B2C610BEF8F88141'),(5668,'d','输出：NullPointerException ','C1DD9BE59F9A47A5B2C610BEF8F88141'),(5669,'a','public void method( int m){...}     ','84979A08FBAC4584AE4D61E43B2BA585'),(5670,'b','public int method(){...} ','84979A08FBAC4584AE4D61E43B2BA585'),(5671,'c','public void method2(){...}    ','84979A08FBAC4584AE4D61E43B2BA585'),(5672,'d','public int method(int m，float f ){...} ','84979A08FBAC4584AE4D61E43B2BA585'),(5673,'a','sleep方法 ','5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(5674,'b','IO等待 ','5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(5675,'c','yield方法 ','5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(5676,'d','wait方法 ','5AE6C1A0FFBD4381BD021BC0CCBF9E61'),(5677,'a','将private int m改为 protected int m  ','1A2645D1AEE54168B6B253C3DD0CA998'),(5678,'b','将private int m改为 public int m    ','1A2645D1AEE54168B6B253C3DD0CA998'),(5679,'c','将private int m改为 static int m     ','1A2645D1AEE54168B6B253C3DD0CA998'),(5680,'d','将private int m改为int m ','1A2645D1AEE54168B6B253C3DD0CA998'),(5681,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','213431AF11204FD69CCF18F8439522B5'),(5682,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','213431AF11204FD69CCF18F8439522B5'),(5683,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','213431AF11204FD69CCF18F8439522B5'),(5684,'d','new InputStreamReader(\"1.dat\") ; ','213431AF11204FD69CCF18F8439522B5'),(5685,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0FCBBA0E48CA43AAA7E30796D30F9CB1'),(5686,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0FCBBA0E48CA43AAA7E30796D30F9CB1'),(5687,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0FCBBA0E48CA43AAA7E30796D30F9CB1'),(5688,'d','new InputStreamReader(\"1.dat\") ; ','0FCBBA0E48CA43AAA7E30796D30F9CB1'),(5689,'a','编译错误 ','FFA54377478E42D7A01E7D71E3BBA729'),(5690,'b','抛出运行时异常 ','FFA54377478E42D7A01E7D71E3BBA729'),(5691,'c','输出：bar ','FFA54377478E42D7A01E7D71E3BBA729'),(5692,'d','代码正常运行，但是无输出 ','FFA54377478E42D7A01E7D71E3BBA729'),(5693,'a','输出Exception ','0413E90435FC4D4FB1FEE23601F9FE7A'),(5694,'b','输出A,B,Exception ','0413E90435FC4D4FB1FEE23601F9FE7A'),(5695,'c','编译失败 ','0413E90435FC4D4FB1FEE23601F9FE7A'),(5696,'d','在运行时抛出NullPointerException异常 ','0413E90435FC4D4FB1FEE23601F9FE7A'),(5697,'a','编译错误 ','E8952C853EFF4BFF87F05D414D4ED78E'),(5698,'b','实现向文件record.dat追加写入字符a ','E8952C853EFF4BFF87F05D414D4ED78E'),(5699,'c','实现向文件record.dat覆盖写入字符a ','E8952C853EFF4BFF87F05D414D4ED78E'),(5700,'d','文件record.dat无任何内容 ','E8952C853EFF4BFF87F05D414D4ED78E'),(5701,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','D203B21A22A341059D50FF51D820BA1A'),(5702,'b','垃圾收集将检查并释放不在使用的内存  ','D203B21A22A341059D50FF51D820BA1A'),(5703,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','D203B21A22A341059D50FF51D820BA1A'),(5704,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','D203B21A22A341059D50FF51D820BA1A'),(5705,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','7301865F1FD946079509C0AFF72F804B'),(5706,'b','垃圾收集将检查并释放不在使用的内存  ','7301865F1FD946079509C0AFF72F804B'),(5707,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','7301865F1FD946079509C0AFF72F804B'),(5708,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','7301865F1FD946079509C0AFF72F804B'),(5709,'a','栈是非线性结构        ','B0AB1A23B3104B4BAF40A190A0CE2597'),(5710,'b','栈是一种树状结构 ','B0AB1A23B3104B4BAF40A190A0CE2597'),(5711,'c','栈具有先进先出的特征  ','B0AB1A23B3104B4BAF40A190A0CE2597'),(5712,'d','栈具有后进先出的特征 ','B0AB1A23B3104B4BAF40A190A0CE2597'),(5713,'a','sleep方法 ','4A0A7795EA85408093FD320E246F3839'),(5714,'b','IO等待 ','4A0A7795EA85408093FD320E246F3839'),(5715,'c','yield方法 ','4A0A7795EA85408093FD320E246F3839'),(5716,'d','wait方法 ','4A0A7795EA85408093FD320E246F3839'),(5717,'a','public void method( int m){...}     ','6BEBF5BF0802488AA946FB02AE7F6A8F'),(5718,'b','public int method(){...} ','6BEBF5BF0802488AA946FB02AE7F6A8F'),(5719,'c','public void method2(){...}    ','6BEBF5BF0802488AA946FB02AE7F6A8F'),(5720,'d','public int method(int m，float f ){...} ','6BEBF5BF0802488AA946FB02AE7F6A8F'),(5721,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','12542706BD1B47119195DC25D9FBE82F'),(5722,'b','垃圾收集将检查并释放不在使用的内存  ','12542706BD1B47119195DC25D9FBE82F'),(5723,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','12542706BD1B47119195DC25D9FBE82F'),(5724,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','12542706BD1B47119195DC25D9FBE82F'),(5725,'a','编译错误 ','CF84EF1519B44EA391DFEB1D7669C4FD'),(5726,'b','实现向文件record.dat追加写入字符a ','CF84EF1519B44EA391DFEB1D7669C4FD'),(5727,'c','实现向文件record.dat覆盖写入字符a ','CF84EF1519B44EA391DFEB1D7669C4FD'),(5728,'d','文件record.dat无任何内容 ','CF84EF1519B44EA391DFEB1D7669C4FD'),(5729,'a','一旦一个线程被创建，它就立即开始运行。  ','1F908DE55FC44B5DABA7F325B741FABE'),(5730,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','1F908DE55FC44B5DABA7F325B741FABE'),(5731,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','1F908DE55FC44B5DABA7F325B741FABE'),(5732,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','1F908DE55FC44B5DABA7F325B741FABE'),(5733,'a','start()    ','BD9451FDDC5344B2ADF9B2071536DCBE'),(5734,'b','init()    ','BD9451FDDC5344B2ADF9B2071536DCBE'),(5735,'c','run()    ','BD9451FDDC5344B2ADF9B2071536DCBE'),(5736,'d','main()  ','BD9451FDDC5344B2ADF9B2071536DCBE'),(5737,'a','编译错误 ','9BD5843563AB40E582D75AE781066C2A'),(5738,'b','实现向文件record.dat追加写入字符a ','9BD5843563AB40E582D75AE781066C2A'),(5739,'c','实现向文件record.dat覆盖写入字符a ','9BD5843563AB40E582D75AE781066C2A'),(5740,'d','文件record.dat无任何内容 ','9BD5843563AB40E582D75AE781066C2A'),(5741,'a','5.0','AE0268E517A74B4E8C0674B98BA4937B'),(5742,'b','4.0','AE0268E517A74B4E8C0674B98BA4937B'),(5743,'c','6.0','AE0268E517A74B4E8C0674B98BA4937B'),(5744,'d','finished','AE0268E517A74B4E8C0674B98BA4937B'),(5745,'a','编译错误 ','1EF1C021F1664F89B606141F9944285B'),(5746,'b','实现向文件record.dat追加写入字符a ','1EF1C021F1664F89B606141F9944285B'),(5747,'c','实现向文件record.dat覆盖写入字符a ','1EF1C021F1664F89B606141F9944285B'),(5748,'d','文件record.dat无任何内容 ','1EF1C021F1664F89B606141F9944285B'),(5749,'a','Output is null.             ','595F46030B864B5AA7A2514C5FD01530'),(5750,'b','Output is 0 ','595F46030B864B5AA7A2514C5FD01530'),(5751,'c','编译时报错 ','595F46030B864B5AA7A2514C5FD01530'),(5752,'d','运行时报错','595F46030B864B5AA7A2514C5FD01530'),(5753,'a','m.length()    ','D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(5754,'b','m.length   ','D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(5755,'c','m.length()+1   ','D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(5756,'d','m.length-1','D83968E0FC104EDD8BA6BCF5AAD5EF4B'),(5757,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','0A4B1D2AF0084D7B895035B5EE77D8E6'),(5758,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','0A4B1D2AF0084D7B895035B5EE77D8E6'),(5759,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','0A4B1D2AF0084D7B895035B5EE77D8E6'),(5760,'d','new InputStreamReader(\"dat\") ; ','0A4B1D2AF0084D7B895035B5EE77D8E6'),(5761,'a','start()    ','CFA4D63725C642A48F7FF82A23D6DF68'),(5762,'b','init()    ','CFA4D63725C642A48F7FF82A23D6DF68'),(5763,'c','run()    ','CFA4D63725C642A48F7FF82A23D6DF68'),(5764,'d','main()  ','CFA4D63725C642A48F7FF82A23D6DF68'),(5765,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','09CBFACD70A14F2F9745A645E465E922'),(5766,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','09CBFACD70A14F2F9745A645E465E922'),(5767,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','09CBFACD70A14F2F9745A645E465E922'),(5768,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','09CBFACD70A14F2F9745A645E465E922'),(5769,'a','编译错误 ','61F3E2D3FA414A7C982585BCC73FFA87'),(5770,'b','抛出运行时异常 ','61F3E2D3FA414A7C982585BCC73FFA87'),(5771,'c','输出：bar ','61F3E2D3FA414A7C982585BCC73FFA87'),(5772,'d','代码正常运行，但是无输出 ','61F3E2D3FA414A7C982585BCC73FFA87'),(5773,'a','const   ','9222CF3B26344D5ABF02A74B4D16EB26'),(5774,'b','NULL  ','9222CF3B26344D5ABF02A74B4D16EB26'),(5775,'c','false   ','9222CF3B26344D5ABF02A74B4D16EB26'),(5776,'d','this  ','9222CF3B26344D5ABF02A74B4D16EB26'),(5777,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','0AC17E06E97042EFBEA37DFCDD508C66'),(5778,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','0AC17E06E97042EFBEA37DFCDD508C66'),(5779,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','0AC17E06E97042EFBEA37DFCDD508C66'),(5780,'d','new InputStreamReader(\"dat\") ; ','0AC17E06E97042EFBEA37DFCDD508C66'),(5781,'a','输出：4 ','64C581C57611435FA96D0C207F770D40'),(5782,'b','在运行时抛出NullPointerException异常 ','64C581C57611435FA96D0C207F770D40'),(5783,'c','在运行时抛出NumberFormatException异常 ','64C581C57611435FA96D0C207F770D40'),(5784,'d','在运行时抛出IllegalStateException异常 ','64C581C57611435FA96D0C207F770D40'),(5785,'a','long 1 = 4990  ','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(5786,'b','int i = 4L  ','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(5787,'c','float f =1.1  ','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(5788,'d','double d = 34.4','7C5608C9F84B48048BB9DC6E1B9ACB5B'),(5789,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','AA64AE2B1CFA45B58FF91578C0C692E9'),(5790,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','AA64AE2B1CFA45B58FF91578C0C692E9'),(5791,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','AA64AE2B1CFA45B58FF91578C0C692E9'),(5792,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','AA64AE2B1CFA45B58FF91578C0C692E9'),(5793,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','C67CA358B09B49B082703D8FB5487FC7'),(5794,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','C67CA358B09B49B082703D8FB5487FC7'),(5795,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','C67CA358B09B49B082703D8FB5487FC7'),(5796,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','C67CA358B09B49B082703D8FB5487FC7'),(5797,'a','编译错误 ','D7F585C00576434F9E229D2B28AE5B94'),(5798,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D7F585C00576434F9E229D2B28AE5B94'),(5799,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D7F585C00576434F9E229D2B28AE5B94'),(5800,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D7F585C00576434F9E229D2B28AE5B94'),(5801,'a','s>>>=3   ','4980664FEEE74094BE1EF5C56E0CF621'),(5802,'b','s[3]= “X”  ','4980664FEEE74094BE1EF5C56E0CF621'),(5803,'c','int i = s.length()   ','4980664FEEE74094BE1EF5C56E0CF621'),(5804,'d','s = s + 10 ','4980664FEEE74094BE1EF5C56E0CF621'),(5805,'a','InputStreamReader','F6CA9C10199B422A97C874A6E8014FEF'),(5806,'b','BufferedReader','F6CA9C10199B422A97C874A6E8014FEF'),(5807,'c','FileInputStream','F6CA9C10199B422A97C874A6E8014FEF'),(5808,'d','InputStream','F6CA9C10199B422A97C874A6E8014FEF'),(5809,'a','一旦一个线程被创建，它就立即开始运行。  ','65AAEF852B1241298EF0DD8CE15CF55F'),(5810,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','65AAEF852B1241298EF0DD8CE15CF55F'),(5811,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','65AAEF852B1241298EF0DD8CE15CF55F'),(5812,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','65AAEF852B1241298EF0DD8CE15CF55F'),(5813,'a','编译错误 ','2DBB8289CE3848ED8436AC61EC34CEB8'),(5814,'b','实现向文件record.dat追加写入字符a ','2DBB8289CE3848ED8436AC61EC34CEB8'),(5815,'c','实现向文件record.dat覆盖写入字符a ','2DBB8289CE3848ED8436AC61EC34CEB8'),(5816,'d','文件record.dat无任何内容 ','2DBB8289CE3848ED8436AC61EC34CEB8'),(5817,'a','第3行抛出异常 ','0EBBB7F18A16459393FF93CE72EFADE6'),(5818,'b','第1行抛出异常 ','0EBBB7F18A16459393FF93CE72EFADE6'),(5819,'c','第5行抛出异常 ','0EBBB7F18A16459393FF93CE72EFADE6'),(5820,'d','第3行代码成功执行 ','0EBBB7F18A16459393FF93CE72EFADE6'),(5821,'a','const   ','3D1895E837B5483CBE893C45DF5AD110'),(5822,'b','NULL  ','3D1895E837B5483CBE893C45DF5AD110'),(5823,'c','false   ','3D1895E837B5483CBE893C45DF5AD110'),(5824,'d','this  ','3D1895E837B5483CBE893C45DF5AD110'),(5825,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','BCE8E2EB961046C4865CFDD088105D7E'),(5826,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','BCE8E2EB961046C4865CFDD088105D7E'),(5827,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','BCE8E2EB961046C4865CFDD088105D7E'),(5828,'d','new InputStreamReader(\"1.dat\") ; ','BCE8E2EB961046C4865CFDD088105D7E'),(5829,'a','输出Exception ','55A3E48D36974DAAB0070567857162EB'),(5830,'b','输出A,B,Exception ','55A3E48D36974DAAB0070567857162EB'),(5831,'c','编译失败 ','55A3E48D36974DAAB0070567857162EB'),(5832,'d','在运行时抛出NullPointerException异常 ','55A3E48D36974DAAB0070567857162EB'),(5833,'a','5.0','25FA8D11E9AB40B48B33145A15B64EFB'),(5834,'b','4.0','25FA8D11E9AB40B48B33145A15B64EFB'),(5835,'c','6.0','25FA8D11E9AB40B48B33145A15B64EFB'),(5836,'d','finished','25FA8D11E9AB40B48B33145A15B64EFB'),(5837,'a','start()    ','74345EFDF9CE487B92EA4DF6D9A26F3A'),(5838,'b','init()    ','74345EFDF9CE487B92EA4DF6D9A26F3A'),(5839,'c','run()    ','74345EFDF9CE487B92EA4DF6D9A26F3A'),(5840,'d','main()  ','74345EFDF9CE487B92EA4DF6D9A26F3A'),(5841,'a','输出：4 ','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(5842,'b','在运行时抛出NullPointerException异常 ','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(5843,'c','在运行时抛出NumberFormatException异常 ','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(5844,'d','在运行时抛出IllegalStateException异常 ','9C9F535BDF9D43DAB01A9D9F81C4F8AC'),(5845,'a','第3行抛出异常 ','60BB608E6E6E4C32BD2D4FECCD02E707'),(5846,'b','第1行抛出异常 ','60BB608E6E6E4C32BD2D4FECCD02E707'),(5847,'c','第5行抛出异常 ','60BB608E6E6E4C32BD2D4FECCD02E707'),(5848,'d','第3行代码成功执行 ','60BB608E6E6E4C32BD2D4FECCD02E707'),(5849,'a','InputStreamReader','8636C2FA7EB948A2A4F6C0A081D24DB8'),(5850,'b','BufferedReader','8636C2FA7EB948A2A4F6C0A081D24DB8'),(5851,'c','FileInputStream','8636C2FA7EB948A2A4F6C0A081D24DB8'),(5852,'d','InputStream','8636C2FA7EB948A2A4F6C0A081D24DB8'),(5853,'a','long 1 = 4990  ','632D0490B4F7404D91A9DB9D4862358C'),(5854,'b','int i = 4L  ','632D0490B4F7404D91A9DB9D4862358C'),(5855,'c','float f =1.1  ','632D0490B4F7404D91A9DB9D4862358C'),(5856,'d','double d = 34.4','632D0490B4F7404D91A9DB9D4862358C'),(5857,'a','m.length()    ','09428B0CFC0D4C92A64BA390292D8FBA'),(5858,'b','m.length   ','09428B0CFC0D4C92A64BA390292D8FBA'),(5859,'c','m.length()+1   ','09428B0CFC0D4C92A64BA390292D8FBA'),(5860,'d','m.length-1','09428B0CFC0D4C92A64BA390292D8FBA'),(5861,'a','编译错误 ','8A7D182C8E044B17AB5EDC822114E7EB'),(5862,'b','抛出运行时异常 ','8A7D182C8E044B17AB5EDC822114E7EB'),(5863,'c','输出：sleep ','8A7D182C8E044B17AB5EDC822114E7EB'),(5864,'d','代码正常运行，但是无输出 ','8A7D182C8E044B17AB5EDC822114E7EB'),(5865,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','22AC3BDE7E5D44039BA2D0B3691A6E97'),(5866,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','22AC3BDE7E5D44039BA2D0B3691A6E97'),(5867,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','22AC3BDE7E5D44039BA2D0B3691A6E97'),(5868,'d','new InputStreamReader(\"dat\") ; ','22AC3BDE7E5D44039BA2D0B3691A6E97'),(5869,'a','s>>>=3   ','C989535D3DA2465397237A0DF7D4A1ED'),(5870,'b','s[3]= “X”  ','C989535D3DA2465397237A0DF7D4A1ED'),(5871,'c','int i = s.length()   ','C989535D3DA2465397237A0DF7D4A1ED'),(5872,'d','s = s + 10 ','C989535D3DA2465397237A0DF7D4A1ED'),(5873,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','83D4F9BEFC574F7FB720DFA04F6F8D9C'),(5874,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','83D4F9BEFC574F7FB720DFA04F6F8D9C'),(5875,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','83D4F9BEFC574F7FB720DFA04F6F8D9C'),(5876,'d','new InputStreamReader(\"dat\") ; ','83D4F9BEFC574F7FB720DFA04F6F8D9C'),(5877,'a','sleep方法 ','FB35A591A3CC4B799FAA2CB19F0F3337'),(5878,'b','IO等待 ','FB35A591A3CC4B799FAA2CB19F0F3337'),(5879,'c','yield方法 ','FB35A591A3CC4B799FAA2CB19F0F3337'),(5880,'d','wait方法 ','FB35A591A3CC4B799FAA2CB19F0F3337'),(5881,'a','5.0','D652C6EA73224BD0AA68641FE2FF8953'),(5882,'b','4.0','D652C6EA73224BD0AA68641FE2FF8953'),(5883,'c','6.0','D652C6EA73224BD0AA68641FE2FF8953'),(5884,'d','finished','D652C6EA73224BD0AA68641FE2FF8953'),(5885,'a','编译错误 ','435DFF33FBBF4C8BBF22B18E4D6FCB66'),(5886,'b','实现向文件record.dat追加写入字符a ','435DFF33FBBF4C8BBF22B18E4D6FCB66'),(5887,'c','实现向文件record.dat覆盖写入字符a ','435DFF33FBBF4C8BBF22B18E4D6FCB66'),(5888,'d','文件record.dat无任何内容 ','435DFF33FBBF4C8BBF22B18E4D6FCB66'),(5889,'a','public void method( int m){...}     ','274E7BEA6110417882F2ECAE1D5E2701'),(5890,'b','public int method(){...} ','274E7BEA6110417882F2ECAE1D5E2701'),(5891,'c','public void method2(){...}    ','274E7BEA6110417882F2ECAE1D5E2701'),(5892,'d','public int method(int m，float f ){...} ','274E7BEA6110417882F2ECAE1D5E2701'),(5893,'a','编译错误 ','CD86DC85642E4EC4807A6AF1D59CE34F'),(5894,'b','实现向文件record.dat追加写入字符a ','CD86DC85642E4EC4807A6AF1D59CE34F'),(5895,'c','实现向文件record.dat覆盖写入字符a ','CD86DC85642E4EC4807A6AF1D59CE34F'),(5896,'d','文件record.dat无任何内容 ','CD86DC85642E4EC4807A6AF1D59CE34F'),(5897,'a','long 1 = 4990  ','CD337A4012E84D54BE512743FCAD3652'),(5898,'b','int i = 4L  ','CD337A4012E84D54BE512743FCAD3652'),(5899,'c','float f =1.1  ','CD337A4012E84D54BE512743FCAD3652'),(5900,'d','double d = 34.4','CD337A4012E84D54BE512743FCAD3652'),(5901,'a','private synchronized Object o; ','81E97EC6AB6D42F9AB7694E0964B9FEF'),(5902,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','81E97EC6AB6D42F9AB7694E0964B9FEF'),(5903,'c','public synchronized void go() { /* code here */ } ','81E97EC6AB6D42F9AB7694E0964B9FEF'),(5904,'d','private synchronized(this) void go() { /* code here */ } ','81E97EC6AB6D42F9AB7694E0964B9FEF'),(5905,'a','一旦一个线程被创建，它就立即开始运行。  ','855F8249B7FC4718A6B81DEFA9876E57'),(5906,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','855F8249B7FC4718A6B81DEFA9876E57'),(5907,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','855F8249B7FC4718A6B81DEFA9876E57'),(5908,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','855F8249B7FC4718A6B81DEFA9876E57'),(5909,'a','Output is null.             ','8B1C032B2EDC4B96AE3B1B2564F4F20C'),(5910,'b','Output is 0 ','8B1C032B2EDC4B96AE3B1B2564F4F20C'),(5911,'c','编译时报错 ','8B1C032B2EDC4B96AE3B1B2564F4F20C'),(5912,'d','运行时报错','8B1C032B2EDC4B96AE3B1B2564F4F20C'),(5913,'a','sleep方法 ','A90B7EB988B94928891FE56B40027C73'),(5914,'b','IO等待 ','A90B7EB988B94928891FE56B40027C73'),(5915,'c','yield方法 ','A90B7EB988B94928891FE56B40027C73'),(5916,'d','wait方法 ','A90B7EB988B94928891FE56B40027C73'),(5917,'a','输出：4 ','63321AF40BF541E19D74646BB674A19F'),(5918,'b','在运行时抛出NullPointerException异常 ','63321AF40BF541E19D74646BB674A19F'),(5919,'c','在运行时抛出NumberFormatException异常 ','63321AF40BF541E19D74646BB674A19F'),(5920,'d','在运行时抛出IllegalStateException异常 ','63321AF40BF541E19D74646BB674A19F'),(5921,'a','编译错误 ','5B06C53FDDB54E7FA921FA7A5073A57E'),(5922,'b','抛出运行时异常 ','5B06C53FDDB54E7FA921FA7A5073A57E'),(5923,'c','输出：bar ','5B06C53FDDB54E7FA921FA7A5073A57E'),(5924,'d','代码正常运行，但是无输出 ','5B06C53FDDB54E7FA921FA7A5073A57E'),(5925,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','97DDA73A5682439DB14849C80DD0084A'),(5926,'b','垃圾收集将检查并释放不在使用的内存  ','97DDA73A5682439DB14849C80DD0084A'),(5927,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','97DDA73A5682439DB14849C80DD0084A'),(5928,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','97DDA73A5682439DB14849C80DD0084A'),(5929,'a','编译错误 ','F877409A392345589C51F43EE52FB5A7'),(5930,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F877409A392345589C51F43EE52FB5A7'),(5931,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F877409A392345589C51F43EE52FB5A7'),(5932,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F877409A392345589C51F43EE52FB5A7'),(5933,'a','名为dtThread的线程为守护线程 ','EDE23230BBA4443A807812268B2BF4BB'),(5934,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','EDE23230BBA4443A807812268B2BF4BB'),(5935,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','EDE23230BBA4443A807812268B2BF4BB'),(5936,'d','main线程是守护线程 ','EDE23230BBA4443A807812268B2BF4BB'),(5937,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','555CE6702DB64A73966AE59F3E576DC1'),(5938,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','555CE6702DB64A73966AE59F3E576DC1'),(5939,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','555CE6702DB64A73966AE59F3E576DC1'),(5940,'d','new InputStreamReader(\"dat\") ; ','555CE6702DB64A73966AE59F3E576DC1'),(5941,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','4396F09A6AA84E1B864D2C63A6337752'),(5942,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','4396F09A6AA84E1B864D2C63A6337752'),(5943,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','4396F09A6AA84E1B864D2C63A6337752'),(5944,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','4396F09A6AA84E1B864D2C63A6337752'),(5945,'a','编译错误 ','53381A42A43340FEA4767E580690F62E'),(5946,'b','实现向文件record.dat追加写入字符a ','53381A42A43340FEA4767E580690F62E'),(5947,'c','实现向文件record.dat覆盖写入字符a ','53381A42A43340FEA4767E580690F62E'),(5948,'d','文件record.dat无任何内容 ','53381A42A43340FEA4767E580690F62E'),(5949,'a','输出Exception ','436D43A3765A462C822FF1A0DE416D15'),(5950,'b','输出A,B,Exception ','436D43A3765A462C822FF1A0DE416D15'),(5951,'c','编译失败 ','436D43A3765A462C822FF1A0DE416D15'),(5952,'d','在运行时抛出NullPointerException异常 ','436D43A3765A462C822FF1A0DE416D15'),(5953,'a','编译错误 ','23F2E8A0873849D5875F9B7DA8B217F6'),(5954,'b','程序可以通过编译，运行后文件company.txt没有任何改变','23F2E8A0873849D5875F9B7DA8B217F6'),(5955,'c','程序可以通过编译，运行后文件company.txt的长度变为0','23F2E8A0873849D5875F9B7DA8B217F6'),(5956,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','23F2E8A0873849D5875F9B7DA8B217F6'),(5957,'a','编译错误 ','825D7955FBB04834A4D1D6441C4480B4'),(5958,'b','实现向文件record.dat追加写入字符a ','825D7955FBB04834A4D1D6441C4480B4'),(5959,'c','实现向文件record.dat覆盖写入字符a ','825D7955FBB04834A4D1D6441C4480B4'),(5960,'d','文件record.dat无任何内容 ','825D7955FBB04834A4D1D6441C4480B4'),(5961,'a','编译错误 ','9ADE4D63B86A4EA9895E5ECEBDF919D7'),(5962,'b','抛出运行时异常 ','9ADE4D63B86A4EA9895E5ECEBDF919D7'),(5963,'c','输出：sleep ','9ADE4D63B86A4EA9895E5ECEBDF919D7'),(5964,'d','代码正常运行，但是无输出 ','9ADE4D63B86A4EA9895E5ECEBDF919D7'),(5965,'a','m.length()    ','4B733A8DEE6D4739AA5417D62A9AEC50'),(5966,'b','m.length   ','4B733A8DEE6D4739AA5417D62A9AEC50'),(5967,'c','m.length()+1   ','4B733A8DEE6D4739AA5417D62A9AEC50'),(5968,'d','m.length-1','4B733A8DEE6D4739AA5417D62A9AEC50'),(5969,'a','m.length()    ','7540390049DD4A7F9D190C9F10BA33FC'),(5970,'b','m.length   ','7540390049DD4A7F9D190C9F10BA33FC'),(5971,'c','m.length()+1   ','7540390049DD4A7F9D190C9F10BA33FC'),(5972,'d','m.length-1','7540390049DD4A7F9D190C9F10BA33FC'),(5973,'a','private synchronized Object o; ','EDF65AC0A4484B0B820A06E9D8FC2EE0'),(5974,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','EDF65AC0A4484B0B820A06E9D8FC2EE0'),(5975,'c','public synchronized void go() { /* code here */ } ','EDF65AC0A4484B0B820A06E9D8FC2EE0'),(5976,'d','private synchronized(this) void go() { /* code here */ } ','EDF65AC0A4484B0B820A06E9D8FC2EE0'),(5977,'a','将private int m改为 protected int m  ','F06B1A470DC2487491F6A83E30E5DBC9'),(5978,'b','将private int m改为 public int m    ','F06B1A470DC2487491F6A83E30E5DBC9'),(5979,'c','将private int m改为 static int m     ','F06B1A470DC2487491F6A83E30E5DBC9'),(5980,'d','将private int m改为int m ','F06B1A470DC2487491F6A83E30E5DBC9'),(5981,'a','输出：test ','CF803CA8E4BF4930BA818B704B11BDB4'),(5982,'b','输出：Exception ','CF803CA8E4BF4930BA818B704B11BDB4'),(5983,'c','编译失败 ','CF803CA8E4BF4930BA818B704B11BDB4'),(5984,'d','输出：NullPointerException ','CF803CA8E4BF4930BA818B704B11BDB4'),(5985,'a','sleep方法 ','0E2A5BD27E394B1090CA3124092283E7'),(5986,'b','IO等待 ','0E2A5BD27E394B1090CA3124092283E7'),(5987,'c','yield方法 ','0E2A5BD27E394B1090CA3124092283E7'),(5988,'d','wait方法 ','0E2A5BD27E394B1090CA3124092283E7'),(5989,'a','第3行抛出异常 ','EDE0E139CEC3451C8E9854861259C3D1'),(5990,'b','第1行抛出异常 ','EDE0E139CEC3451C8E9854861259C3D1'),(5991,'c','第5行抛出异常 ','EDE0E139CEC3451C8E9854861259C3D1'),(5992,'d','第3行代码成功执行 ','EDE0E139CEC3451C8E9854861259C3D1'),(5993,'a','5.0','938DB3CC18C64FC18699CFE62E181DE9'),(5994,'b','4.0','938DB3CC18C64FC18699CFE62E181DE9'),(5995,'c','6.0','938DB3CC18C64FC18699CFE62E181DE9'),(5996,'d','finished','938DB3CC18C64FC18699CFE62E181DE9'),(5997,'a','编译错误 ','DC7D5F74C96E415AB785C71833AB8D2C'),(5998,'b','程序可以通过编译，运行后文件company.txt没有任何改变','DC7D5F74C96E415AB785C71833AB8D2C'),(5999,'c','程序可以通过编译，运行后文件company.txt的长度变为0','DC7D5F74C96E415AB785C71833AB8D2C'),(6000,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','DC7D5F74C96E415AB785C71833AB8D2C'),(6001,'a','栈是非线性结构        ','9049E39730144C6C8739DB31557F6633'),(6002,'b','栈是一种树状结构 ','9049E39730144C6C8739DB31557F6633'),(6003,'c','栈具有先进先出的特征  ','9049E39730144C6C8739DB31557F6633'),(6004,'d','栈具有后进先出的特征 ','9049E39730144C6C8739DB31557F6633'),(6005,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','15C5ACD252D645E1A8084BDCB22BD1F6'),(6006,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','15C5ACD252D645E1A8084BDCB22BD1F6'),(6007,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','15C5ACD252D645E1A8084BDCB22BD1F6'),(6008,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','15C5ACD252D645E1A8084BDCB22BD1F6'),(6009,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','24B4F2D7F305451F87EF5643A6D0C828'),(6010,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','24B4F2D7F305451F87EF5643A6D0C828'),(6011,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','24B4F2D7F305451F87EF5643A6D0C828'),(6012,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','24B4F2D7F305451F87EF5643A6D0C828'),(6013,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','0543D8D393FE4F82A89CDD251772D061'),(6014,'b','垃圾收集将检查并释放不在使用的内存  ','0543D8D393FE4F82A89CDD251772D061'),(6015,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','0543D8D393FE4F82A89CDD251772D061'),(6016,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','0543D8D393FE4F82A89CDD251772D061'),(6017,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','EDC1A3552D814E34ACAED9520D61A2D1'),(6018,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','EDC1A3552D814E34ACAED9520D61A2D1'),(6019,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','EDC1A3552D814E34ACAED9520D61A2D1'),(6020,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','EDC1A3552D814E34ACAED9520D61A2D1'),(6021,'a','输出：4 ','E410C06B1C1048CFA0B99B4B28D44B3C'),(6022,'b','在运行时抛出NullPointerException异常 ','E410C06B1C1048CFA0B99B4B28D44B3C'),(6023,'c','在运行时抛出NumberFormatException异常 ','E410C06B1C1048CFA0B99B4B28D44B3C'),(6024,'d','在运行时抛出IllegalStateException异常 ','E410C06B1C1048CFA0B99B4B28D44B3C'),(6025,'a','一旦一个线程被创建，它就立即开始运行。  ','7B8E1CD00AE149FA80B507FD9164290F'),(6026,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','7B8E1CD00AE149FA80B507FD9164290F'),(6027,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','7B8E1CD00AE149FA80B507FD9164290F'),(6028,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','7B8E1CD00AE149FA80B507FD9164290F'),(6029,'a','long 1 = 4990  ','8298338D4AE4437194D940338B7A3CFE'),(6030,'b','int i = 4L  ','8298338D4AE4437194D940338B7A3CFE'),(6031,'c','float f =1.1  ','8298338D4AE4437194D940338B7A3CFE'),(6032,'d','double d = 34.4','8298338D4AE4437194D940338B7A3CFE'),(6033,'a','编译错误 ','5CB23EC66E6B4B2DABEC0E239C86D451'),(6034,'b','抛出运行时异常 ','5CB23EC66E6B4B2DABEC0E239C86D451'),(6035,'c','输出：bar ','5CB23EC66E6B4B2DABEC0E239C86D451'),(6036,'d','代码正常运行，但是无输出 ','5CB23EC66E6B4B2DABEC0E239C86D451'),(6037,'a','s>>>=3   ','F989D5B7E01948D4A88173210106E6CC'),(6038,'b','s[3]= “X”  ','F989D5B7E01948D4A88173210106E6CC'),(6039,'c','int i = s.length()   ','F989D5B7E01948D4A88173210106E6CC'),(6040,'d','s = s + 10 ','F989D5B7E01948D4A88173210106E6CC'),(6041,'a','编译错误 ','ED10214CC95241C1A21839DFB6712B59'),(6042,'b','抛出运行时异常 ','ED10214CC95241C1A21839DFB6712B59'),(6043,'c','输出：sleep ','ED10214CC95241C1A21839DFB6712B59'),(6044,'d','代码正常运行，但是无输出 ','ED10214CC95241C1A21839DFB6712B59'),(6045,'a','第3行抛出异常 ','81DDD64B5091404E903A638A3275BB87'),(6046,'b','第1行抛出异常 ','81DDD64B5091404E903A638A3275BB87'),(6047,'c','第5行抛出异常 ','81DDD64B5091404E903A638A3275BB87'),(6048,'d','第3行代码成功执行 ','81DDD64B5091404E903A638A3275BB87'),(6049,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','4776E09F1DBA4192BB1C38A4544C45FF'),(6050,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','4776E09F1DBA4192BB1C38A4544C45FF'),(6051,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','4776E09F1DBA4192BB1C38A4544C45FF'),(6052,'d','new InputStreamReader(\"1.dat\") ; ','4776E09F1DBA4192BB1C38A4544C45FF'),(6053,'a','通过调用stop()方法而停止的线程。 ','BF9E794FB6204B4DA28344838DB36967'),(6054,'b','通过调用sleep()方法而停止的线程。 ','BF9E794FB6204B4DA28344838DB36967'),(6055,'c','通过调用wait()方法而停止的线程。 ','BF9E794FB6204B4DA28344838DB36967'),(6056,'d','通过调用suspend()方法而停止的线程。 ','BF9E794FB6204B4DA28344838DB36967'),(6057,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','E1AD6D445318499694C6435F2D5F074C'),(6058,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','E1AD6D445318499694C6435F2D5F074C'),(6059,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','E1AD6D445318499694C6435F2D5F074C'),(6060,'d','new InputStreamReader(\"1.dat\") ; ','E1AD6D445318499694C6435F2D5F074C'),(6061,'a','编译错误 ','D84A574885B249F5AEB13A59A3601AA4'),(6062,'b','实现向文件record.dat追加写入字符a ','D84A574885B249F5AEB13A59A3601AA4'),(6063,'c','实现向文件record.dat覆盖写入字符a ','D84A574885B249F5AEB13A59A3601AA4'),(6064,'d','文件record.dat无任何内容 ','D84A574885B249F5AEB13A59A3601AA4'),(6065,'a','Output is null.             ','7CBE3D12E4224139B9EB06C786ED28FD'),(6066,'b','Output is 0 ','7CBE3D12E4224139B9EB06C786ED28FD'),(6067,'c','编译时报错 ','7CBE3D12E4224139B9EB06C786ED28FD'),(6068,'d','运行时报错','7CBE3D12E4224139B9EB06C786ED28FD'),(6069,'a','输出Exception ','03BC69A2D63B49AC97A4356D8FB0A380'),(6070,'b','输出A,B,Exception ','03BC69A2D63B49AC97A4356D8FB0A380'),(6071,'c','编译失败 ','03BC69A2D63B49AC97A4356D8FB0A380'),(6072,'d','在运行时抛出NullPointerException异常 ','03BC69A2D63B49AC97A4356D8FB0A380'),(6073,'a','const   ','09C53C15B56941238EF4E2F8B00A9F95'),(6074,'b','NULL  ','09C53C15B56941238EF4E2F8B00A9F95'),(6075,'c','false   ','09C53C15B56941238EF4E2F8B00A9F95'),(6076,'d','this  ','09C53C15B56941238EF4E2F8B00A9F95'),(6077,'a','InputStreamReader','78E4D599990449DD9FA65CDDFBE61CA2'),(6078,'b','BufferedReader','78E4D599990449DD9FA65CDDFBE61CA2'),(6079,'c','FileInputStream','78E4D599990449DD9FA65CDDFBE61CA2'),(6080,'d','InputStream','78E4D599990449DD9FA65CDDFBE61CA2'),(6081,'a','输出Exception ','FC741D0D99DD4FE093AA5766536AF46C'),(6082,'b','输出A,B,Exception ','FC741D0D99DD4FE093AA5766536AF46C'),(6083,'c','编译失败 ','FC741D0D99DD4FE093AA5766536AF46C'),(6084,'d','在运行时抛出NullPointerException异常 ','FC741D0D99DD4FE093AA5766536AF46C'),(6085,'a','一旦一个线程被创建，它就立即开始运行。  ','58D055FB14FE43ED919859CCCF067B97'),(6086,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','58D055FB14FE43ED919859CCCF067B97'),(6087,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','58D055FB14FE43ED919859CCCF067B97'),(6088,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','58D055FB14FE43ED919859CCCF067B97'),(6089,'a','s>>>=3   ','F190C2F69AE34F4B91E74A208A069C7D'),(6090,'b','s[3]= “X”  ','F190C2F69AE34F4B91E74A208A069C7D'),(6091,'c','int i = s.length()   ','F190C2F69AE34F4B91E74A208A069C7D'),(6092,'d','s = s + 10 ','F190C2F69AE34F4B91E74A208A069C7D'),(6093,'a','public void method( int m){...}     ','329706FC45284D01B254145C2FDC6FF5'),(6094,'b','public int method(){...} ','329706FC45284D01B254145C2FDC6FF5'),(6095,'c','public void method2(){...}    ','329706FC45284D01B254145C2FDC6FF5'),(6096,'d','public int method(int m，float f ){...} ','329706FC45284D01B254145C2FDC6FF5'),(6097,'a','栈是非线性结构        ','A0A9C16F6CDD4C0C9C5B0DA460076A29'),(6098,'b','栈是一种树状结构 ','A0A9C16F6CDD4C0C9C5B0DA460076A29'),(6099,'c','栈具有先进先出的特征  ','A0A9C16F6CDD4C0C9C5B0DA460076A29'),(6100,'d','栈具有后进先出的特征 ','A0A9C16F6CDD4C0C9C5B0DA460076A29'),(6101,'a','start()    ','808A0BD91EA549508B3EDF9312B85848'),(6102,'b','init()    ','808A0BD91EA549508B3EDF9312B85848'),(6103,'c','run()    ','808A0BD91EA549508B3EDF9312B85848'),(6104,'d','main()  ','808A0BD91EA549508B3EDF9312B85848'),(6105,'a','编译错误 ','3D05015A6C164D7783F984AB539C3358'),(6106,'b','实现向文件record.dat追加写入字符a ','3D05015A6C164D7783F984AB539C3358'),(6107,'c','实现向文件record.dat覆盖写入字符a ','3D05015A6C164D7783F984AB539C3358'),(6108,'d','文件record.dat无任何内容 ','3D05015A6C164D7783F984AB539C3358'),(6109,'a','输出：test ','33E22D18B1A548E68947E03AA501A447'),(6110,'b','输出：Exception ','33E22D18B1A548E68947E03AA501A447'),(6111,'c','编译失败 ','33E22D18B1A548E68947E03AA501A447'),(6112,'d','输出：NullPointerException ','33E22D18B1A548E68947E03AA501A447'),(6113,'a','将private int m改为 protected int m  ','81F52435CD614AEA92585458280A090F'),(6114,'b','将private int m改为 public int m    ','81F52435CD614AEA92585458280A090F'),(6115,'c','将private int m改为 static int m     ','81F52435CD614AEA92585458280A090F'),(6116,'d','将private int m改为int m ','81F52435CD614AEA92585458280A090F'),(6117,'a','名为dtThread的线程为守护线程 ','FC35A8164F4849C7B9DF535EC15B79E6'),(6118,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','FC35A8164F4849C7B9DF535EC15B79E6'),(6119,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','FC35A8164F4849C7B9DF535EC15B79E6'),(6120,'d','main线程是守护线程 ','FC35A8164F4849C7B9DF535EC15B79E6'),(6121,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','F972C82759434FC7AAF61E0C14AC217C'),(6122,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','F972C82759434FC7AAF61E0C14AC217C'),(6123,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','F972C82759434FC7AAF61E0C14AC217C'),(6124,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','F972C82759434FC7AAF61E0C14AC217C'),(6125,'a','InputStreamReader','1D15934771994B7FA18EE7C70DB61D1C'),(6126,'b','BufferedReader','1D15934771994B7FA18EE7C70DB61D1C'),(6127,'c','FileInputStream','1D15934771994B7FA18EE7C70DB61D1C'),(6128,'d','InputStream','1D15934771994B7FA18EE7C70DB61D1C'),(6129,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','79C4369D5C084B009ECAB86185455F68'),(6130,'b','垃圾收集将检查并释放不在使用的内存  ','79C4369D5C084B009ECAB86185455F68'),(6131,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','79C4369D5C084B009ECAB86185455F68'),(6132,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','79C4369D5C084B009ECAB86185455F68'),(6133,'a','const   ','521F8738D95F4360BA4257A38DD65584'),(6134,'b','NULL  ','521F8738D95F4360BA4257A38DD65584'),(6135,'c','false   ','521F8738D95F4360BA4257A38DD65584'),(6136,'d','this  ','521F8738D95F4360BA4257A38DD65584'),(6137,'a','private synchronized Object o; ','F43017E7D7994F1FB738CB11F4046AB8'),(6138,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','F43017E7D7994F1FB738CB11F4046AB8'),(6139,'c','public synchronized void go() { /* code here */ } ','F43017E7D7994F1FB738CB11F4046AB8'),(6140,'d','private synchronized(this) void go() { /* code here */ } ','F43017E7D7994F1FB738CB11F4046AB8'),(6141,'a','通过调用stop()方法而停止的线程。 ','9F13AA53017F456CBCD746891E672C3E'),(6142,'b','通过调用sleep()方法而停止的线程。 ','9F13AA53017F456CBCD746891E672C3E'),(6143,'c','通过调用wait()方法而停止的线程。 ','9F13AA53017F456CBCD746891E672C3E'),(6144,'d','通过调用suspend()方法而停止的线程。 ','9F13AA53017F456CBCD746891E672C3E'),(6145,'a','将private int m改为 protected int m  ','295DD721E257458DA40B3B17E8599AA5'),(6146,'b','将private int m改为 public int m    ','295DD721E257458DA40B3B17E8599AA5'),(6147,'c','将private int m改为 static int m     ','295DD721E257458DA40B3B17E8599AA5'),(6148,'d','将private int m改为int m ','295DD721E257458DA40B3B17E8599AA5'),(6149,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','16A6BF18CE014E06AFF9A5BE86AE13E3'),(6150,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','16A6BF18CE014E06AFF9A5BE86AE13E3'),(6151,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','16A6BF18CE014E06AFF9A5BE86AE13E3'),(6152,'d','new InputStreamReader(\"1.dat\") ; ','16A6BF18CE014E06AFF9A5BE86AE13E3'),(6153,'a','编译错误 ','6898DE2C981C41A198058EAF9EEE16A9'),(6154,'b','抛出运行时异常 ','6898DE2C981C41A198058EAF9EEE16A9'),(6155,'c','输出：bar ','6898DE2C981C41A198058EAF9EEE16A9'),(6156,'d','代码正常运行，但是无输出 ','6898DE2C981C41A198058EAF9EEE16A9'),(6157,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','32C34E0881AD47F49BE0B4D549D50988'),(6158,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','32C34E0881AD47F49BE0B4D549D50988'),(6159,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','32C34E0881AD47F49BE0B4D549D50988'),(6160,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','32C34E0881AD47F49BE0B4D549D50988'),(6161,'a','start()    ','DD9C53E5FB494381ADA04E4638EC428C'),(6162,'b','init()    ','DD9C53E5FB494381ADA04E4638EC428C'),(6163,'c','run()    ','DD9C53E5FB494381ADA04E4638EC428C'),(6164,'d','main()  ','DD9C53E5FB494381ADA04E4638EC428C'),(6165,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','2615D6CD0F1C43978448245BDF843B5B'),(6166,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','2615D6CD0F1C43978448245BDF843B5B'),(6167,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','2615D6CD0F1C43978448245BDF843B5B'),(6168,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','2615D6CD0F1C43978448245BDF843B5B'),(6169,'a','编译错误 ','19B517D3B52F40578347905C3D044486'),(6170,'b','实现向文件record.dat追加写入字符a ','19B517D3B52F40578347905C3D044486'),(6171,'c','实现向文件record.dat覆盖写入字符a ','19B517D3B52F40578347905C3D044486'),(6172,'d','文件record.dat无任何内容 ','19B517D3B52F40578347905C3D044486'),(6173,'a','InputStreamReader','F9FA720A32EB4F969E6A5104E0C8E8DB'),(6174,'b','BufferedReader','F9FA720A32EB4F969E6A5104E0C8E8DB'),(6175,'c','FileInputStream','F9FA720A32EB4F969E6A5104E0C8E8DB'),(6176,'d','InputStream','F9FA720A32EB4F969E6A5104E0C8E8DB'),(6177,'a','m.length()    ','E70032CFDD22460C966839D6828B3D84'),(6178,'b','m.length   ','E70032CFDD22460C966839D6828B3D84'),(6179,'c','m.length()+1   ','E70032CFDD22460C966839D6828B3D84'),(6180,'d','m.length-1','E70032CFDD22460C966839D6828B3D84'),(6181,'a','栈是非线性结构        ','1BF333CF63E64126A30DD17110FB01AA'),(6182,'b','栈是一种树状结构 ','1BF333CF63E64126A30DD17110FB01AA'),(6183,'c','栈具有先进先出的特征  ','1BF333CF63E64126A30DD17110FB01AA'),(6184,'d','栈具有后进先出的特征 ','1BF333CF63E64126A30DD17110FB01AA'),(6185,'a','第3行抛出异常 ','D660E09215B34A70BDC91F490EA27A06'),(6186,'b','第1行抛出异常 ','D660E09215B34A70BDC91F490EA27A06'),(6187,'c','第5行抛出异常 ','D660E09215B34A70BDC91F490EA27A06'),(6188,'d','第3行代码成功执行 ','D660E09215B34A70BDC91F490EA27A06'),(6189,'a','编译错误 ','66A765BB58C54E408F8B8A597438D34B'),(6190,'b','实现向文件record.dat追加写入字符a ','66A765BB58C54E408F8B8A597438D34B'),(6191,'c','实现向文件record.dat覆盖写入字符a ','66A765BB58C54E408F8B8A597438D34B'),(6192,'d','文件record.dat无任何内容 ','66A765BB58C54E408F8B8A597438D34B'),(6193,'a','第3行抛出异常 ','E0E5CC9B9DFB46D585F1547C00361D74'),(6194,'b','第1行抛出异常 ','E0E5CC9B9DFB46D585F1547C00361D74'),(6195,'c','第5行抛出异常 ','E0E5CC9B9DFB46D585F1547C00361D74'),(6196,'d','第3行代码成功执行 ','E0E5CC9B9DFB46D585F1547C00361D74'),(6197,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','4D21A34788D84C99B33234D0632DA411'),(6198,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','4D21A34788D84C99B33234D0632DA411'),(6199,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','4D21A34788D84C99B33234D0632DA411'),(6200,'d','new InputStreamReader(\"1.dat\") ; ','4D21A34788D84C99B33234D0632DA411'),(6201,'a','编译错误 ','3CC7679ED20943A8AB106E2B229CE269'),(6202,'b','抛出运行时异常 ','3CC7679ED20943A8AB106E2B229CE269'),(6203,'c','输出：sleep ','3CC7679ED20943A8AB106E2B229CE269'),(6204,'d','代码正常运行，但是无输出 ','3CC7679ED20943A8AB106E2B229CE269'),(6205,'a','将private int m改为 protected int m  ','375B9BBAE57B4CF3A9A85DF58C603211'),(6206,'b','将private int m改为 public int m    ','375B9BBAE57B4CF3A9A85DF58C603211'),(6207,'c','将private int m改为 static int m     ','375B9BBAE57B4CF3A9A85DF58C603211'),(6208,'d','将private int m改为int m ','375B9BBAE57B4CF3A9A85DF58C603211'),(6209,'a','编译错误 ','F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(6210,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(6211,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(6212,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F11F8BAD0EAF44BB8409F4C4F4DF4F72'),(6213,'a','名为dtThread的线程为守护线程 ','2D92B3A0EFD24E698D9B7907B5338C11'),(6214,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','2D92B3A0EFD24E698D9B7907B5338C11'),(6215,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','2D92B3A0EFD24E698D9B7907B5338C11'),(6216,'d','main线程是守护线程 ','2D92B3A0EFD24E698D9B7907B5338C11'),(6217,'a','m.length()    ','2FE0D8ECEB2341F28F9A298B99DBE435'),(6218,'b','m.length   ','2FE0D8ECEB2341F28F9A298B99DBE435'),(6219,'c','m.length()+1   ','2FE0D8ECEB2341F28F9A298B99DBE435'),(6220,'d','m.length-1','2FE0D8ECEB2341F28F9A298B99DBE435'),(6221,'a','将private int m改为 protected int m  ','003A3CE42BBF4289B57F500920DA5DE3'),(6222,'b','将private int m改为 public int m    ','003A3CE42BBF4289B57F500920DA5DE3'),(6223,'c','将private int m改为 static int m     ','003A3CE42BBF4289B57F500920DA5DE3'),(6224,'d','将private int m改为int m ','003A3CE42BBF4289B57F500920DA5DE3'),(6225,'a','输出Exception ','119E5EF740FA44EABD71DFAD54A61393'),(6226,'b','输出A,B,Exception ','119E5EF740FA44EABD71DFAD54A61393'),(6227,'c','编译失败 ','119E5EF740FA44EABD71DFAD54A61393'),(6228,'d','在运行时抛出NullPointerException异常 ','119E5EF740FA44EABD71DFAD54A61393'),(6229,'a','const   ','C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(6230,'b','NULL  ','C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(6231,'c','false   ','C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(6232,'d','this  ','C8EB2FEC3DBF4EF2885729DDAF17DCDA'),(6233,'a','栈是非线性结构        ','E6BED81C3B174E708FC985C1CC16F948'),(6234,'b','栈是一种树状结构 ','E6BED81C3B174E708FC985C1CC16F948'),(6235,'c','栈具有先进先出的特征  ','E6BED81C3B174E708FC985C1CC16F948'),(6236,'d','栈具有后进先出的特征 ','E6BED81C3B174E708FC985C1CC16F948'),(6237,'a','InputStreamReader','EC95DFD2A860487891780D49A0816759'),(6238,'b','BufferedReader','EC95DFD2A860487891780D49A0816759'),(6239,'c','FileInputStream','EC95DFD2A860487891780D49A0816759'),(6240,'d','InputStream','EC95DFD2A860487891780D49A0816759'),(6241,'a','编译错误 ','F47CE03E84ED4C78AE2B01EFB0BD9982'),(6242,'b','抛出运行时异常 ','F47CE03E84ED4C78AE2B01EFB0BD9982'),(6243,'c','输出：sleep ','F47CE03E84ED4C78AE2B01EFB0BD9982'),(6244,'d','代码正常运行，但是无输出 ','F47CE03E84ED4C78AE2B01EFB0BD9982'),(6245,'a','一旦一个线程被创建，它就立即开始运行。  ','B5F2F5237A8C4C5D9498F5598C177300'),(6246,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','B5F2F5237A8C4C5D9498F5598C177300'),(6247,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','B5F2F5237A8C4C5D9498F5598C177300'),(6248,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','B5F2F5237A8C4C5D9498F5598C177300'),(6249,'a','Output is null.             ','99629B14E46243759AAA9D372F54F79B'),(6250,'b','Output is 0 ','99629B14E46243759AAA9D372F54F79B'),(6251,'c','编译时报错 ','99629B14E46243759AAA9D372F54F79B'),(6252,'d','运行时报错','99629B14E46243759AAA9D372F54F79B'),(6253,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','AC6471EC5B974392934D74BB93F9433A'),(6254,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','AC6471EC5B974392934D74BB93F9433A'),(6255,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','AC6471EC5B974392934D74BB93F9433A'),(6256,'d','new InputStreamReader(\"dat\") ; ','AC6471EC5B974392934D74BB93F9433A'),(6257,'a','5.0','7B5788DE261E4F0B831E2E5DFF8B48F3'),(6258,'b','4.0','7B5788DE261E4F0B831E2E5DFF8B48F3'),(6259,'c','6.0','7B5788DE261E4F0B831E2E5DFF8B48F3'),(6260,'d','finished','7B5788DE261E4F0B831E2E5DFF8B48F3'),(6261,'a','public void method( int m){...}     ','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(6262,'b','public int method(){...} ','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(6263,'c','public void method2(){...}    ','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(6264,'d','public int method(int m，float f ){...} ','A0CEAA1E7DDE4AD6BE3669B5789ED2EC'),(6265,'a','s>>>=3   ','2CD78964FDB04D3286C934F576DD6AA2'),(6266,'b','s[3]= “X”  ','2CD78964FDB04D3286C934F576DD6AA2'),(6267,'c','int i = s.length()   ','2CD78964FDB04D3286C934F576DD6AA2'),(6268,'d','s = s + 10 ','2CD78964FDB04D3286C934F576DD6AA2'),(6269,'a','第3行抛出异常 ','6BBE419AF2B74821923AE428CD594584'),(6270,'b','第1行抛出异常 ','6BBE419AF2B74821923AE428CD594584'),(6271,'c','第5行抛出异常 ','6BBE419AF2B74821923AE428CD594584'),(6272,'d','第3行代码成功执行 ','6BBE419AF2B74821923AE428CD594584'),(6273,'a','5.0','91ACB31317C14810AB7FA8D25F474A31'),(6274,'b','4.0','91ACB31317C14810AB7FA8D25F474A31'),(6275,'c','6.0','91ACB31317C14810AB7FA8D25F474A31'),(6276,'d','finished','91ACB31317C14810AB7FA8D25F474A31'),(6277,'a','栈是非线性结构        ','F547BF7A1E9640B8B7E819EF06D18141'),(6278,'b','栈是一种树状结构 ','F547BF7A1E9640B8B7E819EF06D18141'),(6279,'c','栈具有先进先出的特征  ','F547BF7A1E9640B8B7E819EF06D18141'),(6280,'d','栈具有后进先出的特征 ','F547BF7A1E9640B8B7E819EF06D18141'),(6281,'a','s>>>=3   ','B4F0B52F92B14322932F9F3468E64390'),(6282,'b','s[3]= “X”  ','B4F0B52F92B14322932F9F3468E64390'),(6283,'c','int i = s.length()   ','B4F0B52F92B14322932F9F3468E64390'),(6284,'d','s = s + 10 ','B4F0B52F92B14322932F9F3468E64390'),(6285,'a','private synchronized Object o; ','3E75ACCA16C14F7191BE8EBDA6C3AC32'),(6286,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','3E75ACCA16C14F7191BE8EBDA6C3AC32'),(6287,'c','public synchronized void go() { /* code here */ } ','3E75ACCA16C14F7191BE8EBDA6C3AC32'),(6288,'d','private synchronized(this) void go() { /* code here */ } ','3E75ACCA16C14F7191BE8EBDA6C3AC32'),(6289,'a','m.length()    ','80A64B51289C40FE93FDE1BBA74D0022'),(6290,'b','m.length   ','80A64B51289C40FE93FDE1BBA74D0022'),(6291,'c','m.length()+1   ','80A64B51289C40FE93FDE1BBA74D0022'),(6292,'d','m.length-1','80A64B51289C40FE93FDE1BBA74D0022'),(6293,'a','编译错误 ','C0EEE70D6F6F4968B8296E2D52E2F1B8'),(6294,'b','抛出运行时异常 ','C0EEE70D6F6F4968B8296E2D52E2F1B8'),(6295,'c','输出：bar ','C0EEE70D6F6F4968B8296E2D52E2F1B8'),(6296,'d','代码正常运行，但是无输出 ','C0EEE70D6F6F4968B8296E2D52E2F1B8'),(6297,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','5A651F4832374D32A049DB3B119167A6'),(6298,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','5A651F4832374D32A049DB3B119167A6'),(6299,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','5A651F4832374D32A049DB3B119167A6'),(6300,'d','new InputStreamReader(\"dat\") ; ','5A651F4832374D32A049DB3B119167A6'),(6301,'a','编译错误 ','533E7E73FE0348D0935D07BF4C5D8860'),(6302,'b','实现向文件record.dat追加写入字符a ','533E7E73FE0348D0935D07BF4C5D8860'),(6303,'c','实现向文件record.dat覆盖写入字符a ','533E7E73FE0348D0935D07BF4C5D8860'),(6304,'d','文件record.dat无任何内容 ','533E7E73FE0348D0935D07BF4C5D8860'),(6305,'a','通过调用stop()方法而停止的线程。 ','50E80301AF3A4036A1CC737159EE46CA'),(6306,'b','通过调用sleep()方法而停止的线程。 ','50E80301AF3A4036A1CC737159EE46CA'),(6307,'c','通过调用wait()方法而停止的线程。 ','50E80301AF3A4036A1CC737159EE46CA'),(6308,'d','通过调用suspend()方法而停止的线程。 ','50E80301AF3A4036A1CC737159EE46CA'),(6309,'a','const   ','76B3C03EB0C04229974EF7B08BAB3404'),(6310,'b','NULL  ','76B3C03EB0C04229974EF7B08BAB3404'),(6311,'c','false   ','76B3C03EB0C04229974EF7B08BAB3404'),(6312,'d','this  ','76B3C03EB0C04229974EF7B08BAB3404'),(6313,'a','InputStreamReader','40AF6A85DE0D44C3AF6F2122C99033D1'),(6314,'b','BufferedReader','40AF6A85DE0D44C3AF6F2122C99033D1'),(6315,'c','FileInputStream','40AF6A85DE0D44C3AF6F2122C99033D1'),(6316,'d','InputStream','40AF6A85DE0D44C3AF6F2122C99033D1'),(6317,'a','long 1 = 4990  ','B9494DA7CA294715BCE7BDAA3446C82B'),(6318,'b','int i = 4L  ','B9494DA7CA294715BCE7BDAA3446C82B'),(6319,'c','float f =1.1  ','B9494DA7CA294715BCE7BDAA3446C82B'),(6320,'d','double d = 34.4','B9494DA7CA294715BCE7BDAA3446C82B'),(6321,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','EB20C87468C647FD95CA00663E89E733'),(6322,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','EB20C87468C647FD95CA00663E89E733'),(6323,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','EB20C87468C647FD95CA00663E89E733'),(6324,'d','new InputStreamReader(\"dat\") ; ','EB20C87468C647FD95CA00663E89E733'),(6325,'a','输出：4 ','87FA9065EDAC4039A085CC9DBD15063C'),(6326,'b','在运行时抛出NullPointerException异常 ','87FA9065EDAC4039A085CC9DBD15063C'),(6327,'c','在运行时抛出NumberFormatException异常 ','87FA9065EDAC4039A085CC9DBD15063C'),(6328,'d','在运行时抛出IllegalStateException异常 ','87FA9065EDAC4039A085CC9DBD15063C'),(6329,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','3CEEDA7CD02B46F3BF0F5CFA32D45399'),(6330,'b','垃圾收集将检查并释放不在使用的内存  ','3CEEDA7CD02B46F3BF0F5CFA32D45399'),(6331,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','3CEEDA7CD02B46F3BF0F5CFA32D45399'),(6332,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','3CEEDA7CD02B46F3BF0F5CFA32D45399'),(6333,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','0E08E66A8AB645159BCE242D26B62202'),(6334,'b','垃圾收集将检查并释放不在使用的内存  ','0E08E66A8AB645159BCE242D26B62202'),(6335,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','0E08E66A8AB645159BCE242D26B62202'),(6336,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','0E08E66A8AB645159BCE242D26B62202'),(6337,'a','通过调用stop()方法而停止的线程。 ','9EE93CF38D344B13BDE4CED1D5358251'),(6338,'b','通过调用sleep()方法而停止的线程。 ','9EE93CF38D344B13BDE4CED1D5358251'),(6339,'c','通过调用wait()方法而停止的线程。 ','9EE93CF38D344B13BDE4CED1D5358251'),(6340,'d','通过调用suspend()方法而停止的线程。 ','9EE93CF38D344B13BDE4CED1D5358251'),(6341,'a','public void method( int m){...}     ','1A5266262367427C8637D993FE966F21'),(6342,'b','public int method(){...} ','1A5266262367427C8637D993FE966F21'),(6343,'c','public void method2(){...}    ','1A5266262367427C8637D993FE966F21'),(6344,'d','public int method(int m，float f ){...} ','1A5266262367427C8637D993FE966F21'),(6345,'a','start()    ','48CA108F7CF14766B4066F3298186FE3'),(6346,'b','init()    ','48CA108F7CF14766B4066F3298186FE3'),(6347,'c','run()    ','48CA108F7CF14766B4066F3298186FE3'),(6348,'d','main()  ','48CA108F7CF14766B4066F3298186FE3'),(6349,'a','5.0','2039E97D0941437E8774BD4D4C9CC5A5'),(6350,'b','4.0','2039E97D0941437E8774BD4D4C9CC5A5'),(6351,'c','6.0','2039E97D0941437E8774BD4D4C9CC5A5'),(6352,'d','finished','2039E97D0941437E8774BD4D4C9CC5A5'),(6353,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','E54F7561D1A54BCFB5BCE654A9B939E1'),(6354,'b','垃圾收集将检查并释放不在使用的内存  ','E54F7561D1A54BCFB5BCE654A9B939E1'),(6355,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','E54F7561D1A54BCFB5BCE654A9B939E1'),(6356,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','E54F7561D1A54BCFB5BCE654A9B939E1'),(6357,'a','输出：4 ','E0BCA8C7EA704D44B25AD8D9FBBC9049'),(6358,'b','在运行时抛出NullPointerException异常 ','E0BCA8C7EA704D44B25AD8D9FBBC9049'),(6359,'c','在运行时抛出NumberFormatException异常 ','E0BCA8C7EA704D44B25AD8D9FBBC9049'),(6360,'d','在运行时抛出IllegalStateException异常 ','E0BCA8C7EA704D44B25AD8D9FBBC9049'),(6361,'a','private synchronized Object o; ','6A4B6D306E954A58AF67FE2B0918A52A'),(6362,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','6A4B6D306E954A58AF67FE2B0918A52A'),(6363,'c','public synchronized void go() { /* code here */ } ','6A4B6D306E954A58AF67FE2B0918A52A'),(6364,'d','private synchronized(this) void go() { /* code here */ } ','6A4B6D306E954A58AF67FE2B0918A52A'),(6365,'a','编译错误 ','9ABDBBE373C945ADAB6AECD62691B2EC'),(6366,'b','程序可以通过编译，运行后文件company.txt没有任何改变','9ABDBBE373C945ADAB6AECD62691B2EC'),(6367,'c','程序可以通过编译，运行后文件company.txt的长度变为0','9ABDBBE373C945ADAB6AECD62691B2EC'),(6368,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','9ABDBBE373C945ADAB6AECD62691B2EC'),(6369,'a','const   ','A96CAB20630C46FE98F12F3F9E4EDBC3'),(6370,'b','NULL  ','A96CAB20630C46FE98F12F3F9E4EDBC3'),(6371,'c','false   ','A96CAB20630C46FE98F12F3F9E4EDBC3'),(6372,'d','this  ','A96CAB20630C46FE98F12F3F9E4EDBC3'),(6373,'a','编译错误 ','E34607B970B847F5833C3EE91DBE260A'),(6374,'b','程序可以通过编译，运行后文件company.txt没有任何改变','E34607B970B847F5833C3EE91DBE260A'),(6375,'c','程序可以通过编译，运行后文件company.txt的长度变为0','E34607B970B847F5833C3EE91DBE260A'),(6376,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','E34607B970B847F5833C3EE91DBE260A'),(6377,'a','private synchronized Object o; ','592045A682C143F1B5F73AB2BC49EA39'),(6378,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','592045A682C143F1B5F73AB2BC49EA39'),(6379,'c','public synchronized void go() { /* code here */ } ','592045A682C143F1B5F73AB2BC49EA39'),(6380,'d','private synchronized(this) void go() { /* code here */ } ','592045A682C143F1B5F73AB2BC49EA39'),(6381,'a','输出：4 ','15AF822681384E0C8116298B275F4E5F'),(6382,'b','在运行时抛出NullPointerException异常 ','15AF822681384E0C8116298B275F4E5F'),(6383,'c','在运行时抛出NumberFormatException异常 ','15AF822681384E0C8116298B275F4E5F'),(6384,'d','在运行时抛出IllegalStateException异常 ','15AF822681384E0C8116298B275F4E5F'),(6385,'a','一旦一个线程被创建，它就立即开始运行。  ','154A8F749A014BB89B6559B2ED663231'),(6386,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','154A8F749A014BB89B6559B2ED663231'),(6387,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','154A8F749A014BB89B6559B2ED663231'),(6388,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','154A8F749A014BB89B6559B2ED663231'),(6389,'a','将private int m改为 protected int m  ','B381A76FE262452B9E6C9478034D7294'),(6390,'b','将private int m改为 public int m    ','B381A76FE262452B9E6C9478034D7294'),(6391,'c','将private int m改为 static int m     ','B381A76FE262452B9E6C9478034D7294'),(6392,'d','将private int m改为int m ','B381A76FE262452B9E6C9478034D7294'),(6393,'a','输出：test ','E0EBC82ADAA04CB6A525D33648826673'),(6394,'b','输出：Exception ','E0EBC82ADAA04CB6A525D33648826673'),(6395,'c','编译失败 ','E0EBC82ADAA04CB6A525D33648826673'),(6396,'d','输出：NullPointerException ','E0EBC82ADAA04CB6A525D33648826673'),(6397,'a','编译错误 ','DAA6D7CA54404D2ABD317D6E34B54068'),(6398,'b','抛出运行时异常 ','DAA6D7CA54404D2ABD317D6E34B54068'),(6399,'c','输出：bar ','DAA6D7CA54404D2ABD317D6E34B54068'),(6400,'d','代码正常运行，但是无输出 ','DAA6D7CA54404D2ABD317D6E34B54068'),(6401,'a','编译错误 ','9B0FDE2C2E8140E5A112E7196C143B96'),(6402,'b','实现向文件record.dat追加写入字符a ','9B0FDE2C2E8140E5A112E7196C143B96'),(6403,'c','实现向文件record.dat覆盖写入字符a ','9B0FDE2C2E8140E5A112E7196C143B96'),(6404,'d','文件record.dat无任何内容 ','9B0FDE2C2E8140E5A112E7196C143B96'),(6405,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','867759DE356A4AF4A9506844D56D3CBD'),(6406,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','867759DE356A4AF4A9506844D56D3CBD'),(6407,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','867759DE356A4AF4A9506844D56D3CBD'),(6408,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','867759DE356A4AF4A9506844D56D3CBD'),(6409,'a','输出：test ','9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(6410,'b','输出：Exception ','9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(6411,'c','编译失败 ','9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(6412,'d','输出：NullPointerException ','9DAE3F2B54EA4A3DAB2CA9CE7F4776A5'),(6413,'a','编译错误 ','06817551644C4775813A63475CD22F5C'),(6414,'b','实现向文件record.dat追加写入字符a ','06817551644C4775813A63475CD22F5C'),(6415,'c','实现向文件record.dat覆盖写入字符a ','06817551644C4775813A63475CD22F5C'),(6416,'d','文件record.dat无任何内容 ','06817551644C4775813A63475CD22F5C'),(6417,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','B647C898BB624E8B9C169FA8ED71DB11'),(6418,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','B647C898BB624E8B9C169FA8ED71DB11'),(6419,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','B647C898BB624E8B9C169FA8ED71DB11'),(6420,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','B647C898BB624E8B9C169FA8ED71DB11'),(6421,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','8254D1C937494DC1BDE603DFBB7DBA20'),(6422,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','8254D1C937494DC1BDE603DFBB7DBA20'),(6423,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','8254D1C937494DC1BDE603DFBB7DBA20'),(6424,'d','new InputStreamReader(\"1.dat\") ; ','8254D1C937494DC1BDE603DFBB7DBA20'),(6425,'a','名为dtThread的线程为守护线程 ','494A6ADC1C424B0990FF898174DEA3BF'),(6426,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','494A6ADC1C424B0990FF898174DEA3BF'),(6427,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','494A6ADC1C424B0990FF898174DEA3BF'),(6428,'d','main线程是守护线程 ','494A6ADC1C424B0990FF898174DEA3BF'),(6429,'a','通过调用stop()方法而停止的线程。 ','CB798645904E4DFBAE124FC361420EDE'),(6430,'b','通过调用sleep()方法而停止的线程。 ','CB798645904E4DFBAE124FC361420EDE'),(6431,'c','通过调用wait()方法而停止的线程。 ','CB798645904E4DFBAE124FC361420EDE'),(6432,'d','通过调用suspend()方法而停止的线程。 ','CB798645904E4DFBAE124FC361420EDE'),(6433,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(6434,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(6435,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(6436,'d','new InputStreamReader(\"1.dat\") ; ','0F2C2BF7BBAF4CDCA319725F4ED4B8BB'),(6437,'a','Output is null.             ','F1A5E74880D34C7CBCFD7ED24D062263'),(6438,'b','Output is 0 ','F1A5E74880D34C7CBCFD7ED24D062263'),(6439,'c','编译时报错 ','F1A5E74880D34C7CBCFD7ED24D062263'),(6440,'d','运行时报错','F1A5E74880D34C7CBCFD7ED24D062263'),(6441,'a','一旦一个线程被创建，它就立即开始运行。  ','6D2079CAACF54FD1996EB3B034058787'),(6442,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','6D2079CAACF54FD1996EB3B034058787'),(6443,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','6D2079CAACF54FD1996EB3B034058787'),(6444,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','6D2079CAACF54FD1996EB3B034058787'),(6445,'a','start()    ','7BA353CD6E6146AA9BD40C103F8F0B25'),(6446,'b','init()    ','7BA353CD6E6146AA9BD40C103F8F0B25'),(6447,'c','run()    ','7BA353CD6E6146AA9BD40C103F8F0B25'),(6448,'d','main()  ','7BA353CD6E6146AA9BD40C103F8F0B25'),(6449,'a','sleep方法 ','A086187FDE3E411DA803CCA6FD4A260B'),(6450,'b','IO等待 ','A086187FDE3E411DA803CCA6FD4A260B'),(6451,'c','yield方法 ','A086187FDE3E411DA803CCA6FD4A260B'),(6452,'d','wait方法 ','A086187FDE3E411DA803CCA6FD4A260B'),(6453,'a','long 1 = 4990  ','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(6454,'b','int i = 4L  ','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(6455,'c','float f =1.1  ','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(6456,'d','double d = 34.4','5AEF21E0863A48B9AAD6675F5EA6EEAB'),(6457,'a','sleep方法 ','95BB57D10490464CACCB836D1987B76C'),(6458,'b','IO等待 ','95BB57D10490464CACCB836D1987B76C'),(6459,'c','yield方法 ','95BB57D10490464CACCB836D1987B76C'),(6460,'d','wait方法 ','95BB57D10490464CACCB836D1987B76C'),(6461,'a','编译错误 ','A14341A6F3284C5CA55170871D4A4FA1'),(6462,'b','抛出运行时异常 ','A14341A6F3284C5CA55170871D4A4FA1'),(6463,'c','输出：sleep ','A14341A6F3284C5CA55170871D4A4FA1'),(6464,'d','代码正常运行，但是无输出 ','A14341A6F3284C5CA55170871D4A4FA1'),(6465,'a','输出Exception ','1B60F1B1E9E9432AABA1E787C9867C5B'),(6466,'b','输出A,B,Exception ','1B60F1B1E9E9432AABA1E787C9867C5B'),(6467,'c','编译失败 ','1B60F1B1E9E9432AABA1E787C9867C5B'),(6468,'d','在运行时抛出NullPointerException异常 ','1B60F1B1E9E9432AABA1E787C9867C5B'),(6469,'a','输出Exception ','AA5A5FB2ACCC4BE7894B8E1280C50B53'),(6470,'b','输出A,B,Exception ','AA5A5FB2ACCC4BE7894B8E1280C50B53'),(6471,'c','编译失败 ','AA5A5FB2ACCC4BE7894B8E1280C50B53'),(6472,'d','在运行时抛出NullPointerException异常 ','AA5A5FB2ACCC4BE7894B8E1280C50B53'),(6473,'a','start()    ','CFDF209AC9C147ADAA00CE3B89365063'),(6474,'b','init()    ','CFDF209AC9C147ADAA00CE3B89365063'),(6475,'c','run()    ','CFDF209AC9C147ADAA00CE3B89365063'),(6476,'d','main()  ','CFDF209AC9C147ADAA00CE3B89365063'),(6477,'a','sleep方法 ','7ED13A90A5E34B73A766B23C1F0C11AA'),(6478,'b','IO等待 ','7ED13A90A5E34B73A766B23C1F0C11AA'),(6479,'c','yield方法 ','7ED13A90A5E34B73A766B23C1F0C11AA'),(6480,'d','wait方法 ','7ED13A90A5E34B73A766B23C1F0C11AA'),(6481,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','33826A86CBF94E76B700F60AD89095BF'),(6482,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','33826A86CBF94E76B700F60AD89095BF'),(6483,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','33826A86CBF94E76B700F60AD89095BF'),(6484,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','33826A86CBF94E76B700F60AD89095BF'),(6485,'a','编译错误 ','0299E16829EB473F86EE48E22507392A'),(6486,'b','实现向文件record.dat追加写入字符a ','0299E16829EB473F86EE48E22507392A'),(6487,'c','实现向文件record.dat覆盖写入字符a ','0299E16829EB473F86EE48E22507392A'),(6488,'d','文件record.dat无任何内容 ','0299E16829EB473F86EE48E22507392A'),(6489,'a','Output is null.             ','489788BA73894390B508732C250373F3'),(6490,'b','Output is 0 ','489788BA73894390B508732C250373F3'),(6491,'c','编译时报错 ','489788BA73894390B508732C250373F3'),(6492,'d','运行时报错','489788BA73894390B508732C250373F3'),(6493,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','167C1305788C46FCABD8D296563274AA'),(6494,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','167C1305788C46FCABD8D296563274AA'),(6495,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','167C1305788C46FCABD8D296563274AA'),(6496,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','167C1305788C46FCABD8D296563274AA'),(6497,'a','Output is null.             ','AEAA6705843A42FE9B935AA76736D75E'),(6498,'b','Output is 0 ','AEAA6705843A42FE9B935AA76736D75E'),(6499,'c','编译时报错 ','AEAA6705843A42FE9B935AA76736D75E'),(6500,'d','运行时报错','AEAA6705843A42FE9B935AA76736D75E'),(6501,'a','s>>>=3   ','A8C158F95DEF44FF87D4805613DCCA05'),(6502,'b','s[3]= “X”  ','A8C158F95DEF44FF87D4805613DCCA05'),(6503,'c','int i = s.length()   ','A8C158F95DEF44FF87D4805613DCCA05'),(6504,'d','s = s + 10 ','A8C158F95DEF44FF87D4805613DCCA05'),(6505,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','BC40F65384954721B7F35CE058DC2070'),(6506,'b','垃圾收集将检查并释放不在使用的内存  ','BC40F65384954721B7F35CE058DC2070'),(6507,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','BC40F65384954721B7F35CE058DC2070'),(6508,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','BC40F65384954721B7F35CE058DC2070'),(6509,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','E8A9CABCE48F44FDB8660AF66F9CD579'),(6510,'b','垃圾收集将检查并释放不在使用的内存  ','E8A9CABCE48F44FDB8660AF66F9CD579'),(6511,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','E8A9CABCE48F44FDB8660AF66F9CD579'),(6512,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','E8A9CABCE48F44FDB8660AF66F9CD579'),(6513,'a','输出Exception ','A7CD4554B61F45AE8C3CB6EF8F1E859F'),(6514,'b','输出A,B,Exception ','A7CD4554B61F45AE8C3CB6EF8F1E859F'),(6515,'c','编译失败 ','A7CD4554B61F45AE8C3CB6EF8F1E859F'),(6516,'d','在运行时抛出NullPointerException异常 ','A7CD4554B61F45AE8C3CB6EF8F1E859F'),(6517,'a','编译错误 ','7736CC6C00C747D9A3B37296533358F8'),(6518,'b','程序可以通过编译，运行后文件company.txt没有任何改变','7736CC6C00C747D9A3B37296533358F8'),(6519,'c','程序可以通过编译，运行后文件company.txt的长度变为0','7736CC6C00C747D9A3B37296533358F8'),(6520,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','7736CC6C00C747D9A3B37296533358F8'),(6521,'a','输出：4 ','9E43F442CC244D75B12236BE6ED302B7'),(6522,'b','在运行时抛出NullPointerException异常 ','9E43F442CC244D75B12236BE6ED302B7'),(6523,'c','在运行时抛出NumberFormatException异常 ','9E43F442CC244D75B12236BE6ED302B7'),(6524,'d','在运行时抛出IllegalStateException异常 ','9E43F442CC244D75B12236BE6ED302B7'),(6525,'a','输出：4 ','6A7CBD3CF9DD4923A736F30B26C0F341'),(6526,'b','在运行时抛出NullPointerException异常 ','6A7CBD3CF9DD4923A736F30B26C0F341'),(6527,'c','在运行时抛出NumberFormatException异常 ','6A7CBD3CF9DD4923A736F30B26C0F341'),(6528,'d','在运行时抛出IllegalStateException异常 ','6A7CBD3CF9DD4923A736F30B26C0F341'),(6529,'a','private synchronized Object o; ','7A1067BE51724D56AD76B9A2DBFED6CD'),(6530,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','7A1067BE51724D56AD76B9A2DBFED6CD'),(6531,'c','public synchronized void go() { /* code here */ } ','7A1067BE51724D56AD76B9A2DBFED6CD'),(6532,'d','private synchronized(this) void go() { /* code here */ } ','7A1067BE51724D56AD76B9A2DBFED6CD'),(6533,'a','编译错误 ','E843E01A778B4E529EE11876783B61D6'),(6534,'b','抛出运行时异常 ','E843E01A778B4E529EE11876783B61D6'),(6535,'c','输出：bar ','E843E01A778B4E529EE11876783B61D6'),(6536,'d','代码正常运行，但是无输出 ','E843E01A778B4E529EE11876783B61D6'),(6537,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','63DE80D28D9E4134AB8122CDD21F3A27'),(6538,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','63DE80D28D9E4134AB8122CDD21F3A27'),(6539,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','63DE80D28D9E4134AB8122CDD21F3A27'),(6540,'d','new InputStreamReader(\"dat\") ; ','63DE80D28D9E4134AB8122CDD21F3A27'),(6541,'a','public void method( int m){...}     ','D4A41C347A0C4A92B7BB84DDA41ADC40'),(6542,'b','public int method(){...} ','D4A41C347A0C4A92B7BB84DDA41ADC40'),(6543,'c','public void method2(){...}    ','D4A41C347A0C4A92B7BB84DDA41ADC40'),(6544,'d','public int method(int m，float f ){...} ','D4A41C347A0C4A92B7BB84DDA41ADC40'),(6545,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','DA658CDFA0EA4008A43FF6B5C8F18337'),(6546,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','DA658CDFA0EA4008A43FF6B5C8F18337'),(6547,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','DA658CDFA0EA4008A43FF6B5C8F18337'),(6548,'d','new InputStreamReader(\"1.dat\") ; ','DA658CDFA0EA4008A43FF6B5C8F18337'),(6549,'a','InputStreamReader','96EF4A0B490C4290914DDAC8D05AF71A'),(6550,'b','BufferedReader','96EF4A0B490C4290914DDAC8D05AF71A'),(6551,'c','FileInputStream','96EF4A0B490C4290914DDAC8D05AF71A'),(6552,'d','InputStream','96EF4A0B490C4290914DDAC8D05AF71A'),(6553,'a','编译错误 ','5A66BF0CE99F45AA86BCA1699BB63B71'),(6554,'b','程序可以通过编译，运行后文件company.txt没有任何改变','5A66BF0CE99F45AA86BCA1699BB63B71'),(6555,'c','程序可以通过编译，运行后文件company.txt的长度变为0','5A66BF0CE99F45AA86BCA1699BB63B71'),(6556,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','5A66BF0CE99F45AA86BCA1699BB63B71'),(6557,'a','一旦一个线程被创建，它就立即开始运行。  ','40885C34DB05481FB4269E64A982B194'),(6558,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','40885C34DB05481FB4269E64A982B194'),(6559,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','40885C34DB05481FB4269E64A982B194'),(6560,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','40885C34DB05481FB4269E64A982B194'),(6561,'a','第3行抛出异常 ','195C9E8E3A51477687A7D71BB2EB1F84'),(6562,'b','第1行抛出异常 ','195C9E8E3A51477687A7D71BB2EB1F84'),(6563,'c','第5行抛出异常 ','195C9E8E3A51477687A7D71BB2EB1F84'),(6564,'d','第3行代码成功执行 ','195C9E8E3A51477687A7D71BB2EB1F84'),(6565,'a','编译错误 ','F64E7F4C040C4863ADE8A76716B5069F'),(6566,'b','抛出运行时异常 ','F64E7F4C040C4863ADE8A76716B5069F'),(6567,'c','输出：bar ','F64E7F4C040C4863ADE8A76716B5069F'),(6568,'d','代码正常运行，但是无输出 ','F64E7F4C040C4863ADE8A76716B5069F'),(6569,'a','输出Exception ','A2BDA62415F3495DA7BF416B26FACF04'),(6570,'b','输出A,B,Exception ','A2BDA62415F3495DA7BF416B26FACF04'),(6571,'c','编译失败 ','A2BDA62415F3495DA7BF416B26FACF04'),(6572,'d','在运行时抛出NullPointerException异常 ','A2BDA62415F3495DA7BF416B26FACF04'),(6573,'a','第3行抛出异常 ','C2E31B5A2299479EB316899E28AAC73C'),(6574,'b','第1行抛出异常 ','C2E31B5A2299479EB316899E28AAC73C'),(6575,'c','第5行抛出异常 ','C2E31B5A2299479EB316899E28AAC73C'),(6576,'d','第3行代码成功执行 ','C2E31B5A2299479EB316899E28AAC73C'),(6577,'a','编译错误 ','AAB10F8D7C7940EC9B91ED5C07E7FD57'),(6578,'b','抛出运行时异常 ','AAB10F8D7C7940EC9B91ED5C07E7FD57'),(6579,'c','输出：bar ','AAB10F8D7C7940EC9B91ED5C07E7FD57'),(6580,'d','代码正常运行，但是无输出 ','AAB10F8D7C7940EC9B91ED5C07E7FD57'),(6581,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','FF9F91C6DE7C4F70B25A30900DB69D3E'),(6582,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','FF9F91C6DE7C4F70B25A30900DB69D3E'),(6583,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','FF9F91C6DE7C4F70B25A30900DB69D3E'),(6584,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','FF9F91C6DE7C4F70B25A30900DB69D3E'),(6585,'a','public void method( int m){...}     ','5904376E0FEB4D19962CDC61B5E83D00'),(6586,'b','public int method(){...} ','5904376E0FEB4D19962CDC61B5E83D00'),(6587,'c','public void method2(){...}    ','5904376E0FEB4D19962CDC61B5E83D00'),(6588,'d','public int method(int m，float f ){...} ','5904376E0FEB4D19962CDC61B5E83D00'),(6589,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','254C0048C836445AAC8CF2F05E896957'),(6590,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','254C0048C836445AAC8CF2F05E896957'),(6591,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','254C0048C836445AAC8CF2F05E896957'),(6592,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','254C0048C836445AAC8CF2F05E896957'),(6593,'a','m.length()    ','7C9BB443AC7D41B7A3049CB978D5F984'),(6594,'b','m.length   ','7C9BB443AC7D41B7A3049CB978D5F984'),(6595,'c','m.length()+1   ','7C9BB443AC7D41B7A3049CB978D5F984'),(6596,'d','m.length-1','7C9BB443AC7D41B7A3049CB978D5F984'),(6597,'a','编译错误 ','44967D1672CB49C2ACB62C2A9E264DA4'),(6598,'b','实现向文件record.dat追加写入字符a ','44967D1672CB49C2ACB62C2A9E264DA4'),(6599,'c','实现向文件record.dat覆盖写入字符a ','44967D1672CB49C2ACB62C2A9E264DA4'),(6600,'d','文件record.dat无任何内容 ','44967D1672CB49C2ACB62C2A9E264DA4'),(6601,'a','Output is null.             ','014E8A798851424C9F8EB15B1D3EF004'),(6602,'b','Output is 0 ','014E8A798851424C9F8EB15B1D3EF004'),(6603,'c','编译时报错 ','014E8A798851424C9F8EB15B1D3EF004'),(6604,'d','运行时报错','014E8A798851424C9F8EB15B1D3EF004'),(6605,'a','编译错误 ','789AA087285040E8A654170258E693CA'),(6606,'b','抛出运行时异常 ','789AA087285040E8A654170258E693CA'),(6607,'c','输出：sleep ','789AA087285040E8A654170258E693CA'),(6608,'d','代码正常运行，但是无输出 ','789AA087285040E8A654170258E693CA'),(6609,'a','5.0','BEC05EC41F6D423F8F42BA058CAFE4A6'),(6610,'b','4.0','BEC05EC41F6D423F8F42BA058CAFE4A6'),(6611,'c','6.0','BEC05EC41F6D423F8F42BA058CAFE4A6'),(6612,'d','finished','BEC05EC41F6D423F8F42BA058CAFE4A6'),(6613,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','988A4504583D463B954CB26D7AB138DA'),(6614,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','988A4504583D463B954CB26D7AB138DA'),(6615,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','988A4504583D463B954CB26D7AB138DA'),(6616,'d','new InputStreamReader(\"dat\") ; ','988A4504583D463B954CB26D7AB138DA'),(6617,'a','名为dtThread的线程为守护线程 ','B241A08F2AC948449075C5E5C0E818CB'),(6618,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','B241A08F2AC948449075C5E5C0E818CB'),(6619,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','B241A08F2AC948449075C5E5C0E818CB'),(6620,'d','main线程是守护线程 ','B241A08F2AC948449075C5E5C0E818CB'),(6621,'a','start()    ','4D0C6E8D8EFA468BB0CD1C4274576553'),(6622,'b','init()    ','4D0C6E8D8EFA468BB0CD1C4274576553'),(6623,'c','run()    ','4D0C6E8D8EFA468BB0CD1C4274576553'),(6624,'d','main()  ','4D0C6E8D8EFA468BB0CD1C4274576553'),(6625,'a','将private int m改为 protected int m  ','A77262B0AF5740DB87C9A51FE4911E16'),(6626,'b','将private int m改为 public int m    ','A77262B0AF5740DB87C9A51FE4911E16'),(6627,'c','将private int m改为 static int m     ','A77262B0AF5740DB87C9A51FE4911E16'),(6628,'d','将private int m改为int m ','A77262B0AF5740DB87C9A51FE4911E16'),(6629,'a','输出：4 ','61D69936A43F41FAB8796932AC9D115D'),(6630,'b','在运行时抛出NullPointerException异常 ','61D69936A43F41FAB8796932AC9D115D'),(6631,'c','在运行时抛出NumberFormatException异常 ','61D69936A43F41FAB8796932AC9D115D'),(6632,'d','在运行时抛出IllegalStateException异常 ','61D69936A43F41FAB8796932AC9D115D'),(6633,'a','输出：test ','C427D5723A7A43D9A9C11B98994CA1A6'),(6634,'b','输出：Exception ','C427D5723A7A43D9A9C11B98994CA1A6'),(6635,'c','编译失败 ','C427D5723A7A43D9A9C11B98994CA1A6'),(6636,'d','输出：NullPointerException ','C427D5723A7A43D9A9C11B98994CA1A6'),(6637,'a','通过调用stop()方法而停止的线程。 ','1DAB54B841644A20BD0CE37C7024FF1E'),(6638,'b','通过调用sleep()方法而停止的线程。 ','1DAB54B841644A20BD0CE37C7024FF1E'),(6639,'c','通过调用wait()方法而停止的线程。 ','1DAB54B841644A20BD0CE37C7024FF1E'),(6640,'d','通过调用suspend()方法而停止的线程。 ','1DAB54B841644A20BD0CE37C7024FF1E'),(6641,'a','通过调用stop()方法而停止的线程。 ','8E5BBA0B691048C683966FF703BA6E07'),(6642,'b','通过调用sleep()方法而停止的线程。 ','8E5BBA0B691048C683966FF703BA6E07'),(6643,'c','通过调用wait()方法而停止的线程。 ','8E5BBA0B691048C683966FF703BA6E07'),(6644,'d','通过调用suspend()方法而停止的线程。 ','8E5BBA0B691048C683966FF703BA6E07'),(6645,'a','const   ','9731F99B9C4A4110B8F5829407E29481'),(6646,'b','NULL  ','9731F99B9C4A4110B8F5829407E29481'),(6647,'c','false   ','9731F99B9C4A4110B8F5829407E29481'),(6648,'d','this  ','9731F99B9C4A4110B8F5829407E29481'),(6649,'a','编译错误 ','D9E8856D46EA40F58B247109E2BEB758'),(6650,'b','实现向文件record.dat追加写入字符a ','D9E8856D46EA40F58B247109E2BEB758'),(6651,'c','实现向文件record.dat覆盖写入字符a ','D9E8856D46EA40F58B247109E2BEB758'),(6652,'d','文件record.dat无任何内容 ','D9E8856D46EA40F58B247109E2BEB758'),(6653,'a','sleep方法 ','E020D6EFC3B5417684331BD792869938'),(6654,'b','IO等待 ','E020D6EFC3B5417684331BD792869938'),(6655,'c','yield方法 ','E020D6EFC3B5417684331BD792869938'),(6656,'d','wait方法 ','E020D6EFC3B5417684331BD792869938'),(6657,'a','输出：test ','094EC8B8D038495EA86724EA0CFBC8E6'),(6658,'b','输出：Exception ','094EC8B8D038495EA86724EA0CFBC8E6'),(6659,'c','编译失败 ','094EC8B8D038495EA86724EA0CFBC8E6'),(6660,'d','输出：NullPointerException ','094EC8B8D038495EA86724EA0CFBC8E6'),(6661,'a','long 1 = 4990  ','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(6662,'b','int i = 4L  ','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(6663,'c','float f =1.1  ','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(6664,'d','double d = 34.4','B8703E28F1824FBFAB97FE0D5F7AB1AC'),(6665,'a','名为dtThread的线程为守护线程 ','281B19C9F69D47C59305436EB36A633C'),(6666,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','281B19C9F69D47C59305436EB36A633C'),(6667,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','281B19C9F69D47C59305436EB36A633C'),(6668,'d','main线程是守护线程 ','281B19C9F69D47C59305436EB36A633C'),(6669,'a','m.length()    ','66B11088551247C1924DF310A1641786'),(6670,'b','m.length   ','66B11088551247C1924DF310A1641786'),(6671,'c','m.length()+1   ','66B11088551247C1924DF310A1641786'),(6672,'d','m.length-1','66B11088551247C1924DF310A1641786'),(6673,'a','编译错误 ','709B464AAA3647358F69D68D509EA8E3'),(6674,'b','实现向文件record.dat追加写入字符a ','709B464AAA3647358F69D68D509EA8E3'),(6675,'c','实现向文件record.dat覆盖写入字符a ','709B464AAA3647358F69D68D509EA8E3'),(6676,'d','文件record.dat无任何内容 ','709B464AAA3647358F69D68D509EA8E3'),(6677,'a','const   ','58552B603604403A958B9DA4495C11D8'),(6678,'b','NULL  ','58552B603604403A958B9DA4495C11D8'),(6679,'c','false   ','58552B603604403A958B9DA4495C11D8'),(6680,'d','this  ','58552B603604403A958B9DA4495C11D8'),(6681,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','EA9CC06D7373460D9678ECA2894E64AA'),(6682,'b','垃圾收集将检查并释放不在使用的内存  ','EA9CC06D7373460D9678ECA2894E64AA'),(6683,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','EA9CC06D7373460D9678ECA2894E64AA'),(6684,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','EA9CC06D7373460D9678ECA2894E64AA'),(6685,'a','private synchronized Object o; ','2D9BE9797C2245D7B1DB8E09C6ACEB53'),(6686,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','2D9BE9797C2245D7B1DB8E09C6ACEB53'),(6687,'c','public synchronized void go() { /* code here */ } ','2D9BE9797C2245D7B1DB8E09C6ACEB53'),(6688,'d','private synchronized(this) void go() { /* code here */ } ','2D9BE9797C2245D7B1DB8E09C6ACEB53'),(6689,'a','输出：test ','DFAEAD70CF24459AA6F0C3223111B42B'),(6690,'b','输出：Exception ','DFAEAD70CF24459AA6F0C3223111B42B'),(6691,'c','编译失败 ','DFAEAD70CF24459AA6F0C3223111B42B'),(6692,'d','输出：NullPointerException ','DFAEAD70CF24459AA6F0C3223111B42B'),(6693,'a','将private int m改为 protected int m  ','73E3DD9CD09C437AB61941BAE111767E'),(6694,'b','将private int m改为 public int m    ','73E3DD9CD09C437AB61941BAE111767E'),(6695,'c','将private int m改为 static int m     ','73E3DD9CD09C437AB61941BAE111767E'),(6696,'d','将private int m改为int m ','73E3DD9CD09C437AB61941BAE111767E'),(6697,'a','编译错误 ','D909313558454382A29345276AAB284E'),(6698,'b','实现向文件record.dat追加写入字符a ','D909313558454382A29345276AAB284E'),(6699,'c','实现向文件record.dat覆盖写入字符a ','D909313558454382A29345276AAB284E'),(6700,'d','文件record.dat无任何内容 ','D909313558454382A29345276AAB284E'),(6701,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','66684A524E94456C967B1DE167DC0CFB'),(6702,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','66684A524E94456C967B1DE167DC0CFB'),(6703,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','66684A524E94456C967B1DE167DC0CFB'),(6704,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','66684A524E94456C967B1DE167DC0CFB'),(6705,'a','编译错误 ','B8A918ABED9F444A844BE17CBB2C8639'),(6706,'b','程序可以通过编译，运行后文件company.txt没有任何改变','B8A918ABED9F444A844BE17CBB2C8639'),(6707,'c','程序可以通过编译，运行后文件company.txt的长度变为0','B8A918ABED9F444A844BE17CBB2C8639'),(6708,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','B8A918ABED9F444A844BE17CBB2C8639'),(6709,'a','sleep方法 ','E9D73490F69F4DF6B653181BEC8E8F24'),(6710,'b','IO等待 ','E9D73490F69F4DF6B653181BEC8E8F24'),(6711,'c','yield方法 ','E9D73490F69F4DF6B653181BEC8E8F24'),(6712,'d','wait方法 ','E9D73490F69F4DF6B653181BEC8E8F24'),(6713,'a','第3行抛出异常 ','3E6945401C5D485F8323E8CDFE5E9493'),(6714,'b','第1行抛出异常 ','3E6945401C5D485F8323E8CDFE5E9493'),(6715,'c','第5行抛出异常 ','3E6945401C5D485F8323E8CDFE5E9493'),(6716,'d','第3行代码成功执行 ','3E6945401C5D485F8323E8CDFE5E9493'),(6717,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','4A88DE2F3B1946A489889028214E14D0'),(6718,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','4A88DE2F3B1946A489889028214E14D0'),(6719,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','4A88DE2F3B1946A489889028214E14D0'),(6720,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','4A88DE2F3B1946A489889028214E14D0'),(6721,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','01A46533ED594CE49940A246AF19B1A6'),(6722,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','01A46533ED594CE49940A246AF19B1A6'),(6723,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','01A46533ED594CE49940A246AF19B1A6'),(6724,'d','new InputStreamReader(\"1.dat\") ; ','01A46533ED594CE49940A246AF19B1A6'),(6725,'a','s>>>=3   ','866AA7190E484BEAAF35BFA62177E6E9'),(6726,'b','s[3]= “X”  ','866AA7190E484BEAAF35BFA62177E6E9'),(6727,'c','int i = s.length()   ','866AA7190E484BEAAF35BFA62177E6E9'),(6728,'d','s = s + 10 ','866AA7190E484BEAAF35BFA62177E6E9'),(6729,'a','m.length()    ','B2D5668D6F094EC196253CA62154F829'),(6730,'b','m.length   ','B2D5668D6F094EC196253CA62154F829'),(6731,'c','m.length()+1   ','B2D5668D6F094EC196253CA62154F829'),(6732,'d','m.length-1','B2D5668D6F094EC196253CA62154F829'),(6733,'a','const   ','D387242B65A14D22B43371C16F8C9411'),(6734,'b','NULL  ','D387242B65A14D22B43371C16F8C9411'),(6735,'c','false   ','D387242B65A14D22B43371C16F8C9411'),(6736,'d','this  ','D387242B65A14D22B43371C16F8C9411'),(6737,'a','long 1 = 4990  ','18632F73C2844543B0C18A4322CA8339'),(6738,'b','int i = 4L  ','18632F73C2844543B0C18A4322CA8339'),(6739,'c','float f =1.1  ','18632F73C2844543B0C18A4322CA8339'),(6740,'d','double d = 34.4','18632F73C2844543B0C18A4322CA8339'),(6741,'a','栈是非线性结构        ','5740D06016464C47B7E7C107A30B7CB0'),(6742,'b','栈是一种树状结构 ','5740D06016464C47B7E7C107A30B7CB0'),(6743,'c','栈具有先进先出的特征  ','5740D06016464C47B7E7C107A30B7CB0'),(6744,'d','栈具有后进先出的特征 ','5740D06016464C47B7E7C107A30B7CB0'),(6745,'a','编译错误 ','09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(6746,'b','实现向文件record.dat追加写入字符a ','09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(6747,'c','实现向文件record.dat覆盖写入字符a ','09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(6748,'d','文件record.dat无任何内容 ','09558F6A4D1040AE8EFA3EB2EAE1D6A2'),(6749,'a','Output is null.             ','AAF89D30DF4143DEB7F23A931682BBC1'),(6750,'b','Output is 0 ','AAF89D30DF4143DEB7F23A931682BBC1'),(6751,'c','编译时报错 ','AAF89D30DF4143DEB7F23A931682BBC1'),(6752,'d','运行时报错','AAF89D30DF4143DEB7F23A931682BBC1'),(6753,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','40EFD49AB39747948D5F83176DCECCDA'),(6754,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','40EFD49AB39747948D5F83176DCECCDA'),(6755,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','40EFD49AB39747948D5F83176DCECCDA'),(6756,'d','new InputStreamReader(\"1.dat\") ; ','40EFD49AB39747948D5F83176DCECCDA'),(6757,'a','编译错误 ','2AE08401C159412CA3D1740681579A50'),(6758,'b','实现向文件record.dat追加写入字符a ','2AE08401C159412CA3D1740681579A50'),(6759,'c','实现向文件record.dat覆盖写入字符a ','2AE08401C159412CA3D1740681579A50'),(6760,'d','文件record.dat无任何内容 ','2AE08401C159412CA3D1740681579A50'),(6761,'a','一旦一个线程被创建，它就立即开始运行。  ','A6F99C70A86343DAB7670CA79FCCA63A'),(6762,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','A6F99C70A86343DAB7670CA79FCCA63A'),(6763,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','A6F99C70A86343DAB7670CA79FCCA63A'),(6764,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','A6F99C70A86343DAB7670CA79FCCA63A'),(6765,'a','5.0','98EF0AFE64F345369A76B641C32486F0'),(6766,'b','4.0','98EF0AFE64F345369A76B641C32486F0'),(6767,'c','6.0','98EF0AFE64F345369A76B641C32486F0'),(6768,'d','finished','98EF0AFE64F345369A76B641C32486F0'),(6769,'a','编译错误 ','379B0496E3A9438D8B7F6C9422666D51'),(6770,'b','抛出运行时异常 ','379B0496E3A9438D8B7F6C9422666D51'),(6771,'c','输出：sleep ','379B0496E3A9438D8B7F6C9422666D51'),(6772,'d','代码正常运行，但是无输出 ','379B0496E3A9438D8B7F6C9422666D51'),(6773,'a','start()    ','0B721D7D16F04592AA6F42749580D033'),(6774,'b','init()    ','0B721D7D16F04592AA6F42749580D033'),(6775,'c','run()    ','0B721D7D16F04592AA6F42749580D033'),(6776,'d','main()  ','0B721D7D16F04592AA6F42749580D033'),(6777,'a','sleep方法 ','EE1A413F380D4309BBFFF711A8648157'),(6778,'b','IO等待 ','EE1A413F380D4309BBFFF711A8648157'),(6779,'c','yield方法 ','EE1A413F380D4309BBFFF711A8648157'),(6780,'d','wait方法 ','EE1A413F380D4309BBFFF711A8648157'),(6781,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','B7A3FD0A53D44C839EFA0E045283B7D2'),(6782,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','B7A3FD0A53D44C839EFA0E045283B7D2'),(6783,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','B7A3FD0A53D44C839EFA0E045283B7D2'),(6784,'d','new InputStreamReader(\"dat\") ; ','B7A3FD0A53D44C839EFA0E045283B7D2'),(6785,'a','名为dtThread的线程为守护线程 ','157D8F6E86244589ABCE190C55E9E206'),(6786,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','157D8F6E86244589ABCE190C55E9E206'),(6787,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','157D8F6E86244589ABCE190C55E9E206'),(6788,'d','main线程是守护线程 ','157D8F6E86244589ABCE190C55E9E206'),(6789,'a','编译错误 ','5A4370DBC11A467F8F2B7DD7B12A02A8'),(6790,'b','抛出运行时异常 ','5A4370DBC11A467F8F2B7DD7B12A02A8'),(6791,'c','输出：sleep ','5A4370DBC11A467F8F2B7DD7B12A02A8'),(6792,'d','代码正常运行，但是无输出 ','5A4370DBC11A467F8F2B7DD7B12A02A8'),(6793,'a','public void method( int m){...}     ','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(6794,'b','public int method(){...} ','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(6795,'c','public void method2(){...}    ','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(6796,'d','public int method(int m，float f ){...} ','8E28A8F9497B4A19B0F2E28FC0B5EEA8'),(6797,'a','将private int m改为 protected int m  ','8FB8A3B925264124ADC086FE3BCCF07C'),(6798,'b','将private int m改为 public int m    ','8FB8A3B925264124ADC086FE3BCCF07C'),(6799,'c','将private int m改为 static int m     ','8FB8A3B925264124ADC086FE3BCCF07C'),(6800,'d','将private int m改为int m ','8FB8A3B925264124ADC086FE3BCCF07C'),(6801,'a','5.0','C1B926935A27482F8BDFD800A0E134E4'),(6802,'b','4.0','C1B926935A27482F8BDFD800A0E134E4'),(6803,'c','6.0','C1B926935A27482F8BDFD800A0E134E4'),(6804,'d','finished','C1B926935A27482F8BDFD800A0E134E4'),(6805,'a','s>>>=3   ','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(6806,'b','s[3]= “X”  ','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(6807,'c','int i = s.length()   ','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(6808,'d','s = s + 10 ','2FCFF2A9ECEB49869E3DC6173D8CEE63'),(6809,'a','栈是非线性结构        ','36328B1A27024DF5BF53EE86B0AFE395'),(6810,'b','栈是一种树状结构 ','36328B1A27024DF5BF53EE86B0AFE395'),(6811,'c','栈具有先进先出的特征  ','36328B1A27024DF5BF53EE86B0AFE395'),(6812,'d','栈具有后进先出的特征 ','36328B1A27024DF5BF53EE86B0AFE395'),(6813,'a','InputStreamReader','4E3F5523794448A682A9E45F720D337C'),(6814,'b','BufferedReader','4E3F5523794448A682A9E45F720D337C'),(6815,'c','FileInputStream','4E3F5523794448A682A9E45F720D337C'),(6816,'d','InputStream','4E3F5523794448A682A9E45F720D337C'),(6817,'a','InputStreamReader','AB86306982F64A30A843B32CC551A395'),(6818,'b','BufferedReader','AB86306982F64A30A843B32CC551A395'),(6819,'c','FileInputStream','AB86306982F64A30A843B32CC551A395'),(6820,'d','InputStream','AB86306982F64A30A843B32CC551A395'),(6821,'a','栈是非线性结构        ','0DEC67667703418A9D500A6AA492ECB5'),(6822,'b','栈是一种树状结构 ','0DEC67667703418A9D500A6AA492ECB5'),(6823,'c','栈具有先进先出的特征  ','0DEC67667703418A9D500A6AA492ECB5'),(6824,'d','栈具有后进先出的特征 ','0DEC67667703418A9D500A6AA492ECB5'),(6825,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','DE9FE12BDBE2439390748073206FD7A5'),(6826,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','DE9FE12BDBE2439390748073206FD7A5'),(6827,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','DE9FE12BDBE2439390748073206FD7A5'),(6828,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','DE9FE12BDBE2439390748073206FD7A5'),(6829,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','B6A9FDC67237424789850CDC62960F6F'),(6830,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','B6A9FDC67237424789850CDC62960F6F'),(6831,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','B6A9FDC67237424789850CDC62960F6F'),(6832,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','B6A9FDC67237424789850CDC62960F6F'),(6833,'a','栈是非线性结构        ','749BB2EA756F45EA81C7DF86DF55C4CE'),(6834,'b','栈是一种树状结构 ','749BB2EA756F45EA81C7DF86DF55C4CE'),(6835,'c','栈具有先进先出的特征  ','749BB2EA756F45EA81C7DF86DF55C4CE'),(6836,'d','栈具有后进先出的特征 ','749BB2EA756F45EA81C7DF86DF55C4CE'),(6837,'a','编译错误 ','39E6BC067CAE4D17AFC56F575DB28D62'),(6838,'b','实现向文件record.dat追加写入字符a ','39E6BC067CAE4D17AFC56F575DB28D62'),(6839,'c','实现向文件record.dat覆盖写入字符a ','39E6BC067CAE4D17AFC56F575DB28D62'),(6840,'d','文件record.dat无任何内容 ','39E6BC067CAE4D17AFC56F575DB28D62'),(6841,'a','InputStreamReader','5A7BC33966824788AAF68E077BF4B593'),(6842,'b','BufferedReader','5A7BC33966824788AAF68E077BF4B593'),(6843,'c','FileInputStream','5A7BC33966824788AAF68E077BF4B593'),(6844,'d','InputStream','5A7BC33966824788AAF68E077BF4B593'),(6845,'a','public void method( int m){...}     ','2C9E2DD1F915459EA056A5A349137FD6'),(6846,'b','public int method(){...} ','2C9E2DD1F915459EA056A5A349137FD6'),(6847,'c','public void method2(){...}    ','2C9E2DD1F915459EA056A5A349137FD6'),(6848,'d','public int method(int m，float f ){...} ','2C9E2DD1F915459EA056A5A349137FD6'),(6849,'a','一旦一个线程被创建，它就立即开始运行。  ','45CD38F7BB2C4E00B47734F25466E71D'),(6850,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','45CD38F7BB2C4E00B47734F25466E71D'),(6851,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','45CD38F7BB2C4E00B47734F25466E71D'),(6852,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','45CD38F7BB2C4E00B47734F25466E71D'),(6853,'a','start()    ','9688B22F8FD44D63980AEAC3A2F89B7F'),(6854,'b','init()    ','9688B22F8FD44D63980AEAC3A2F89B7F'),(6855,'c','run()    ','9688B22F8FD44D63980AEAC3A2F89B7F'),(6856,'d','main()  ','9688B22F8FD44D63980AEAC3A2F89B7F'),(6857,'a','编译错误 ','D172597C84C341F0866B539C4483B2E5'),(6858,'b','实现向文件record.dat追加写入字符a ','D172597C84C341F0866B539C4483B2E5'),(6859,'c','实现向文件record.dat覆盖写入字符a ','D172597C84C341F0866B539C4483B2E5'),(6860,'d','文件record.dat无任何内容 ','D172597C84C341F0866B539C4483B2E5'),(6861,'a','输出Exception ','00E6391CB1EE4A6BACCF7F7B72AB410E'),(6862,'b','输出A,B,Exception ','00E6391CB1EE4A6BACCF7F7B72AB410E'),(6863,'c','编译失败 ','00E6391CB1EE4A6BACCF7F7B72AB410E'),(6864,'d','在运行时抛出NullPointerException异常 ','00E6391CB1EE4A6BACCF7F7B72AB410E'),(6865,'a','一旦一个线程被创建，它就立即开始运行。  ','568BDC18AB1045E8813E099558FD496E'),(6866,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','568BDC18AB1045E8813E099558FD496E'),(6867,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','568BDC18AB1045E8813E099558FD496E'),(6868,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','568BDC18AB1045E8813E099558FD496E'),(6869,'a','Output is null.             ','C6B500BD927C41C88DB9D00BFD7AF0FE'),(6870,'b','Output is 0 ','C6B500BD927C41C88DB9D00BFD7AF0FE'),(6871,'c','编译时报错 ','C6B500BD927C41C88DB9D00BFD7AF0FE'),(6872,'d','运行时报错','C6B500BD927C41C88DB9D00BFD7AF0FE'),(6873,'a','s>>>=3   ','0788717DF9EE497C8BADC2D9A7E9D19F'),(6874,'b','s[3]= “X”  ','0788717DF9EE497C8BADC2D9A7E9D19F'),(6875,'c','int i = s.length()   ','0788717DF9EE497C8BADC2D9A7E9D19F'),(6876,'d','s = s + 10 ','0788717DF9EE497C8BADC2D9A7E9D19F'),(6877,'a','private synchronized Object o; ','6D63BDFF890D4ABDB9024BB9BA454AF9'),(6878,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','6D63BDFF890D4ABDB9024BB9BA454AF9'),(6879,'c','public synchronized void go() { /* code here */ } ','6D63BDFF890D4ABDB9024BB9BA454AF9'),(6880,'d','private synchronized(this) void go() { /* code here */ } ','6D63BDFF890D4ABDB9024BB9BA454AF9'),(6881,'a','编译错误 ','EAA46BF912CE4CCBA52FFCB463793446'),(6882,'b','实现向文件record.dat追加写入字符a ','EAA46BF912CE4CCBA52FFCB463793446'),(6883,'c','实现向文件record.dat覆盖写入字符a ','EAA46BF912CE4CCBA52FFCB463793446'),(6884,'d','文件record.dat无任何内容 ','EAA46BF912CE4CCBA52FFCB463793446'),(6885,'a','编译错误 ','06C4FDDABB98445A81483DB9CEE1AFEE'),(6886,'b','抛出运行时异常 ','06C4FDDABB98445A81483DB9CEE1AFEE'),(6887,'c','输出：sleep ','06C4FDDABB98445A81483DB9CEE1AFEE'),(6888,'d','代码正常运行，但是无输出 ','06C4FDDABB98445A81483DB9CEE1AFEE'),(6889,'a','栈是非线性结构        ','1A96EAC9928141F094CB921ADBD1B6AB'),(6890,'b','栈是一种树状结构 ','1A96EAC9928141F094CB921ADBD1B6AB'),(6891,'c','栈具有先进先出的特征  ','1A96EAC9928141F094CB921ADBD1B6AB'),(6892,'d','栈具有后进先出的特征 ','1A96EAC9928141F094CB921ADBD1B6AB'),(6893,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','53160599A2B34D3FBD1302AB2F9C6CF0'),(6894,'b','垃圾收集将检查并释放不在使用的内存  ','53160599A2B34D3FBD1302AB2F9C6CF0'),(6895,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','53160599A2B34D3FBD1302AB2F9C6CF0'),(6896,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','53160599A2B34D3FBD1302AB2F9C6CF0'),(6897,'a','编译错误 ','53077725492E4C7ABA5D53A5CDADD450'),(6898,'b','抛出运行时异常 ','53077725492E4C7ABA5D53A5CDADD450'),(6899,'c','输出：bar ','53077725492E4C7ABA5D53A5CDADD450'),(6900,'d','代码正常运行，但是无输出 ','53077725492E4C7ABA5D53A5CDADD450'),(6901,'a','编译错误 ','EF2C064FF3864D3388B7B8DFEB930BF8'),(6902,'b','程序可以通过编译，运行后文件company.txt没有任何改变','EF2C064FF3864D3388B7B8DFEB930BF8'),(6903,'c','程序可以通过编译，运行后文件company.txt的长度变为0','EF2C064FF3864D3388B7B8DFEB930BF8'),(6904,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','EF2C064FF3864D3388B7B8DFEB930BF8'),(6905,'a','start()    ','8F66DA2C47EA4C2385210F2F81178064'),(6906,'b','init()    ','8F66DA2C47EA4C2385210F2F81178064'),(6907,'c','run()    ','8F66DA2C47EA4C2385210F2F81178064'),(6908,'d','main()  ','8F66DA2C47EA4C2385210F2F81178064'),(6909,'a','第3行抛出异常 ','43603D2B89624DC99830BD1EE69C3730'),(6910,'b','第1行抛出异常 ','43603D2B89624DC99830BD1EE69C3730'),(6911,'c','第5行抛出异常 ','43603D2B89624DC99830BD1EE69C3730'),(6912,'d','第3行代码成功执行 ','43603D2B89624DC99830BD1EE69C3730'),(6913,'a','编译错误 ','81630083A38F49D0BE960AD6F062ACBD'),(6914,'b','实现向文件record.dat追加写入字符a ','81630083A38F49D0BE960AD6F062ACBD'),(6915,'c','实现向文件record.dat覆盖写入字符a ','81630083A38F49D0BE960AD6F062ACBD'),(6916,'d','文件record.dat无任何内容 ','81630083A38F49D0BE960AD6F062ACBD'),(6917,'a','long 1 = 4990  ','29A867228E2A435EB5B098E83FAB5889'),(6918,'b','int i = 4L  ','29A867228E2A435EB5B098E83FAB5889'),(6919,'c','float f =1.1  ','29A867228E2A435EB5B098E83FAB5889'),(6920,'d','double d = 34.4','29A867228E2A435EB5B098E83FAB5889'),(6921,'a','编译错误 ','BF0E49DD27164962897E2AB31605477D'),(6922,'b','实现向文件record.dat追加写入字符a ','BF0E49DD27164962897E2AB31605477D'),(6923,'c','实现向文件record.dat覆盖写入字符a ','BF0E49DD27164962897E2AB31605477D'),(6924,'d','文件record.dat无任何内容 ','BF0E49DD27164962897E2AB31605477D'),(6925,'a','输出：4 ','F2046F13400747ADB57821BA597C86A1'),(6926,'b','在运行时抛出NullPointerException异常 ','F2046F13400747ADB57821BA597C86A1'),(6927,'c','在运行时抛出NumberFormatException异常 ','F2046F13400747ADB57821BA597C86A1'),(6928,'d','在运行时抛出IllegalStateException异常 ','F2046F13400747ADB57821BA597C86A1'),(6929,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','C1619AB6ABCA428BBE2DB67FCA8A3232'),(6930,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','C1619AB6ABCA428BBE2DB67FCA8A3232'),(6931,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','C1619AB6ABCA428BBE2DB67FCA8A3232'),(6932,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','C1619AB6ABCA428BBE2DB67FCA8A3232'),(6933,'a','名为dtThread的线程为守护线程 ','266DAC8CF357407E9EF594744D49414E'),(6934,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','266DAC8CF357407E9EF594744D49414E'),(6935,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','266DAC8CF357407E9EF594744D49414E'),(6936,'d','main线程是守护线程 ','266DAC8CF357407E9EF594744D49414E'),(6937,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','9BE869101F7A4AEA9A75C927C78A984D'),(6938,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','9BE869101F7A4AEA9A75C927C78A984D'),(6939,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','9BE869101F7A4AEA9A75C927C78A984D'),(6940,'d','new InputStreamReader(\"dat\") ; ','9BE869101F7A4AEA9A75C927C78A984D'),(6941,'a','编译错误 ','FBE4320644EB4B7C9635A397DFA6D74A'),(6942,'b','程序可以通过编译，运行后文件company.txt没有任何改变','FBE4320644EB4B7C9635A397DFA6D74A'),(6943,'c','程序可以通过编译，运行后文件company.txt的长度变为0','FBE4320644EB4B7C9635A397DFA6D74A'),(6944,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','FBE4320644EB4B7C9635A397DFA6D74A'),(6945,'a','sleep方法 ','6561C61E1AC646EB88C22636AA6A1E0A'),(6946,'b','IO等待 ','6561C61E1AC646EB88C22636AA6A1E0A'),(6947,'c','yield方法 ','6561C61E1AC646EB88C22636AA6A1E0A'),(6948,'d','wait方法 ','6561C61E1AC646EB88C22636AA6A1E0A'),(6949,'a','long 1 = 4990  ','2F841EE0DFBF4C82A8D2AFF4619B6912'),(6950,'b','int i = 4L  ','2F841EE0DFBF4C82A8D2AFF4619B6912'),(6951,'c','float f =1.1  ','2F841EE0DFBF4C82A8D2AFF4619B6912'),(6952,'d','double d = 34.4','2F841EE0DFBF4C82A8D2AFF4619B6912'),(6953,'a','private synchronized Object o; ','FAB2F9E3E32A40A9BC43857BD6B97C00'),(6954,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','FAB2F9E3E32A40A9BC43857BD6B97C00'),(6955,'c','public synchronized void go() { /* code here */ } ','FAB2F9E3E32A40A9BC43857BD6B97C00'),(6956,'d','private synchronized(this) void go() { /* code here */ } ','FAB2F9E3E32A40A9BC43857BD6B97C00'),(6957,'a','输出：test ','E26645938F3545CCBD41E8C1CB3B6093'),(6958,'b','输出：Exception ','E26645938F3545CCBD41E8C1CB3B6093'),(6959,'c','编译失败 ','E26645938F3545CCBD41E8C1CB3B6093'),(6960,'d','输出：NullPointerException ','E26645938F3545CCBD41E8C1CB3B6093'),(6961,'a','InputStreamReader','2EF993C3309E41BCAF1ECA02A88AE421'),(6962,'b','BufferedReader','2EF993C3309E41BCAF1ECA02A88AE421'),(6963,'c','FileInputStream','2EF993C3309E41BCAF1ECA02A88AE421'),(6964,'d','InputStream','2EF993C3309E41BCAF1ECA02A88AE421'),(6965,'a','编译错误 ','54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(6966,'b','程序可以通过编译，运行后文件company.txt没有任何改变','54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(6967,'c','程序可以通过编译，运行后文件company.txt的长度变为0','54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(6968,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','54E4D2FD1B7F4EA0A75FE09DFE59DBBF'),(6969,'a','s>>>=3   ','B4FD0B66F64345DFB23A25256028E2A2'),(6970,'b','s[3]= “X”  ','B4FD0B66F64345DFB23A25256028E2A2'),(6971,'c','int i = s.length()   ','B4FD0B66F64345DFB23A25256028E2A2'),(6972,'d','s = s + 10 ','B4FD0B66F64345DFB23A25256028E2A2'),(6973,'a','const   ','1C0CF566310C45FF8F76F7FFDE05B2E8'),(6974,'b','NULL  ','1C0CF566310C45FF8F76F7FFDE05B2E8'),(6975,'c','false   ','1C0CF566310C45FF8F76F7FFDE05B2E8'),(6976,'d','this  ','1C0CF566310C45FF8F76F7FFDE05B2E8'),(6977,'a','long 1 = 4990  ','04192177F3B2401589AB65735D756D55'),(6978,'b','int i = 4L  ','04192177F3B2401589AB65735D756D55'),(6979,'c','float f =1.1  ','04192177F3B2401589AB65735D756D55'),(6980,'d','double d = 34.4','04192177F3B2401589AB65735D756D55'),(6981,'a','第3行抛出异常 ','FAB1E10EC3C048BAB84520D159612BAA'),(6982,'b','第1行抛出异常 ','FAB1E10EC3C048BAB84520D159612BAA'),(6983,'c','第5行抛出异常 ','FAB1E10EC3C048BAB84520D159612BAA'),(6984,'d','第3行代码成功执行 ','FAB1E10EC3C048BAB84520D159612BAA'),(6985,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','0D4F2426ECB14C88831F56D9FFBDA19B'),(6986,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','0D4F2426ECB14C88831F56D9FFBDA19B'),(6987,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','0D4F2426ECB14C88831F56D9FFBDA19B'),(6988,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','0D4F2426ECB14C88831F56D9FFBDA19B'),(6989,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','4483E7EBDD2945E88054262B69920F76'),(6990,'b','垃圾收集将检查并释放不在使用的内存  ','4483E7EBDD2945E88054262B69920F76'),(6991,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','4483E7EBDD2945E88054262B69920F76'),(6992,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','4483E7EBDD2945E88054262B69920F76'),(6993,'a','m.length()    ','44A7015B0C9E4DE7BFC397C4F88D158F'),(6994,'b','m.length   ','44A7015B0C9E4DE7BFC397C4F88D158F'),(6995,'c','m.length()+1   ','44A7015B0C9E4DE7BFC397C4F88D158F'),(6996,'d','m.length-1','44A7015B0C9E4DE7BFC397C4F88D158F'),(6997,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','3227122F1D3B4253937F3AC8BA98F55D'),(6998,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','3227122F1D3B4253937F3AC8BA98F55D'),(6999,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','3227122F1D3B4253937F3AC8BA98F55D'),(7000,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','3227122F1D3B4253937F3AC8BA98F55D'),(7001,'a','5.0','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(7002,'b','4.0','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(7003,'c','6.0','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(7004,'d','finished','4CE93DBFF1AC4C2FAB108B2E9DD1802D'),(7005,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','346488CE8EEF4D8D8E0041EA1657521F'),(7006,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','346488CE8EEF4D8D8E0041EA1657521F'),(7007,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','346488CE8EEF4D8D8E0041EA1657521F'),(7008,'d','new InputStreamReader(\"1.dat\") ; ','346488CE8EEF4D8D8E0041EA1657521F'),(7009,'a','第3行抛出异常 ','F3E2C829CD3E40D6BD08ABCB539DA5B5'),(7010,'b','第1行抛出异常 ','F3E2C829CD3E40D6BD08ABCB539DA5B5'),(7011,'c','第5行抛出异常 ','F3E2C829CD3E40D6BD08ABCB539DA5B5'),(7012,'d','第3行代码成功执行 ','F3E2C829CD3E40D6BD08ABCB539DA5B5'),(7013,'a','名为dtThread的线程为守护线程 ','D47B6D432BF74D69A2FF1B9059BCB0D4'),(7014,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','D47B6D432BF74D69A2FF1B9059BCB0D4'),(7015,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','D47B6D432BF74D69A2FF1B9059BCB0D4'),(7016,'d','main线程是守护线程 ','D47B6D432BF74D69A2FF1B9059BCB0D4'),(7017,'a','5.0','AC40FAC9FCD94D05ACF7502468A369B6'),(7018,'b','4.0','AC40FAC9FCD94D05ACF7502468A369B6'),(7019,'c','6.0','AC40FAC9FCD94D05ACF7502468A369B6'),(7020,'d','finished','AC40FAC9FCD94D05ACF7502468A369B6'),(7021,'a','将private int m改为 protected int m  ','66D0990F809C448EBDEF19B59496FFEC'),(7022,'b','将private int m改为 public int m    ','66D0990F809C448EBDEF19B59496FFEC'),(7023,'c','将private int m改为 static int m     ','66D0990F809C448EBDEF19B59496FFEC'),(7024,'d','将private int m改为int m ','66D0990F809C448EBDEF19B59496FFEC'),(7025,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','AAB7B4F0DCAF44B5A25602423671A4A0'),(7026,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','AAB7B4F0DCAF44B5A25602423671A4A0'),(7027,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','AAB7B4F0DCAF44B5A25602423671A4A0'),(7028,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','AAB7B4F0DCAF44B5A25602423671A4A0'),(7029,'a','将private int m改为 protected int m  ','6EC20CEF47054C1C80902F92550C91B1'),(7030,'b','将private int m改为 public int m    ','6EC20CEF47054C1C80902F92550C91B1'),(7031,'c','将private int m改为 static int m     ','6EC20CEF47054C1C80902F92550C91B1'),(7032,'d','将private int m改为int m ','6EC20CEF47054C1C80902F92550C91B1'),(7033,'a','通过调用stop()方法而停止的线程。 ','62CFC755832E43CC8636AC529CA8CC44'),(7034,'b','通过调用sleep()方法而停止的线程。 ','62CFC755832E43CC8636AC529CA8CC44'),(7035,'c','通过调用wait()方法而停止的线程。 ','62CFC755832E43CC8636AC529CA8CC44'),(7036,'d','通过调用suspend()方法而停止的线程。 ','62CFC755832E43CC8636AC529CA8CC44'),(7037,'a','一旦一个线程被创建，它就立即开始运行。  ','8510596130264C7FAC98B914569D3B27'),(7038,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','8510596130264C7FAC98B914569D3B27'),(7039,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','8510596130264C7FAC98B914569D3B27'),(7040,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','8510596130264C7FAC98B914569D3B27'),(7041,'a','sleep方法 ','49C7A54A42514EE8972F343F37F799E2'),(7042,'b','IO等待 ','49C7A54A42514EE8972F343F37F799E2'),(7043,'c','yield方法 ','49C7A54A42514EE8972F343F37F799E2'),(7044,'d','wait方法 ','49C7A54A42514EE8972F343F37F799E2'),(7045,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','A6B4F5F0C65442A69501AD63A919AC9A'),(7046,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','A6B4F5F0C65442A69501AD63A919AC9A'),(7047,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','A6B4F5F0C65442A69501AD63A919AC9A'),(7048,'d','new InputStreamReader(\"dat\") ; ','A6B4F5F0C65442A69501AD63A919AC9A'),(7049,'a','输出：test ','69441DA83D0748B38D7B1C1CD3AFBDFB'),(7050,'b','输出：Exception ','69441DA83D0748B38D7B1C1CD3AFBDFB'),(7051,'c','编译失败 ','69441DA83D0748B38D7B1C1CD3AFBDFB'),(7052,'d','输出：NullPointerException ','69441DA83D0748B38D7B1C1CD3AFBDFB'),(7053,'a','编译错误 ','1C7FA981148C41C89AF466BDC06FF914'),(7054,'b','抛出运行时异常 ','1C7FA981148C41C89AF466BDC06FF914'),(7055,'c','输出：sleep ','1C7FA981148C41C89AF466BDC06FF914'),(7056,'d','代码正常运行，但是无输出 ','1C7FA981148C41C89AF466BDC06FF914'),(7057,'a','将private int m改为 protected int m  ','CBA03C9AFACB47BA99F5C37C46AF980C'),(7058,'b','将private int m改为 public int m    ','CBA03C9AFACB47BA99F5C37C46AF980C'),(7059,'c','将private int m改为 static int m     ','CBA03C9AFACB47BA99F5C37C46AF980C'),(7060,'d','将private int m改为int m ','CBA03C9AFACB47BA99F5C37C46AF980C'),(7061,'a','m.length()    ','58B9E9AB34CE4DE3B726DD52DCE3548E'),(7062,'b','m.length   ','58B9E9AB34CE4DE3B726DD52DCE3548E'),(7063,'c','m.length()+1   ','58B9E9AB34CE4DE3B726DD52DCE3548E'),(7064,'d','m.length-1','58B9E9AB34CE4DE3B726DD52DCE3548E'),(7065,'a','Output is null.             ','0103F17EE62E497285EC7437477AF307'),(7066,'b','Output is 0 ','0103F17EE62E497285EC7437477AF307'),(7067,'c','编译时报错 ','0103F17EE62E497285EC7437477AF307'),(7068,'d','运行时报错','0103F17EE62E497285EC7437477AF307'),(7069,'a','输出：4 ','92107D02C994441BA78D6475FC3054A1'),(7070,'b','在运行时抛出NullPointerException异常 ','92107D02C994441BA78D6475FC3054A1'),(7071,'c','在运行时抛出NumberFormatException异常 ','92107D02C994441BA78D6475FC3054A1'),(7072,'d','在运行时抛出IllegalStateException异常 ','92107D02C994441BA78D6475FC3054A1'),(7073,'a','InputStreamReader','BF0A5E73F82745769147CDD7F322FB2C'),(7074,'b','BufferedReader','BF0A5E73F82745769147CDD7F322FB2C'),(7075,'c','FileInputStream','BF0A5E73F82745769147CDD7F322FB2C'),(7076,'d','InputStream','BF0A5E73F82745769147CDD7F322FB2C'),(7077,'a','Output is null.             ','F8FB56A58FDB4169AA60FEC42FA09383'),(7078,'b','Output is 0 ','F8FB56A58FDB4169AA60FEC42FA09383'),(7079,'c','编译时报错 ','F8FB56A58FDB4169AA60FEC42FA09383'),(7080,'d','运行时报错','F8FB56A58FDB4169AA60FEC42FA09383'),(7081,'a','编译错误 ','E9952F11B8C3415BA1609A2C27A1F61A'),(7082,'b','实现向文件record.dat追加写入字符a ','E9952F11B8C3415BA1609A2C27A1F61A'),(7083,'c','实现向文件record.dat覆盖写入字符a ','E9952F11B8C3415BA1609A2C27A1F61A'),(7084,'d','文件record.dat无任何内容 ','E9952F11B8C3415BA1609A2C27A1F61A'),(7085,'a','输出：test ','D5A4347BEE0C495C8AD0AD9E2DAA2722'),(7086,'b','输出：Exception ','D5A4347BEE0C495C8AD0AD9E2DAA2722'),(7087,'c','编译失败 ','D5A4347BEE0C495C8AD0AD9E2DAA2722'),(7088,'d','输出：NullPointerException ','D5A4347BEE0C495C8AD0AD9E2DAA2722'),(7089,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','7039626842984703B880F302A6610165'),(7090,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','7039626842984703B880F302A6610165'),(7091,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','7039626842984703B880F302A6610165'),(7092,'d','new InputStreamReader(\"1.dat\") ; ','7039626842984703B880F302A6610165'),(7093,'a','sleep方法 ','BBD768F6849C4F7BBD3DF8D44014696C'),(7094,'b','IO等待 ','BBD768F6849C4F7BBD3DF8D44014696C'),(7095,'c','yield方法 ','BBD768F6849C4F7BBD3DF8D44014696C'),(7096,'d','wait方法 ','BBD768F6849C4F7BBD3DF8D44014696C'),(7097,'a','编译错误 ','C238FC3B475B4B1B9BBCD1523BEEA0A9'),(7098,'b','抛出运行时异常 ','C238FC3B475B4B1B9BBCD1523BEEA0A9'),(7099,'c','输出：bar ','C238FC3B475B4B1B9BBCD1523BEEA0A9'),(7100,'d','代码正常运行，但是无输出 ','C238FC3B475B4B1B9BBCD1523BEEA0A9'),(7101,'a','编译错误 ','B5FE489BDF6B4D42932C9A01C977D569'),(7102,'b','抛出运行时异常 ','B5FE489BDF6B4D42932C9A01C977D569'),(7103,'c','输出：bar ','B5FE489BDF6B4D42932C9A01C977D569'),(7104,'d','代码正常运行，但是无输出 ','B5FE489BDF6B4D42932C9A01C977D569'),(7105,'a','栈是非线性结构        ','C1ED1AE40D7043F19E7D333333FA6952'),(7106,'b','栈是一种树状结构 ','C1ED1AE40D7043F19E7D333333FA6952'),(7107,'c','栈具有先进先出的特征  ','C1ED1AE40D7043F19E7D333333FA6952'),(7108,'d','栈具有后进先出的特征 ','C1ED1AE40D7043F19E7D333333FA6952'),(7109,'a','通过调用stop()方法而停止的线程。 ','DF8E33F93C30440A840D498AF2E4F56C'),(7110,'b','通过调用sleep()方法而停止的线程。 ','DF8E33F93C30440A840D498AF2E4F56C'),(7111,'c','通过调用wait()方法而停止的线程。 ','DF8E33F93C30440A840D498AF2E4F56C'),(7112,'d','通过调用suspend()方法而停止的线程。 ','DF8E33F93C30440A840D498AF2E4F56C'),(7113,'a','s>>>=3   ','10CB3A260EC24B4F9A73F5C6E73E30F0'),(7114,'b','s[3]= “X”  ','10CB3A260EC24B4F9A73F5C6E73E30F0'),(7115,'c','int i = s.length()   ','10CB3A260EC24B4F9A73F5C6E73E30F0'),(7116,'d','s = s + 10 ','10CB3A260EC24B4F9A73F5C6E73E30F0'),(7117,'a','编译错误 ','A15C848F87C54EA9A608CED45093462F'),(7118,'b','抛出运行时异常 ','A15C848F87C54EA9A608CED45093462F'),(7119,'c','输出：sleep ','A15C848F87C54EA9A608CED45093462F'),(7120,'d','代码正常运行，但是无输出 ','A15C848F87C54EA9A608CED45093462F'),(7121,'a','输出Exception ','C17AA689F2424E9A9AFEB8190FA43458'),(7122,'b','输出A,B,Exception ','C17AA689F2424E9A9AFEB8190FA43458'),(7123,'c','编译失败 ','C17AA689F2424E9A9AFEB8190FA43458'),(7124,'d','在运行时抛出NullPointerException异常 ','C17AA689F2424E9A9AFEB8190FA43458'),(7125,'a','const   ','2972A4EFD72741BEA09835CFCF7252B1'),(7126,'b','NULL  ','2972A4EFD72741BEA09835CFCF7252B1'),(7127,'c','false   ','2972A4EFD72741BEA09835CFCF7252B1'),(7128,'d','this  ','2972A4EFD72741BEA09835CFCF7252B1'),(7129,'a','const   ','5285DA94409A45D6BE4433A67D94AE72'),(7130,'b','NULL  ','5285DA94409A45D6BE4433A67D94AE72'),(7131,'c','false   ','5285DA94409A45D6BE4433A67D94AE72'),(7132,'d','this  ','5285DA94409A45D6BE4433A67D94AE72'),(7133,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(7134,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(7135,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(7136,'d','new InputStreamReader(\"dat\") ; ','F0CC513AF3DC412EAFD8F4EFC38A3A2C'),(7137,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','22AA7B46E9CC4FF9A52C0D91F2531BA7'),(7138,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','22AA7B46E9CC4FF9A52C0D91F2531BA7'),(7139,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','22AA7B46E9CC4FF9A52C0D91F2531BA7'),(7140,'d','new InputStreamReader(\"1.dat\") ; ','22AA7B46E9CC4FF9A52C0D91F2531BA7'),(7141,'a','名为dtThread的线程为守护线程 ','7096A670872842DF935B5B2A7602156A'),(7142,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','7096A670872842DF935B5B2A7602156A'),(7143,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','7096A670872842DF935B5B2A7602156A'),(7144,'d','main线程是守护线程 ','7096A670872842DF935B5B2A7602156A'),(7145,'a','输出Exception ','0758F9F59E1946E3B274047C62015ADB'),(7146,'b','输出A,B,Exception ','0758F9F59E1946E3B274047C62015ADB'),(7147,'c','编译失败 ','0758F9F59E1946E3B274047C62015ADB'),(7148,'d','在运行时抛出NullPointerException异常 ','0758F9F59E1946E3B274047C62015ADB'),(7149,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','233169FAA7A244BCA1C4F30FEEAFD4BE'),(7150,'b','垃圾收集将检查并释放不在使用的内存  ','233169FAA7A244BCA1C4F30FEEAFD4BE'),(7151,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','233169FAA7A244BCA1C4F30FEEAFD4BE'),(7152,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','233169FAA7A244BCA1C4F30FEEAFD4BE'),(7153,'a','start()    ','17AD95CD9BC54FEA8CF08604C1EF8715'),(7154,'b','init()    ','17AD95CD9BC54FEA8CF08604C1EF8715'),(7155,'c','run()    ','17AD95CD9BC54FEA8CF08604C1EF8715'),(7156,'d','main()  ','17AD95CD9BC54FEA8CF08604C1EF8715'),(7157,'a','5.0','CF614B35CCE44E79A1259A752F6DE2FA'),(7158,'b','4.0','CF614B35CCE44E79A1259A752F6DE2FA'),(7159,'c','6.0','CF614B35CCE44E79A1259A752F6DE2FA'),(7160,'d','finished','CF614B35CCE44E79A1259A752F6DE2FA'),(7161,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','DCE44BE62D9A47EF8052023CA5CEA01A'),(7162,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','DCE44BE62D9A47EF8052023CA5CEA01A'),(7163,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','DCE44BE62D9A47EF8052023CA5CEA01A'),(7164,'d','new InputStreamReader(\"1.dat\") ; ','DCE44BE62D9A47EF8052023CA5CEA01A'),(7165,'a','输出Exception ','CFC744FF351F46DCB24368F04E696D44'),(7166,'b','输出A,B,Exception ','CFC744FF351F46DCB24368F04E696D44'),(7167,'c','编译失败 ','CFC744FF351F46DCB24368F04E696D44'),(7168,'d','在运行时抛出NullPointerException异常 ','CFC744FF351F46DCB24368F04E696D44'),(7169,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','6BD84423199644FC957A96F9D476DD42'),(7170,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','6BD84423199644FC957A96F9D476DD42'),(7171,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','6BD84423199644FC957A96F9D476DD42'),(7172,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','6BD84423199644FC957A96F9D476DD42'),(7173,'a','InputStreamReader','334F5C50917D4A3F9B535A64900CD18D'),(7174,'b','BufferedReader','334F5C50917D4A3F9B535A64900CD18D'),(7175,'c','FileInputStream','334F5C50917D4A3F9B535A64900CD18D'),(7176,'d','InputStream','334F5C50917D4A3F9B535A64900CD18D'),(7177,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','3788075215A14C04B495EB95BB4EADA2'),(7178,'b','垃圾收集将检查并释放不在使用的内存  ','3788075215A14C04B495EB95BB4EADA2'),(7179,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','3788075215A14C04B495EB95BB4EADA2'),(7180,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','3788075215A14C04B495EB95BB4EADA2'),(7181,'a','编译错误 ','E00157DEA9A04A18872B46BE84F13D94'),(7182,'b','抛出运行时异常 ','E00157DEA9A04A18872B46BE84F13D94'),(7183,'c','输出：sleep ','E00157DEA9A04A18872B46BE84F13D94'),(7184,'d','代码正常运行，但是无输出 ','E00157DEA9A04A18872B46BE84F13D94'),(7185,'a','编译错误 ','CE7677332D704CCFAAF1860B7B396296'),(7186,'b','抛出运行时异常 ','CE7677332D704CCFAAF1860B7B396296'),(7187,'c','输出：sleep ','CE7677332D704CCFAAF1860B7B396296'),(7188,'d','代码正常运行，但是无输出 ','CE7677332D704CCFAAF1860B7B396296'),(7189,'a','编译错误 ','1C3D9B50490F42B8A878F3B2DE1D45E2'),(7190,'b','实现向文件record.dat追加写入字符a ','1C3D9B50490F42B8A878F3B2DE1D45E2'),(7191,'c','实现向文件record.dat覆盖写入字符a ','1C3D9B50490F42B8A878F3B2DE1D45E2'),(7192,'d','文件record.dat无任何内容 ','1C3D9B50490F42B8A878F3B2DE1D45E2'),(7193,'a','编译错误 ','0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(7194,'b','程序可以通过编译，运行后文件company.txt没有任何改变','0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(7195,'c','程序可以通过编译，运行后文件company.txt的长度变为0','0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(7196,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','0797AC6FFCAC4E8D93F4CC2C3E5DC84B'),(7197,'a','sleep方法 ','BA073725DF8C439D801FB1901636DD57'),(7198,'b','IO等待 ','BA073725DF8C439D801FB1901636DD57'),(7199,'c','yield方法 ','BA073725DF8C439D801FB1901636DD57'),(7200,'d','wait方法 ','BA073725DF8C439D801FB1901636DD57'),(7201,'a','const   ','3A65C6D9B6AD43189E49E5ED6AC319CB'),(7202,'b','NULL  ','3A65C6D9B6AD43189E49E5ED6AC319CB'),(7203,'c','false   ','3A65C6D9B6AD43189E49E5ED6AC319CB'),(7204,'d','this  ','3A65C6D9B6AD43189E49E5ED6AC319CB'),(7205,'a','s>>>=3   ','005802D091E542519BFC003D0E2D2E39'),(7206,'b','s[3]= “X”  ','005802D091E542519BFC003D0E2D2E39'),(7207,'c','int i = s.length()   ','005802D091E542519BFC003D0E2D2E39'),(7208,'d','s = s + 10 ','005802D091E542519BFC003D0E2D2E39'),(7209,'a','m.length()    ','BAEBC257AB0045FC946236CD71F8AB3A'),(7210,'b','m.length   ','BAEBC257AB0045FC946236CD71F8AB3A'),(7211,'c','m.length()+1   ','BAEBC257AB0045FC946236CD71F8AB3A'),(7212,'d','m.length-1','BAEBC257AB0045FC946236CD71F8AB3A'),(7213,'a','start()    ','393D2E8FD028481E98AFE3DBB036177C'),(7214,'b','init()    ','393D2E8FD028481E98AFE3DBB036177C'),(7215,'c','run()    ','393D2E8FD028481E98AFE3DBB036177C'),(7216,'d','main()  ','393D2E8FD028481E98AFE3DBB036177C'),(7217,'a','名为dtThread的线程为守护线程 ','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(7218,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(7219,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(7220,'d','main线程是守护线程 ','C3539F7F7BEC4650BD1B3C9B1C7C0864'),(7221,'a','const   ','99A265F02E1B4F238F1171485A4E7DFA'),(7222,'b','NULL  ','99A265F02E1B4F238F1171485A4E7DFA'),(7223,'c','false   ','99A265F02E1B4F238F1171485A4E7DFA'),(7224,'d','this  ','99A265F02E1B4F238F1171485A4E7DFA'),(7225,'a','第3行抛出异常 ','0819BE7291624D0C8A8F0DF701EFBBA6'),(7226,'b','第1行抛出异常 ','0819BE7291624D0C8A8F0DF701EFBBA6'),(7227,'c','第5行抛出异常 ','0819BE7291624D0C8A8F0DF701EFBBA6'),(7228,'d','第3行代码成功执行 ','0819BE7291624D0C8A8F0DF701EFBBA6'),(7229,'a','long 1 = 4990  ','BB543D312AF84975AFB0615D833A236E'),(7230,'b','int i = 4L  ','BB543D312AF84975AFB0615D833A236E'),(7231,'c','float f =1.1  ','BB543D312AF84975AFB0615D833A236E'),(7232,'d','double d = 34.4','BB543D312AF84975AFB0615D833A236E'),(7233,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','5E98C9F825FF4370BFA8FADE88BAD2DA'),(7234,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','5E98C9F825FF4370BFA8FADE88BAD2DA'),(7235,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','5E98C9F825FF4370BFA8FADE88BAD2DA'),(7236,'d','new InputStreamReader(\"dat\") ; ','5E98C9F825FF4370BFA8FADE88BAD2DA'),(7237,'a','栈是非线性结构        ','E81064F468FC4E27A2393FD79F7E9503'),(7238,'b','栈是一种树状结构 ','E81064F468FC4E27A2393FD79F7E9503'),(7239,'c','栈具有先进先出的特征  ','E81064F468FC4E27A2393FD79F7E9503'),(7240,'d','栈具有后进先出的特征 ','E81064F468FC4E27A2393FD79F7E9503'),(7241,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','2A2AD3907EE647BFBB0F60B90A9F1FED'),(7242,'b','垃圾收集将检查并释放不在使用的内存  ','2A2AD3907EE647BFBB0F60B90A9F1FED'),(7243,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','2A2AD3907EE647BFBB0F60B90A9F1FED'),(7244,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','2A2AD3907EE647BFBB0F60B90A9F1FED'),(7245,'a','第3行抛出异常 ','A6B39AED85044B269AD6D4610A5E594E'),(7246,'b','第1行抛出异常 ','A6B39AED85044B269AD6D4610A5E594E'),(7247,'c','第5行抛出异常 ','A6B39AED85044B269AD6D4610A5E594E'),(7248,'d','第3行代码成功执行 ','A6B39AED85044B269AD6D4610A5E594E'),(7249,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','1F751F03125F4385B745F6B2A50D4B75'),(7250,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','1F751F03125F4385B745F6B2A50D4B75'),(7251,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','1F751F03125F4385B745F6B2A50D4B75'),(7252,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','1F751F03125F4385B745F6B2A50D4B75'),(7253,'a','const   ','209D4121BDD74D738EEFF4243D813872'),(7254,'b','NULL  ','209D4121BDD74D738EEFF4243D813872'),(7255,'c','false   ','209D4121BDD74D738EEFF4243D813872'),(7256,'d','this  ','209D4121BDD74D738EEFF4243D813872'),(7257,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','0A09594770674B909158E12AC60DCDD6'),(7258,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','0A09594770674B909158E12AC60DCDD6'),(7259,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','0A09594770674B909158E12AC60DCDD6'),(7260,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','0A09594770674B909158E12AC60DCDD6'),(7261,'a','栈是非线性结构        ','19F96C702E0F44BBBD84E8A3554949D2'),(7262,'b','栈是一种树状结构 ','19F96C702E0F44BBBD84E8A3554949D2'),(7263,'c','栈具有先进先出的特征  ','19F96C702E0F44BBBD84E8A3554949D2'),(7264,'d','栈具有后进先出的特征 ','19F96C702E0F44BBBD84E8A3554949D2'),(7265,'a','编译错误 ','957A3EE7FC7042F2BC267DBA2205A448'),(7266,'b','抛出运行时异常 ','957A3EE7FC7042F2BC267DBA2205A448'),(7267,'c','输出：bar ','957A3EE7FC7042F2BC267DBA2205A448'),(7268,'d','代码正常运行，但是无输出 ','957A3EE7FC7042F2BC267DBA2205A448'),(7269,'a','start()    ','87A936136CF04C099C2577BDBBF2BE5E'),(7270,'b','init()    ','87A936136CF04C099C2577BDBBF2BE5E'),(7271,'c','run()    ','87A936136CF04C099C2577BDBBF2BE5E'),(7272,'d','main()  ','87A936136CF04C099C2577BDBBF2BE5E'),(7273,'a','通过调用stop()方法而停止的线程。 ','8F17415408FB486488BC09A48902016E'),(7274,'b','通过调用sleep()方法而停止的线程。 ','8F17415408FB486488BC09A48902016E'),(7275,'c','通过调用wait()方法而停止的线程。 ','8F17415408FB486488BC09A48902016E'),(7276,'d','通过调用suspend()方法而停止的线程。 ','8F17415408FB486488BC09A48902016E'),(7277,'a','编译错误 ','6942988593844717A912588376F9CCFB'),(7278,'b','实现向文件record.dat追加写入字符a ','6942988593844717A912588376F9CCFB'),(7279,'c','实现向文件record.dat覆盖写入字符a ','6942988593844717A912588376F9CCFB'),(7280,'d','文件record.dat无任何内容 ','6942988593844717A912588376F9CCFB'),(7281,'a','编译错误 ','5530964D6602461F8FE56F45791A3455'),(7282,'b','程序可以通过编译，运行后文件company.txt没有任何改变','5530964D6602461F8FE56F45791A3455'),(7283,'c','程序可以通过编译，运行后文件company.txt的长度变为0','5530964D6602461F8FE56F45791A3455'),(7284,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','5530964D6602461F8FE56F45791A3455'),(7285,'a','编译错误 ','CF5A8EA158EE4D82BC2DC7CE0084C03D'),(7286,'b','实现向文件record.dat追加写入字符a ','CF5A8EA158EE4D82BC2DC7CE0084C03D'),(7287,'c','实现向文件record.dat覆盖写入字符a ','CF5A8EA158EE4D82BC2DC7CE0084C03D'),(7288,'d','文件record.dat无任何内容 ','CF5A8EA158EE4D82BC2DC7CE0084C03D'),(7289,'a','输出：test ','D98520CFD5CE47AAAB11563B4F87C1C7'),(7290,'b','输出：Exception ','D98520CFD5CE47AAAB11563B4F87C1C7'),(7291,'c','编译失败 ','D98520CFD5CE47AAAB11563B4F87C1C7'),(7292,'d','输出：NullPointerException ','D98520CFD5CE47AAAB11563B4F87C1C7'),(7293,'a','m.length()    ','4D71AB4F57A1439285F72C8F606054A8'),(7294,'b','m.length   ','4D71AB4F57A1439285F72C8F606054A8'),(7295,'c','m.length()+1   ','4D71AB4F57A1439285F72C8F606054A8'),(7296,'d','m.length-1','4D71AB4F57A1439285F72C8F606054A8'),(7297,'a','5.0','9D8493807AC946228A02780FD7FC48B6'),(7298,'b','4.0','9D8493807AC946228A02780FD7FC48B6'),(7299,'c','6.0','9D8493807AC946228A02780FD7FC48B6'),(7300,'d','finished','9D8493807AC946228A02780FD7FC48B6'),(7301,'a','名为dtThread的线程为守护线程 ','4C96E244ECFA49BD9CE06FF1DF394B06'),(7302,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','4C96E244ECFA49BD9CE06FF1DF394B06'),(7303,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','4C96E244ECFA49BD9CE06FF1DF394B06'),(7304,'d','main线程是守护线程 ','4C96E244ECFA49BD9CE06FF1DF394B06'),(7305,'a','sleep方法 ','C20394955A17428495CE9F8CE8ECD17B'),(7306,'b','IO等待 ','C20394955A17428495CE9F8CE8ECD17B'),(7307,'c','yield方法 ','C20394955A17428495CE9F8CE8ECD17B'),(7308,'d','wait方法 ','C20394955A17428495CE9F8CE8ECD17B'),(7309,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','83CA050675FB4356BA1E6AA1FEB6610A'),(7310,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','83CA050675FB4356BA1E6AA1FEB6610A'),(7311,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','83CA050675FB4356BA1E6AA1FEB6610A'),(7312,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','83CA050675FB4356BA1E6AA1FEB6610A'),(7313,'a','InputStreamReader','2F0A0E2658D6413F8F964E96F766C6A8'),(7314,'b','BufferedReader','2F0A0E2658D6413F8F964E96F766C6A8'),(7315,'c','FileInputStream','2F0A0E2658D6413F8F964E96F766C6A8'),(7316,'d','InputStream','2F0A0E2658D6413F8F964E96F766C6A8'),(7317,'a','栈是非线性结构        ','7E2DD2FC2C3B43C1AF53250B313D439D'),(7318,'b','栈是一种树状结构 ','7E2DD2FC2C3B43C1AF53250B313D439D'),(7319,'c','栈具有先进先出的特征  ','7E2DD2FC2C3B43C1AF53250B313D439D'),(7320,'d','栈具有后进先出的特征 ','7E2DD2FC2C3B43C1AF53250B313D439D'),(7321,'a','输出Exception ','E53714C0994746ADB2F291736C1EB2E8'),(7322,'b','输出A,B,Exception ','E53714C0994746ADB2F291736C1EB2E8'),(7323,'c','编译失败 ','E53714C0994746ADB2F291736C1EB2E8'),(7324,'d','在运行时抛出NullPointerException异常 ','E53714C0994746ADB2F291736C1EB2E8'),(7325,'a','输出：test ','B755D9D1A6DE4D39A470D994B9992D0B'),(7326,'b','输出：Exception ','B755D9D1A6DE4D39A470D994B9992D0B'),(7327,'c','编译失败 ','B755D9D1A6DE4D39A470D994B9992D0B'),(7328,'d','输出：NullPointerException ','B755D9D1A6DE4D39A470D994B9992D0B'),(7329,'a','编译错误 ','93AEBD5A03DE40A081FAC479B064AA6A'),(7330,'b','抛出运行时异常 ','93AEBD5A03DE40A081FAC479B064AA6A'),(7331,'c','输出：bar ','93AEBD5A03DE40A081FAC479B064AA6A'),(7332,'d','代码正常运行，但是无输出 ','93AEBD5A03DE40A081FAC479B064AA6A'),(7333,'a','一旦一个线程被创建，它就立即开始运行。  ','31565EE2E3AB45B58F4C9032DE5F92A0'),(7334,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','31565EE2E3AB45B58F4C9032DE5F92A0'),(7335,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','31565EE2E3AB45B58F4C9032DE5F92A0'),(7336,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','31565EE2E3AB45B58F4C9032DE5F92A0'),(7337,'a','private synchronized Object o; ','CC3BA4021D4844C997650D81BAC9CDF5'),(7338,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','CC3BA4021D4844C997650D81BAC9CDF5'),(7339,'c','public synchronized void go() { /* code here */ } ','CC3BA4021D4844C997650D81BAC9CDF5'),(7340,'d','private synchronized(this) void go() { /* code here */ } ','CC3BA4021D4844C997650D81BAC9CDF5'),(7341,'a','名为dtThread的线程为守护线程 ','F7ACC12522434C32982E69D7CB36BB7D'),(7342,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','F7ACC12522434C32982E69D7CB36BB7D'),(7343,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','F7ACC12522434C32982E69D7CB36BB7D'),(7344,'d','main线程是守护线程 ','F7ACC12522434C32982E69D7CB36BB7D'),(7345,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','D393233A19904F8E8C05E08B03A6E065'),(7346,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','D393233A19904F8E8C05E08B03A6E065'),(7347,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','D393233A19904F8E8C05E08B03A6E065'),(7348,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','D393233A19904F8E8C05E08B03A6E065'),(7349,'a','输出：4 ','068F92537E9A4B6688FC5468D0F4488E'),(7350,'b','在运行时抛出NullPointerException异常 ','068F92537E9A4B6688FC5468D0F4488E'),(7351,'c','在运行时抛出NumberFormatException异常 ','068F92537E9A4B6688FC5468D0F4488E'),(7352,'d','在运行时抛出IllegalStateException异常 ','068F92537E9A4B6688FC5468D0F4488E'),(7353,'a','输出：4 ','5D9F07B342374D72BF0CA911D3BE6EF9'),(7354,'b','在运行时抛出NullPointerException异常 ','5D9F07B342374D72BF0CA911D3BE6EF9'),(7355,'c','在运行时抛出NumberFormatException异常 ','5D9F07B342374D72BF0CA911D3BE6EF9'),(7356,'d','在运行时抛出IllegalStateException异常 ','5D9F07B342374D72BF0CA911D3BE6EF9'),(7357,'a','5.0','1280DA32B07C4297BAAB3859C642CE1C'),(7358,'b','4.0','1280DA32B07C4297BAAB3859C642CE1C'),(7359,'c','6.0','1280DA32B07C4297BAAB3859C642CE1C'),(7360,'d','finished','1280DA32B07C4297BAAB3859C642CE1C'),(7361,'a','Output is null.             ','7F35566F68F442FE9FA50A03874BC5BC'),(7362,'b','Output is 0 ','7F35566F68F442FE9FA50A03874BC5BC'),(7363,'c','编译时报错 ','7F35566F68F442FE9FA50A03874BC5BC'),(7364,'d','运行时报错','7F35566F68F442FE9FA50A03874BC5BC'),(7365,'a','s>>>=3   ','5EA296E0B2394366992630E5E7EBAC92'),(7366,'b','s[3]= “X”  ','5EA296E0B2394366992630E5E7EBAC92'),(7367,'c','int i = s.length()   ','5EA296E0B2394366992630E5E7EBAC92'),(7368,'d','s = s + 10 ','5EA296E0B2394366992630E5E7EBAC92'),(7369,'a','private synchronized Object o; ','54A24ECB2F044D4995E456CBC98C34A9'),(7370,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','54A24ECB2F044D4995E456CBC98C34A9'),(7371,'c','public synchronized void go() { /* code here */ } ','54A24ECB2F044D4995E456CBC98C34A9'),(7372,'d','private synchronized(this) void go() { /* code here */ } ','54A24ECB2F044D4995E456CBC98C34A9'),(7373,'a','一旦一个线程被创建，它就立即开始运行。  ','DF8196C18EE9474F8F99C73E78C4882F'),(7374,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','DF8196C18EE9474F8F99C73E78C4882F'),(7375,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','DF8196C18EE9474F8F99C73E78C4882F'),(7376,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','DF8196C18EE9474F8F99C73E78C4882F'),(7377,'a','通过调用stop()方法而停止的线程。 ','FB80C4CC2B504CCB98837EA5F79261E7'),(7378,'b','通过调用sleep()方法而停止的线程。 ','FB80C4CC2B504CCB98837EA5F79261E7'),(7379,'c','通过调用wait()方法而停止的线程。 ','FB80C4CC2B504CCB98837EA5F79261E7'),(7380,'d','通过调用suspend()方法而停止的线程。 ','FB80C4CC2B504CCB98837EA5F79261E7'),(7381,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','3B126CEAD90A4CE5B172771566B43E58'),(7382,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','3B126CEAD90A4CE5B172771566B43E58'),(7383,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','3B126CEAD90A4CE5B172771566B43E58'),(7384,'d','new InputStreamReader(\"1.dat\") ; ','3B126CEAD90A4CE5B172771566B43E58'),(7385,'a','输出：test ','0C521B1F840C4F3EA961FA58D9BE1FEE'),(7386,'b','输出：Exception ','0C521B1F840C4F3EA961FA58D9BE1FEE'),(7387,'c','编译失败 ','0C521B1F840C4F3EA961FA58D9BE1FEE'),(7388,'d','输出：NullPointerException ','0C521B1F840C4F3EA961FA58D9BE1FEE'),(7389,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','A5739E94DBF34F1687AF7D70AF300FD4'),(7390,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','A5739E94DBF34F1687AF7D70AF300FD4'),(7391,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','A5739E94DBF34F1687AF7D70AF300FD4'),(7392,'d','new InputStreamReader(\"1.dat\") ; ','A5739E94DBF34F1687AF7D70AF300FD4'),(7393,'a','private synchronized Object o; ','16AD3C14ABC342EEAC474B7FA17118B1'),(7394,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','16AD3C14ABC342EEAC474B7FA17118B1'),(7395,'c','public synchronized void go() { /* code here */ } ','16AD3C14ABC342EEAC474B7FA17118B1'),(7396,'d','private synchronized(this) void go() { /* code here */ } ','16AD3C14ABC342EEAC474B7FA17118B1'),(7397,'a','输出：4 ','CF630409634242BBA9DEAE4E621B083E'),(7398,'b','在运行时抛出NullPointerException异常 ','CF630409634242BBA9DEAE4E621B083E'),(7399,'c','在运行时抛出NumberFormatException异常 ','CF630409634242BBA9DEAE4E621B083E'),(7400,'d','在运行时抛出IllegalStateException异常 ','CF630409634242BBA9DEAE4E621B083E'),(7401,'a','编译错误 ','1F1B3B43C1804FE288C77D3B11B7B92C'),(7402,'b','实现向文件record.dat追加写入字符a ','1F1B3B43C1804FE288C77D3B11B7B92C'),(7403,'c','实现向文件record.dat覆盖写入字符a ','1F1B3B43C1804FE288C77D3B11B7B92C'),(7404,'d','文件record.dat无任何内容 ','1F1B3B43C1804FE288C77D3B11B7B92C'),(7405,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','724408989A4A4E898D0DF3DDB3685C9E'),(7406,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','724408989A4A4E898D0DF3DDB3685C9E'),(7407,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','724408989A4A4E898D0DF3DDB3685C9E'),(7408,'d','new InputStreamReader(\"dat\") ; ','724408989A4A4E898D0DF3DDB3685C9E'),(7409,'a','编译错误 ','7038A9A5FBA74724BD51F48683E07478'),(7410,'b','实现向文件record.dat追加写入字符a ','7038A9A5FBA74724BD51F48683E07478'),(7411,'c','实现向文件record.dat覆盖写入字符a ','7038A9A5FBA74724BD51F48683E07478'),(7412,'d','文件record.dat无任何内容 ','7038A9A5FBA74724BD51F48683E07478'),(7413,'a','public void method( int m){...}     ','B64F2E0D5EB843709E2FF88F3B53D8B0'),(7414,'b','public int method(){...} ','B64F2E0D5EB843709E2FF88F3B53D8B0'),(7415,'c','public void method2(){...}    ','B64F2E0D5EB843709E2FF88F3B53D8B0'),(7416,'d','public int method(int m，float f ){...} ','B64F2E0D5EB843709E2FF88F3B53D8B0'),(7417,'a','第3行抛出异常 ','5063318F9F8948B98596AA89E3AD5C2E'),(7418,'b','第1行抛出异常 ','5063318F9F8948B98596AA89E3AD5C2E'),(7419,'c','第5行抛出异常 ','5063318F9F8948B98596AA89E3AD5C2E'),(7420,'d','第3行代码成功执行 ','5063318F9F8948B98596AA89E3AD5C2E'),(7421,'a','将private int m改为 protected int m  ','F205F4C97EF64B339A620EF65BFEB3B7'),(7422,'b','将private int m改为 public int m    ','F205F4C97EF64B339A620EF65BFEB3B7'),(7423,'c','将private int m改为 static int m     ','F205F4C97EF64B339A620EF65BFEB3B7'),(7424,'d','将private int m改为int m ','F205F4C97EF64B339A620EF65BFEB3B7'),(7425,'a','long 1 = 4990  ','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(7426,'b','int i = 4L  ','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(7427,'c','float f =1.1  ','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(7428,'d','double d = 34.4','78EC3C51FE8E44F0A8BDDDAFA1987B4F'),(7429,'a','编译错误 ','8F01E94DAF54499DAE4383F918C5F9B3'),(7430,'b','抛出运行时异常 ','8F01E94DAF54499DAE4383F918C5F9B3'),(7431,'c','输出：bar ','8F01E94DAF54499DAE4383F918C5F9B3'),(7432,'d','代码正常运行，但是无输出 ','8F01E94DAF54499DAE4383F918C5F9B3'),(7433,'a','s>>>=3   ','91ACD865B67246608C32C964E6830CE5'),(7434,'b','s[3]= “X”  ','91ACD865B67246608C32C964E6830CE5'),(7435,'c','int i = s.length()   ','91ACD865B67246608C32C964E6830CE5'),(7436,'d','s = s + 10 ','91ACD865B67246608C32C964E6830CE5'),(7437,'a','public void method( int m){...}     ','6CCFE1E7A6AC4235A3D92E639F540F10'),(7438,'b','public int method(){...} ','6CCFE1E7A6AC4235A3D92E639F540F10'),(7439,'c','public void method2(){...}    ','6CCFE1E7A6AC4235A3D92E639F540F10'),(7440,'d','public int method(int m，float f ){...} ','6CCFE1E7A6AC4235A3D92E639F540F10'),(7441,'a','public void method( int m){...}     ','F868F017613D4F7B82A520CA53820A88'),(7442,'b','public int method(){...} ','F868F017613D4F7B82A520CA53820A88'),(7443,'c','public void method2(){...}    ','F868F017613D4F7B82A520CA53820A88'),(7444,'d','public int method(int m，float f ){...} ','F868F017613D4F7B82A520CA53820A88'),(7445,'a','编译错误 ','A5E650650953487BAD3C330A032F013C'),(7446,'b','实现向文件record.dat追加写入字符a ','A5E650650953487BAD3C330A032F013C'),(7447,'c','实现向文件record.dat覆盖写入字符a ','A5E650650953487BAD3C330A032F013C'),(7448,'d','文件record.dat无任何内容 ','A5E650650953487BAD3C330A032F013C'),(7449,'a','sleep方法 ','9FB90ADD96C7406B851262044667F7CF'),(7450,'b','IO等待 ','9FB90ADD96C7406B851262044667F7CF'),(7451,'c','yield方法 ','9FB90ADD96C7406B851262044667F7CF'),(7452,'d','wait方法 ','9FB90ADD96C7406B851262044667F7CF'),(7453,'a','Output is null.             ','16223046B41E426CB0C993521EEFA891'),(7454,'b','Output is 0 ','16223046B41E426CB0C993521EEFA891'),(7455,'c','编译时报错 ','16223046B41E426CB0C993521EEFA891'),(7456,'d','运行时报错','16223046B41E426CB0C993521EEFA891'),(7457,'a','m.length()    ','6990A7987D8245AD9F11ED484497DCBA'),(7458,'b','m.length   ','6990A7987D8245AD9F11ED484497DCBA'),(7459,'c','m.length()+1   ','6990A7987D8245AD9F11ED484497DCBA'),(7460,'d','m.length-1','6990A7987D8245AD9F11ED484497DCBA'),(7461,'a','编译错误 ','A1268745F6DA4A9FAB5AD49B88B5125E'),(7462,'b','程序可以通过编译，运行后文件company.txt没有任何改变','A1268745F6DA4A9FAB5AD49B88B5125E'),(7463,'c','程序可以通过编译，运行后文件company.txt的长度变为0','A1268745F6DA4A9FAB5AD49B88B5125E'),(7464,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','A1268745F6DA4A9FAB5AD49B88B5125E'),(7465,'a','将private int m改为 protected int m  ','B06E364A021E40EDB1C2BB2B1A47DCC1'),(7466,'b','将private int m改为 public int m    ','B06E364A021E40EDB1C2BB2B1A47DCC1'),(7467,'c','将private int m改为 static int m     ','B06E364A021E40EDB1C2BB2B1A47DCC1'),(7468,'d','将private int m改为int m ','B06E364A021E40EDB1C2BB2B1A47DCC1'),(7469,'a','Output is null.             ','0340DBD2C12B4670B78BC4661DEAE63B'),(7470,'b','Output is 0 ','0340DBD2C12B4670B78BC4661DEAE63B'),(7471,'c','编译时报错 ','0340DBD2C12B4670B78BC4661DEAE63B'),(7472,'d','运行时报错','0340DBD2C12B4670B78BC4661DEAE63B'),(7473,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','5F5257B93B4F44D58F3630AF24FD7F2C'),(7474,'b','垃圾收集将检查并释放不在使用的内存  ','5F5257B93B4F44D58F3630AF24FD7F2C'),(7475,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','5F5257B93B4F44D58F3630AF24FD7F2C'),(7476,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','5F5257B93B4F44D58F3630AF24FD7F2C'),(7477,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','E5BC17E83BA54CA48A67B6BF02FBDF36'),(7478,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','E5BC17E83BA54CA48A67B6BF02FBDF36'),(7479,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','E5BC17E83BA54CA48A67B6BF02FBDF36'),(7480,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','E5BC17E83BA54CA48A67B6BF02FBDF36'),(7481,'a','输出：4 ','A49E51747A864D47860F7F94CA02F7F5'),(7482,'b','在运行时抛出NullPointerException异常 ','A49E51747A864D47860F7F94CA02F7F5'),(7483,'c','在运行时抛出NumberFormatException异常 ','A49E51747A864D47860F7F94CA02F7F5'),(7484,'d','在运行时抛出IllegalStateException异常 ','A49E51747A864D47860F7F94CA02F7F5'),(7485,'a','const   ','67D91679E8D740CE8D23131E986B98B9'),(7486,'b','NULL  ','67D91679E8D740CE8D23131E986B98B9'),(7487,'c','false   ','67D91679E8D740CE8D23131E986B98B9'),(7488,'d','this  ','67D91679E8D740CE8D23131E986B98B9'),(7489,'a','private synchronized Object o; ','43E198E4A1C845DA86D244E3D03A6F32'),(7490,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','43E198E4A1C845DA86D244E3D03A6F32'),(7491,'c','public synchronized void go() { /* code here */ } ','43E198E4A1C845DA86D244E3D03A6F32'),(7492,'d','private synchronized(this) void go() { /* code here */ } ','43E198E4A1C845DA86D244E3D03A6F32'),(7493,'a','栈是非线性结构        ','57B805FE40BA43D689079E43CEF8EA11'),(7494,'b','栈是一种树状结构 ','57B805FE40BA43D689079E43CEF8EA11'),(7495,'c','栈具有先进先出的特征  ','57B805FE40BA43D689079E43CEF8EA11'),(7496,'d','栈具有后进先出的特征 ','57B805FE40BA43D689079E43CEF8EA11'),(7497,'a','输出：test ','935D4D7675F04902AD85B724B07097B6'),(7498,'b','输出：Exception ','935D4D7675F04902AD85B724B07097B6'),(7499,'c','编译失败 ','935D4D7675F04902AD85B724B07097B6'),(7500,'d','输出：NullPointerException ','935D4D7675F04902AD85B724B07097B6'),(7501,'a','InputStreamReader','86F86AFFF4D84448820F07C4313BC748'),(7502,'b','BufferedReader','86F86AFFF4D84448820F07C4313BC748'),(7503,'c','FileInputStream','86F86AFFF4D84448820F07C4313BC748'),(7504,'d','InputStream','86F86AFFF4D84448820F07C4313BC748'),(7505,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','2717E466A2DF45788B5E66BD6C064443'),(7506,'b','垃圾收集将检查并释放不在使用的内存  ','2717E466A2DF45788B5E66BD6C064443'),(7507,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','2717E466A2DF45788B5E66BD6C064443'),(7508,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','2717E466A2DF45788B5E66BD6C064443'),(7509,'a','public void method( int m){...}     ','0B21F6AD31E4484A9532654AEAE0B778'),(7510,'b','public int method(){...} ','0B21F6AD31E4484A9532654AEAE0B778'),(7511,'c','public void method2(){...}    ','0B21F6AD31E4484A9532654AEAE0B778'),(7512,'d','public int method(int m，float f ){...} ','0B21F6AD31E4484A9532654AEAE0B778'),(7513,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','E4938E9343C948E6A4BAE41860A7AAB3'),(7514,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','E4938E9343C948E6A4BAE41860A7AAB3'),(7515,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','E4938E9343C948E6A4BAE41860A7AAB3'),(7516,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','E4938E9343C948E6A4BAE41860A7AAB3'),(7517,'a','5.0','14A688A6B6924406AD3C30D2DA0B21B4'),(7518,'b','4.0','14A688A6B6924406AD3C30D2DA0B21B4'),(7519,'c','6.0','14A688A6B6924406AD3C30D2DA0B21B4'),(7520,'d','finished','14A688A6B6924406AD3C30D2DA0B21B4'),(7521,'a','第3行抛出异常 ','194F09FB279F4DBE83B9782DAB269FB3'),(7522,'b','第1行抛出异常 ','194F09FB279F4DBE83B9782DAB269FB3'),(7523,'c','第5行抛出异常 ','194F09FB279F4DBE83B9782DAB269FB3'),(7524,'d','第3行代码成功执行 ','194F09FB279F4DBE83B9782DAB269FB3'),(7525,'a','编译错误 ','DC0044090AE5417ABAEE336169AEC828'),(7526,'b','实现向文件record.dat追加写入字符a ','DC0044090AE5417ABAEE336169AEC828'),(7527,'c','实现向文件record.dat覆盖写入字符a ','DC0044090AE5417ABAEE336169AEC828'),(7528,'d','文件record.dat无任何内容 ','DC0044090AE5417ABAEE336169AEC828'),(7529,'a','输出Exception ','CD53D7573E50468395B5634A9710DC63'),(7530,'b','输出A,B,Exception ','CD53D7573E50468395B5634A9710DC63'),(7531,'c','编译失败 ','CD53D7573E50468395B5634A9710DC63'),(7532,'d','在运行时抛出NullPointerException异常 ','CD53D7573E50468395B5634A9710DC63'),(7533,'a','输出：4 ','61909EC7D40B420CB526B272E195196C'),(7534,'b','在运行时抛出NullPointerException异常 ','61909EC7D40B420CB526B272E195196C'),(7535,'c','在运行时抛出NumberFormatException异常 ','61909EC7D40B420CB526B272E195196C'),(7536,'d','在运行时抛出IllegalStateException异常 ','61909EC7D40B420CB526B272E195196C'),(7537,'a','5.0','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(7538,'b','4.0','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(7539,'c','6.0','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(7540,'d','finished','C95E8D5A32DF46F4B5C4FB99AAFFF3B3'),(7541,'a','m.length()    ','D5CAEB569C2C495BACCDC433DCC14F43'),(7542,'b','m.length   ','D5CAEB569C2C495BACCDC433DCC14F43'),(7543,'c','m.length()+1   ','D5CAEB569C2C495BACCDC433DCC14F43'),(7544,'d','m.length-1','D5CAEB569C2C495BACCDC433DCC14F43'),(7545,'a','编译错误 ','928098EB84FD4F3ABA57355652DA4A84'),(7546,'b','程序可以通过编译，运行后文件company.txt没有任何改变','928098EB84FD4F3ABA57355652DA4A84'),(7547,'c','程序可以通过编译，运行后文件company.txt的长度变为0','928098EB84FD4F3ABA57355652DA4A84'),(7548,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','928098EB84FD4F3ABA57355652DA4A84'),(7549,'a','sleep方法 ','4B5DE4AFC03C4199B95EA38BDF6A578E'),(7550,'b','IO等待 ','4B5DE4AFC03C4199B95EA38BDF6A578E'),(7551,'c','yield方法 ','4B5DE4AFC03C4199B95EA38BDF6A578E'),(7552,'d','wait方法 ','4B5DE4AFC03C4199B95EA38BDF6A578E'),(7553,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','761196840F5D4476B24D89CD4A269D5F'),(7554,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','761196840F5D4476B24D89CD4A269D5F'),(7555,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','761196840F5D4476B24D89CD4A269D5F'),(7556,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','761196840F5D4476B24D89CD4A269D5F'),(7557,'a','输出：test ','36A9EB0D94274D47A4EF19BFDDAEC728'),(7558,'b','输出：Exception ','36A9EB0D94274D47A4EF19BFDDAEC728'),(7559,'c','编译失败 ','36A9EB0D94274D47A4EF19BFDDAEC728'),(7560,'d','输出：NullPointerException ','36A9EB0D94274D47A4EF19BFDDAEC728'),(7561,'a','编译错误 ','79B26A457F714842A53357F13DF013B5'),(7562,'b','实现向文件record.dat追加写入字符a ','79B26A457F714842A53357F13DF013B5'),(7563,'c','实现向文件record.dat覆盖写入字符a ','79B26A457F714842A53357F13DF013B5'),(7564,'d','文件record.dat无任何内容 ','79B26A457F714842A53357F13DF013B5'),(7565,'a','long 1 = 4990  ','BE9C100157444468B567804E26A76964'),(7566,'b','int i = 4L  ','BE9C100157444468B567804E26A76964'),(7567,'c','float f =1.1  ','BE9C100157444468B567804E26A76964'),(7568,'d','double d = 34.4','BE9C100157444468B567804E26A76964'),(7569,'a','栈是非线性结构        ','E5F99D16E49B469BA578889CFCADF356'),(7570,'b','栈是一种树状结构 ','E5F99D16E49B469BA578889CFCADF356'),(7571,'c','栈具有先进先出的特征  ','E5F99D16E49B469BA578889CFCADF356'),(7572,'d','栈具有后进先出的特征 ','E5F99D16E49B469BA578889CFCADF356'),(7573,'a','s>>>=3   ','EC5F649DAA6748B49457A45A601FA813'),(7574,'b','s[3]= “X”  ','EC5F649DAA6748B49457A45A601FA813'),(7575,'c','int i = s.length()   ','EC5F649DAA6748B49457A45A601FA813'),(7576,'d','s = s + 10 ','EC5F649DAA6748B49457A45A601FA813'),(7577,'a','编译错误 ','3AE6B81417D6476EBF61BC82076D5698'),(7578,'b','实现向文件record.dat追加写入字符a ','3AE6B81417D6476EBF61BC82076D5698'),(7579,'c','实现向文件record.dat覆盖写入字符a ','3AE6B81417D6476EBF61BC82076D5698'),(7580,'d','文件record.dat无任何内容 ','3AE6B81417D6476EBF61BC82076D5698'),(7581,'a','输出Exception ','29746DC6045D496E972A7B96F4107EB6'),(7582,'b','输出A,B,Exception ','29746DC6045D496E972A7B96F4107EB6'),(7583,'c','编译失败 ','29746DC6045D496E972A7B96F4107EB6'),(7584,'d','在运行时抛出NullPointerException异常 ','29746DC6045D496E972A7B96F4107EB6'),(7585,'a','private synchronized Object o; ','7F0C627CA34948A2B8942AD79D22CF32'),(7586,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','7F0C627CA34948A2B8942AD79D22CF32'),(7587,'c','public synchronized void go() { /* code here */ } ','7F0C627CA34948A2B8942AD79D22CF32'),(7588,'d','private synchronized(this) void go() { /* code here */ } ','7F0C627CA34948A2B8942AD79D22CF32'),(7589,'a','编译错误 ','69F7B368E6BE41C38AA333C2E74AD035'),(7590,'b','实现向文件record.dat追加写入字符a ','69F7B368E6BE41C38AA333C2E74AD035'),(7591,'c','实现向文件record.dat覆盖写入字符a ','69F7B368E6BE41C38AA333C2E74AD035'),(7592,'d','文件record.dat无任何内容 ','69F7B368E6BE41C38AA333C2E74AD035'),(7593,'a','编译错误 ','A4D1DB4FC1D641F293D5CC464C3A608C'),(7594,'b','抛出运行时异常 ','A4D1DB4FC1D641F293D5CC464C3A608C'),(7595,'c','输出：sleep ','A4D1DB4FC1D641F293D5CC464C3A608C'),(7596,'d','代码正常运行，但是无输出 ','A4D1DB4FC1D641F293D5CC464C3A608C'),(7597,'a','名为dtThread的线程为守护线程 ','0D16818191AD453F83FDAB28311E034F'),(7598,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','0D16818191AD453F83FDAB28311E034F'),(7599,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','0D16818191AD453F83FDAB28311E034F'),(7600,'d','main线程是守护线程 ','0D16818191AD453F83FDAB28311E034F'),(7601,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','5586B0C5CB3F41779879421F4CE69399'),(7602,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','5586B0C5CB3F41779879421F4CE69399'),(7603,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','5586B0C5CB3F41779879421F4CE69399'),(7604,'d','new InputStreamReader(\"dat\") ; ','5586B0C5CB3F41779879421F4CE69399'),(7605,'a','InputStreamReader','EA0F993F3CA54470BC757FF6F559BEA3'),(7606,'b','BufferedReader','EA0F993F3CA54470BC757FF6F559BEA3'),(7607,'c','FileInputStream','EA0F993F3CA54470BC757FF6F559BEA3'),(7608,'d','InputStream','EA0F993F3CA54470BC757FF6F559BEA3'),(7609,'a','const   ','751A2B0AC1BE4919996CEA697AB29521'),(7610,'b','NULL  ','751A2B0AC1BE4919996CEA697AB29521'),(7611,'c','false   ','751A2B0AC1BE4919996CEA697AB29521'),(7612,'d','this  ','751A2B0AC1BE4919996CEA697AB29521'),(7613,'a','将private int m改为 protected int m  ','E6AD178C63D44DA198487A72EED38CD7'),(7614,'b','将private int m改为 public int m    ','E6AD178C63D44DA198487A72EED38CD7'),(7615,'c','将private int m改为 static int m     ','E6AD178C63D44DA198487A72EED38CD7'),(7616,'d','将private int m改为int m ','E6AD178C63D44DA198487A72EED38CD7'),(7617,'a','编译错误 ','66E71A5906264466B87447349155B456'),(7618,'b','抛出运行时异常 ','66E71A5906264466B87447349155B456'),(7619,'c','输出：sleep ','66E71A5906264466B87447349155B456'),(7620,'d','代码正常运行，但是无输出 ','66E71A5906264466B87447349155B456'),(7621,'a','编译错误 ','E4CFC7BF9B57444CB207F9F36A2F6ACB'),(7622,'b','实现向文件record.dat追加写入字符a ','E4CFC7BF9B57444CB207F9F36A2F6ACB'),(7623,'c','实现向文件record.dat覆盖写入字符a ','E4CFC7BF9B57444CB207F9F36A2F6ACB'),(7624,'d','文件record.dat无任何内容 ','E4CFC7BF9B57444CB207F9F36A2F6ACB'),(7625,'a','m.length()    ','74480B5FF4484EC09487846A4FA60717'),(7626,'b','m.length   ','74480B5FF4484EC09487846A4FA60717'),(7627,'c','m.length()+1   ','74480B5FF4484EC09487846A4FA60717'),(7628,'d','m.length-1','74480B5FF4484EC09487846A4FA60717'),(7629,'a','private synchronized Object o; ','C2423B5C7C33457ABEB5D0A439C82F88'),(7630,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','C2423B5C7C33457ABEB5D0A439C82F88'),(7631,'c','public synchronized void go() { /* code here */ } ','C2423B5C7C33457ABEB5D0A439C82F88'),(7632,'d','private synchronized(this) void go() { /* code here */ } ','C2423B5C7C33457ABEB5D0A439C82F88'),(7633,'a','start()    ','6140A62F4AAE45A7ABACA83DB637257C'),(7634,'b','init()    ','6140A62F4AAE45A7ABACA83DB637257C'),(7635,'c','run()    ','6140A62F4AAE45A7ABACA83DB637257C'),(7636,'d','main()  ','6140A62F4AAE45A7ABACA83DB637257C'),(7637,'a','start()    ','99EF76E7F10E4CE68AD0A1711B37EC55'),(7638,'b','init()    ','99EF76E7F10E4CE68AD0A1711B37EC55'),(7639,'c','run()    ','99EF76E7F10E4CE68AD0A1711B37EC55'),(7640,'d','main()  ','99EF76E7F10E4CE68AD0A1711B37EC55'),(7641,'a','第3行抛出异常 ','A0E1E56613CC4668A0FE03B27E9C14E8'),(7642,'b','第1行抛出异常 ','A0E1E56613CC4668A0FE03B27E9C14E8'),(7643,'c','第5行抛出异常 ','A0E1E56613CC4668A0FE03B27E9C14E8'),(7644,'d','第3行代码成功执行 ','A0E1E56613CC4668A0FE03B27E9C14E8'),(7645,'a','sleep方法 ','FC0C5DA4DB8F4141ADA9830A215C057A'),(7646,'b','IO等待 ','FC0C5DA4DB8F4141ADA9830A215C057A'),(7647,'c','yield方法 ','FC0C5DA4DB8F4141ADA9830A215C057A'),(7648,'d','wait方法 ','FC0C5DA4DB8F4141ADA9830A215C057A'),(7649,'a','long 1 = 4990  ','6BE177BBFF0E4ABEABA97BC51777CB83'),(7650,'b','int i = 4L  ','6BE177BBFF0E4ABEABA97BC51777CB83'),(7651,'c','float f =1.1  ','6BE177BBFF0E4ABEABA97BC51777CB83'),(7652,'d','double d = 34.4','6BE177BBFF0E4ABEABA97BC51777CB83'),(7653,'a','long 1 = 4990  ','5B5044D1711646F393AA34C88E289DB8'),(7654,'b','int i = 4L  ','5B5044D1711646F393AA34C88E289DB8'),(7655,'c','float f =1.1  ','5B5044D1711646F393AA34C88E289DB8'),(7656,'d','double d = 34.4','5B5044D1711646F393AA34C88E289DB8'),(7657,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','6FA04AFEC120404C8B84708512AEE940'),(7658,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','6FA04AFEC120404C8B84708512AEE940'),(7659,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','6FA04AFEC120404C8B84708512AEE940'),(7660,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','6FA04AFEC120404C8B84708512AEE940'),(7661,'a','栈是非线性结构        ','4B00617DA3424C7B99336C0321831570'),(7662,'b','栈是一种树状结构 ','4B00617DA3424C7B99336C0321831570'),(7663,'c','栈具有先进先出的特征  ','4B00617DA3424C7B99336C0321831570'),(7664,'d','栈具有后进先出的特征 ','4B00617DA3424C7B99336C0321831570'),(7665,'a','通过调用stop()方法而停止的线程。 ','8080D48D9EBE464FB7B73E956E6DB304'),(7666,'b','通过调用sleep()方法而停止的线程。 ','8080D48D9EBE464FB7B73E956E6DB304'),(7667,'c','通过调用wait()方法而停止的线程。 ','8080D48D9EBE464FB7B73E956E6DB304'),(7668,'d','通过调用suspend()方法而停止的线程。 ','8080D48D9EBE464FB7B73E956E6DB304'),(7669,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','2B31095C9C1C4E2DAA4172FC7F6ACA44'),(7670,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','2B31095C9C1C4E2DAA4172FC7F6ACA44'),(7671,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','2B31095C9C1C4E2DAA4172FC7F6ACA44'),(7672,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','2B31095C9C1C4E2DAA4172FC7F6ACA44'),(7673,'a','第3行抛出异常 ','09D480AD5FF04337906A6E7D7A658245'),(7674,'b','第1行抛出异常 ','09D480AD5FF04337906A6E7D7A658245'),(7675,'c','第5行抛出异常 ','09D480AD5FF04337906A6E7D7A658245'),(7676,'d','第3行代码成功执行 ','09D480AD5FF04337906A6E7D7A658245'),(7677,'a','编译错误 ','62051AC20C474638A6CA94B1FBA93403'),(7678,'b','程序可以通过编译，运行后文件company.txt没有任何改变','62051AC20C474638A6CA94B1FBA93403'),(7679,'c','程序可以通过编译，运行后文件company.txt的长度变为0','62051AC20C474638A6CA94B1FBA93403'),(7680,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','62051AC20C474638A6CA94B1FBA93403'),(7681,'a','一旦一个线程被创建，它就立即开始运行。  ','0482AC0B2895429ABD8E9CB09D015E65'),(7682,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','0482AC0B2895429ABD8E9CB09D015E65'),(7683,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','0482AC0B2895429ABD8E9CB09D015E65'),(7684,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','0482AC0B2895429ABD8E9CB09D015E65'),(7685,'a','public void method( int m){...}     ','D66FA56B06B04BE9B32DEA5E58E2FED4'),(7686,'b','public int method(){...} ','D66FA56B06B04BE9B32DEA5E58E2FED4'),(7687,'c','public void method2(){...}    ','D66FA56B06B04BE9B32DEA5E58E2FED4'),(7688,'d','public int method(int m，float f ){...} ','D66FA56B06B04BE9B32DEA5E58E2FED4'),(7689,'a','一旦一个线程被创建，它就立即开始运行。  ','555BA336AA0B4412BC7272BE86302EAD'),(7690,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','555BA336AA0B4412BC7272BE86302EAD'),(7691,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','555BA336AA0B4412BC7272BE86302EAD'),(7692,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','555BA336AA0B4412BC7272BE86302EAD'),(7693,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','D23940DF31ED4F84A2899E935A23A47B'),(7694,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','D23940DF31ED4F84A2899E935A23A47B'),(7695,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','D23940DF31ED4F84A2899E935A23A47B'),(7696,'d','new InputStreamReader(\"dat\") ; ','D23940DF31ED4F84A2899E935A23A47B'),(7697,'a','Output is null.             ','1E8E933476994B3E8C31EF93422AFEA0'),(7698,'b','Output is 0 ','1E8E933476994B3E8C31EF93422AFEA0'),(7699,'c','编译时报错 ','1E8E933476994B3E8C31EF93422AFEA0'),(7700,'d','运行时报错','1E8E933476994B3E8C31EF93422AFEA0'),(7701,'a','编译错误 ','E5A0C168BE6A44EAB8889AFBB8DE39AF'),(7702,'b','抛出运行时异常 ','E5A0C168BE6A44EAB8889AFBB8DE39AF'),(7703,'c','输出：bar ','E5A0C168BE6A44EAB8889AFBB8DE39AF'),(7704,'d','代码正常运行，但是无输出 ','E5A0C168BE6A44EAB8889AFBB8DE39AF'),(7705,'a','5.0','D2B6F35A17FD413B97CF9B108CF38544'),(7706,'b','4.0','D2B6F35A17FD413B97CF9B108CF38544'),(7707,'c','6.0','D2B6F35A17FD413B97CF9B108CF38544'),(7708,'d','finished','D2B6F35A17FD413B97CF9B108CF38544'),(7709,'a','start()    ','2A7DB67EDB684928BE0C454EEE85359A'),(7710,'b','init()    ','2A7DB67EDB684928BE0C454EEE85359A'),(7711,'c','run()    ','2A7DB67EDB684928BE0C454EEE85359A'),(7712,'d','main()  ','2A7DB67EDB684928BE0C454EEE85359A'),(7713,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','B305E418F4344DF681BC6C41E396E194'),(7714,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','B305E418F4344DF681BC6C41E396E194'),(7715,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','B305E418F4344DF681BC6C41E396E194'),(7716,'d','new InputStreamReader(\"1.dat\") ; ','B305E418F4344DF681BC6C41E396E194'),(7717,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','A8F3A84FB9D24DBA9F3CCD662FB83276'),(7718,'b','垃圾收集将检查并释放不在使用的内存  ','A8F3A84FB9D24DBA9F3CCD662FB83276'),(7719,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','A8F3A84FB9D24DBA9F3CCD662FB83276'),(7720,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','A8F3A84FB9D24DBA9F3CCD662FB83276'),(7721,'a','s>>>=3   ','BD59E94A4A124D91B9DB53A687048736'),(7722,'b','s[3]= “X”  ','BD59E94A4A124D91B9DB53A687048736'),(7723,'c','int i = s.length()   ','BD59E94A4A124D91B9DB53A687048736'),(7724,'d','s = s + 10 ','BD59E94A4A124D91B9DB53A687048736'),(7725,'a','名为dtThread的线程为守护线程 ','70C9693B2A83415CA15636E86F65F20E'),(7726,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','70C9693B2A83415CA15636E86F65F20E'),(7727,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','70C9693B2A83415CA15636E86F65F20E'),(7728,'d','main线程是守护线程 ','70C9693B2A83415CA15636E86F65F20E'),(7729,'a','名为dtThread的线程为守护线程 ','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(7730,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(7731,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(7732,'d','main线程是守护线程 ','6C3ECE66A4FF464CB7B5ADE82CD681FD'),(7733,'a','InputStreamReader','5A50AF5167B34895BA1BF4013B63E747'),(7734,'b','BufferedReader','5A50AF5167B34895BA1BF4013B63E747'),(7735,'c','FileInputStream','5A50AF5167B34895BA1BF4013B63E747'),(7736,'d','InputStream','5A50AF5167B34895BA1BF4013B63E747'),(7737,'a','sleep方法 ','C66DB560147540D99E9D2C5B6F0BC376'),(7738,'b','IO等待 ','C66DB560147540D99E9D2C5B6F0BC376'),(7739,'c','yield方法 ','C66DB560147540D99E9D2C5B6F0BC376'),(7740,'d','wait方法 ','C66DB560147540D99E9D2C5B6F0BC376'),(7741,'a','编译错误 ','82E0210594EC46A5848C1B362B536CE5'),(7742,'b','抛出运行时异常 ','82E0210594EC46A5848C1B362B536CE5'),(7743,'c','输出：sleep ','82E0210594EC46A5848C1B362B536CE5'),(7744,'d','代码正常运行，但是无输出 ','82E0210594EC46A5848C1B362B536CE5'),(7745,'a','将private int m改为 protected int m  ','37586978D0294F0DAA4231CE74C06683'),(7746,'b','将private int m改为 public int m    ','37586978D0294F0DAA4231CE74C06683'),(7747,'c','将private int m改为 static int m     ','37586978D0294F0DAA4231CE74C06683'),(7748,'d','将private int m改为int m ','37586978D0294F0DAA4231CE74C06683'),(7749,'a','public void method( int m){...}     ','F5426AE44A5C4860A30479E132E46E18'),(7750,'b','public int method(){...} ','F5426AE44A5C4860A30479E132E46E18'),(7751,'c','public void method2(){...}    ','F5426AE44A5C4860A30479E132E46E18'),(7752,'d','public int method(int m，float f ){...} ','F5426AE44A5C4860A30479E132E46E18'),(7753,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','490DA59D0137492A861B57122BA8DA6F'),(7754,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','490DA59D0137492A861B57122BA8DA6F'),(7755,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','490DA59D0137492A861B57122BA8DA6F'),(7756,'d','new InputStreamReader(\"dat\") ; ','490DA59D0137492A861B57122BA8DA6F'),(7757,'a','将private int m改为 protected int m  ','1E7C2D0B63784F88931528EE277F602D'),(7758,'b','将private int m改为 public int m    ','1E7C2D0B63784F88931528EE277F602D'),(7759,'c','将private int m改为 static int m     ','1E7C2D0B63784F88931528EE277F602D'),(7760,'d','将private int m改为int m ','1E7C2D0B63784F88931528EE277F602D'),(7761,'a','Output is null.             ','E06613DB0F054BBBB004FB1AAABFEEE8'),(7762,'b','Output is 0 ','E06613DB0F054BBBB004FB1AAABFEEE8'),(7763,'c','编译时报错 ','E06613DB0F054BBBB004FB1AAABFEEE8'),(7764,'d','运行时报错','E06613DB0F054BBBB004FB1AAABFEEE8'),(7765,'a','Output is null.             ','A9C7552E2D7D4C45B9B77575AD986857'),(7766,'b','Output is 0 ','A9C7552E2D7D4C45B9B77575AD986857'),(7767,'c','编译时报错 ','A9C7552E2D7D4C45B9B77575AD986857'),(7768,'d','运行时报错','A9C7552E2D7D4C45B9B77575AD986857'),(7769,'a','编译错误 ','24963641377D4F89B083907A7F343AFF'),(7770,'b','程序可以通过编译，运行后文件company.txt没有任何改变','24963641377D4F89B083907A7F343AFF'),(7771,'c','程序可以通过编译，运行后文件company.txt的长度变为0','24963641377D4F89B083907A7F343AFF'),(7772,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','24963641377D4F89B083907A7F343AFF'),(7773,'a','编译错误 ','615A69A631C24BE2AC9947A98C6F1C7E'),(7774,'b','抛出运行时异常 ','615A69A631C24BE2AC9947A98C6F1C7E'),(7775,'c','输出：bar ','615A69A631C24BE2AC9947A98C6F1C7E'),(7776,'d','代码正常运行，但是无输出 ','615A69A631C24BE2AC9947A98C6F1C7E'),(7777,'a','const   ','7AE249ACF24446D5872457CE801B0355'),(7778,'b','NULL  ','7AE249ACF24446D5872457CE801B0355'),(7779,'c','false   ','7AE249ACF24446D5872457CE801B0355'),(7780,'d','this  ','7AE249ACF24446D5872457CE801B0355'),(7781,'a','一旦一个线程被创建，它就立即开始运行。  ','58C23496BB8843B69A883398E0666360'),(7782,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','58C23496BB8843B69A883398E0666360'),(7783,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','58C23496BB8843B69A883398E0666360'),(7784,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','58C23496BB8843B69A883398E0666360'),(7785,'a','通过调用stop()方法而停止的线程。 ','B9D38B1692174AAE911A2663EBA55B3E'),(7786,'b','通过调用sleep()方法而停止的线程。 ','B9D38B1692174AAE911A2663EBA55B3E'),(7787,'c','通过调用wait()方法而停止的线程。 ','B9D38B1692174AAE911A2663EBA55B3E'),(7788,'d','通过调用suspend()方法而停止的线程。 ','B9D38B1692174AAE911A2663EBA55B3E'),(7789,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','2808DF9DACC946E5B69D29FC50C9AE06'),(7790,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','2808DF9DACC946E5B69D29FC50C9AE06'),(7791,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','2808DF9DACC946E5B69D29FC50C9AE06'),(7792,'d','new InputStreamReader(\"1.dat\") ; ','2808DF9DACC946E5B69D29FC50C9AE06'),(7793,'a','输出：test ','ED1902732A55443387CD472B2244A72E'),(7794,'b','输出：Exception ','ED1902732A55443387CD472B2244A72E'),(7795,'c','编译失败 ','ED1902732A55443387CD472B2244A72E'),(7796,'d','输出：NullPointerException ','ED1902732A55443387CD472B2244A72E'),(7797,'a','输出Exception ','58CCA5BD668A45A38AA01FC7E3B34650'),(7798,'b','输出A,B,Exception ','58CCA5BD668A45A38AA01FC7E3B34650'),(7799,'c','编译失败 ','58CCA5BD668A45A38AA01FC7E3B34650'),(7800,'d','在运行时抛出NullPointerException异常 ','58CCA5BD668A45A38AA01FC7E3B34650'),(7801,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','5B51CC93D8374AEDAE510DF336B2986C'),(7802,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','5B51CC93D8374AEDAE510DF336B2986C'),(7803,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','5B51CC93D8374AEDAE510DF336B2986C'),(7804,'d','new InputStreamReader(\"dat\") ; ','5B51CC93D8374AEDAE510DF336B2986C'),(7805,'a','编译错误 ','9DAB033452A947F69CB8F7B8C724EFBD'),(7806,'b','抛出运行时异常 ','9DAB033452A947F69CB8F7B8C724EFBD'),(7807,'c','输出：sleep ','9DAB033452A947F69CB8F7B8C724EFBD'),(7808,'d','代码正常运行，但是无输出 ','9DAB033452A947F69CB8F7B8C724EFBD'),(7809,'a','s>>>=3   ','0162C6B4758F4301957E58DB6299C09E'),(7810,'b','s[3]= “X”  ','0162C6B4758F4301957E58DB6299C09E'),(7811,'c','int i = s.length()   ','0162C6B4758F4301957E58DB6299C09E'),(7812,'d','s = s + 10 ','0162C6B4758F4301957E58DB6299C09E'),(7813,'a','输出：test ','431AFF560A084AC3AADDAF4D839F3E47'),(7814,'b','输出：Exception ','431AFF560A084AC3AADDAF4D839F3E47'),(7815,'c','编译失败 ','431AFF560A084AC3AADDAF4D839F3E47'),(7816,'d','输出：NullPointerException ','431AFF560A084AC3AADDAF4D839F3E47'),(7817,'a','编译错误 ','30D3D89650C147FFAFCEDD4522C7EC8E'),(7818,'b','抛出运行时异常 ','30D3D89650C147FFAFCEDD4522C7EC8E'),(7819,'c','输出：bar ','30D3D89650C147FFAFCEDD4522C7EC8E'),(7820,'d','代码正常运行，但是无输出 ','30D3D89650C147FFAFCEDD4522C7EC8E'),(7821,'a','private synchronized Object o; ','3B18185C2E9640F499788DCA1EF71D57'),(7822,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','3B18185C2E9640F499788DCA1EF71D57'),(7823,'c','public synchronized void go() { /* code here */ } ','3B18185C2E9640F499788DCA1EF71D57'),(7824,'d','private synchronized(this) void go() { /* code here */ } ','3B18185C2E9640F499788DCA1EF71D57'),(7825,'a','编译错误 ','D12253BBE2B84571838E5E6A8EF6BC3E'),(7826,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D12253BBE2B84571838E5E6A8EF6BC3E'),(7827,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D12253BBE2B84571838E5E6A8EF6BC3E'),(7828,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D12253BBE2B84571838E5E6A8EF6BC3E'),(7829,'a','一旦一个线程被创建，它就立即开始运行。  ','73DE660E898B4424868C66C4E4688BDE'),(7830,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','73DE660E898B4424868C66C4E4688BDE'),(7831,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','73DE660E898B4424868C66C4E4688BDE'),(7832,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','73DE660E898B4424868C66C4E4688BDE'),(7833,'a','输出：test ','BA7D1A7853BC4A22ABE081E19E6371D2'),(7834,'b','输出：Exception ','BA7D1A7853BC4A22ABE081E19E6371D2'),(7835,'c','编译失败 ','BA7D1A7853BC4A22ABE081E19E6371D2'),(7836,'d','输出：NullPointerException ','BA7D1A7853BC4A22ABE081E19E6371D2'),(7837,'a','第3行抛出异常 ','F427B9E419114FACBA2D06B270A68270'),(7838,'b','第1行抛出异常 ','F427B9E419114FACBA2D06B270A68270'),(7839,'c','第5行抛出异常 ','F427B9E419114FACBA2D06B270A68270'),(7840,'d','第3行代码成功执行 ','F427B9E419114FACBA2D06B270A68270'),(7841,'a','编译错误 ','F6BB47DE9483475BA440CF9DB19F8F2B'),(7842,'b','实现向文件record.dat追加写入字符a ','F6BB47DE9483475BA440CF9DB19F8F2B'),(7843,'c','实现向文件record.dat覆盖写入字符a ','F6BB47DE9483475BA440CF9DB19F8F2B'),(7844,'d','文件record.dat无任何内容 ','F6BB47DE9483475BA440CF9DB19F8F2B'),(7845,'a','编译错误 ','4BC7C14FAA004D69A8EF08AE37534177'),(7846,'b','程序可以通过编译，运行后文件company.txt没有任何改变','4BC7C14FAA004D69A8EF08AE37534177'),(7847,'c','程序可以通过编译，运行后文件company.txt的长度变为0','4BC7C14FAA004D69A8EF08AE37534177'),(7848,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','4BC7C14FAA004D69A8EF08AE37534177'),(7849,'a','第3行抛出异常 ','4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(7850,'b','第1行抛出异常 ','4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(7851,'c','第5行抛出异常 ','4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(7852,'d','第3行代码成功执行 ','4FCB6235DF1C48E0BA97A1D07CFCF2CF'),(7853,'a','编译错误 ','6479075EA97B4130B1003BF9DD4E1BDF'),(7854,'b','实现向文件record.dat追加写入字符a ','6479075EA97B4130B1003BF9DD4E1BDF'),(7855,'c','实现向文件record.dat覆盖写入字符a ','6479075EA97B4130B1003BF9DD4E1BDF'),(7856,'d','文件record.dat无任何内容 ','6479075EA97B4130B1003BF9DD4E1BDF'),(7857,'a','sleep方法 ','4C5C9360A6FB442E8AF629BA3BC4A3F6'),(7858,'b','IO等待 ','4C5C9360A6FB442E8AF629BA3BC4A3F6'),(7859,'c','yield方法 ','4C5C9360A6FB442E8AF629BA3BC4A3F6'),(7860,'d','wait方法 ','4C5C9360A6FB442E8AF629BA3BC4A3F6'),(7861,'a','输出：4 ','7D253EA3C6E14AC2931F9D45D998156B'),(7862,'b','在运行时抛出NullPointerException异常 ','7D253EA3C6E14AC2931F9D45D998156B'),(7863,'c','在运行时抛出NumberFormatException异常 ','7D253EA3C6E14AC2931F9D45D998156B'),(7864,'d','在运行时抛出IllegalStateException异常 ','7D253EA3C6E14AC2931F9D45D998156B'),(7865,'a','编译错误 ','98C95E20A931459A92A89055D66DAA19'),(7866,'b','抛出运行时异常 ','98C95E20A931459A92A89055D66DAA19'),(7867,'c','输出：bar ','98C95E20A931459A92A89055D66DAA19'),(7868,'d','代码正常运行，但是无输出 ','98C95E20A931459A92A89055D66DAA19'),(7869,'a','5.0','E89FC25CC66E49BAB7F8CC07F67E2B91'),(7870,'b','4.0','E89FC25CC66E49BAB7F8CC07F67E2B91'),(7871,'c','6.0','E89FC25CC66E49BAB7F8CC07F67E2B91'),(7872,'d','finished','E89FC25CC66E49BAB7F8CC07F67E2B91'),(7873,'a','第3行抛出异常 ','8244B24B35CF4DD9937649E6ED85B4C7'),(7874,'b','第1行抛出异常 ','8244B24B35CF4DD9937649E6ED85B4C7'),(7875,'c','第5行抛出异常 ','8244B24B35CF4DD9937649E6ED85B4C7'),(7876,'d','第3行代码成功执行 ','8244B24B35CF4DD9937649E6ED85B4C7'),(7877,'a','m.length()    ','F6B9D863339A4C8E88EAD26D013B3A7D'),(7878,'b','m.length   ','F6B9D863339A4C8E88EAD26D013B3A7D'),(7879,'c','m.length()+1   ','F6B9D863339A4C8E88EAD26D013B3A7D'),(7880,'d','m.length-1','F6B9D863339A4C8E88EAD26D013B3A7D'),(7881,'a','long 1 = 4990  ','0574B3F614CE42618BB2349DC59194C0'),(7882,'b','int i = 4L  ','0574B3F614CE42618BB2349DC59194C0'),(7883,'c','float f =1.1  ','0574B3F614CE42618BB2349DC59194C0'),(7884,'d','double d = 34.4','0574B3F614CE42618BB2349DC59194C0'),(7885,'a','m.length()    ','B85CE9E7145F421CA73FB1A532AEA310'),(7886,'b','m.length   ','B85CE9E7145F421CA73FB1A532AEA310'),(7887,'c','m.length()+1   ','B85CE9E7145F421CA73FB1A532AEA310'),(7888,'d','m.length-1','B85CE9E7145F421CA73FB1A532AEA310'),(7889,'a','通过调用stop()方法而停止的线程。 ','6F5F15FED99C43C8BF9ECFA906C5B75E'),(7890,'b','通过调用sleep()方法而停止的线程。 ','6F5F15FED99C43C8BF9ECFA906C5B75E'),(7891,'c','通过调用wait()方法而停止的线程。 ','6F5F15FED99C43C8BF9ECFA906C5B75E'),(7892,'d','通过调用suspend()方法而停止的线程。 ','6F5F15FED99C43C8BF9ECFA906C5B75E'),(7893,'a','Output is null.             ','A1A4355FD0414AA0A12F505A830220C7'),(7894,'b','Output is 0 ','A1A4355FD0414AA0A12F505A830220C7'),(7895,'c','编译时报错 ','A1A4355FD0414AA0A12F505A830220C7'),(7896,'d','运行时报错','A1A4355FD0414AA0A12F505A830220C7'),(7897,'a','const   ','F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(7898,'b','NULL  ','F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(7899,'c','false   ','F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(7900,'d','this  ','F4D66FD6DE2C4AA8B0F258B30D9D4A4D'),(7901,'a','start()    ','525D29DF70614DDB84BDF6F37921D8FD'),(7902,'b','init()    ','525D29DF70614DDB84BDF6F37921D8FD'),(7903,'c','run()    ','525D29DF70614DDB84BDF6F37921D8FD'),(7904,'d','main()  ','525D29DF70614DDB84BDF6F37921D8FD'),(7905,'a','s>>>=3   ','53BB7CA57C7243A5BE54B14738A2C030'),(7906,'b','s[3]= “X”  ','53BB7CA57C7243A5BE54B14738A2C030'),(7907,'c','int i = s.length()   ','53BB7CA57C7243A5BE54B14738A2C030'),(7908,'d','s = s + 10 ','53BB7CA57C7243A5BE54B14738A2C030'),(7909,'a','编译错误 ','6937E3F700C64B789B08B27395A063A2'),(7910,'b','程序可以通过编译，运行后文件company.txt没有任何改变','6937E3F700C64B789B08B27395A063A2'),(7911,'c','程序可以通过编译，运行后文件company.txt的长度变为0','6937E3F700C64B789B08B27395A063A2'),(7912,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','6937E3F700C64B789B08B27395A063A2'),(7913,'a','long 1 = 4990  ','89A2D2E6BD1047B28CD40481E8FC98CB'),(7914,'b','int i = 4L  ','89A2D2E6BD1047B28CD40481E8FC98CB'),(7915,'c','float f =1.1  ','89A2D2E6BD1047B28CD40481E8FC98CB'),(7916,'d','double d = 34.4','89A2D2E6BD1047B28CD40481E8FC98CB'),(7917,'a','编译错误 ','2B749F30FF0848ACBD1B1C0CA3FF6032'),(7918,'b','实现向文件record.dat追加写入字符a ','2B749F30FF0848ACBD1B1C0CA3FF6032'),(7919,'c','实现向文件record.dat覆盖写入字符a ','2B749F30FF0848ACBD1B1C0CA3FF6032'),(7920,'d','文件record.dat无任何内容 ','2B749F30FF0848ACBD1B1C0CA3FF6032'),(7921,'a','public void method( int m){...}     ','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(7922,'b','public int method(){...} ','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(7923,'c','public void method2(){...}    ','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(7924,'d','public int method(int m，float f ){...} ','0BD6E1DFE7F84A24ACAFAB09DA6E7606'),(7925,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','922059CBD4C241039447BC256F0E9FF8'),(7926,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','922059CBD4C241039447BC256F0E9FF8'),(7927,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','922059CBD4C241039447BC256F0E9FF8'),(7928,'d','new InputStreamReader(\"1.dat\") ; ','922059CBD4C241039447BC256F0E9FF8'),(7929,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','FEB88DB5421546299B9FF7F0DE93BD95'),(7930,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','FEB88DB5421546299B9FF7F0DE93BD95'),(7931,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','FEB88DB5421546299B9FF7F0DE93BD95'),(7932,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','FEB88DB5421546299B9FF7F0DE93BD95'),(7933,'a','编译错误 ','F937F52ABA8B47F08B5E6B8A7F05D777'),(7934,'b','抛出运行时异常 ','F937F52ABA8B47F08B5E6B8A7F05D777'),(7935,'c','输出：bar ','F937F52ABA8B47F08B5E6B8A7F05D777'),(7936,'d','代码正常运行，但是无输出 ','F937F52ABA8B47F08B5E6B8A7F05D777'),(7937,'a','将private int m改为 protected int m  ','6148A72E4C69455782527585ED19543F'),(7938,'b','将private int m改为 public int m    ','6148A72E4C69455782527585ED19543F'),(7939,'c','将private int m改为 static int m     ','6148A72E4C69455782527585ED19543F'),(7940,'d','将private int m改为int m ','6148A72E4C69455782527585ED19543F'),(7941,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','9FE4B37819814AF8AFECADE4680F335E'),(7942,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','9FE4B37819814AF8AFECADE4680F335E'),(7943,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','9FE4B37819814AF8AFECADE4680F335E'),(7944,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','9FE4B37819814AF8AFECADE4680F335E'),(7945,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','826CBDB7A0374BCB84CC553D72491909'),(7946,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','826CBDB7A0374BCB84CC553D72491909'),(7947,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','826CBDB7A0374BCB84CC553D72491909'),(7948,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','826CBDB7A0374BCB84CC553D72491909'),(7949,'a','一旦一个线程被创建，它就立即开始运行。  ','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(7950,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(7951,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(7952,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','5C7ED38AE2A74C1B8BA7A8D09CA67FD5'),(7953,'a','栈是非线性结构        ','BFFAC648C5384E74960708396A4835EE'),(7954,'b','栈是一种树状结构 ','BFFAC648C5384E74960708396A4835EE'),(7955,'c','栈具有先进先出的特征  ','BFFAC648C5384E74960708396A4835EE'),(7956,'d','栈具有后进先出的特征 ','BFFAC648C5384E74960708396A4835EE'),(7957,'a','sleep方法 ','AE18609B5906462A8668A9E28387B319'),(7958,'b','IO等待 ','AE18609B5906462A8668A9E28387B319'),(7959,'c','yield方法 ','AE18609B5906462A8668A9E28387B319'),(7960,'d','wait方法 ','AE18609B5906462A8668A9E28387B319'),(7961,'a','将private int m改为 protected int m  ','4723D32BA83547BEA3D79ED8247C854F'),(7962,'b','将private int m改为 public int m    ','4723D32BA83547BEA3D79ED8247C854F'),(7963,'c','将private int m改为 static int m     ','4723D32BA83547BEA3D79ED8247C854F'),(7964,'d','将private int m改为int m ','4723D32BA83547BEA3D79ED8247C854F'),(7965,'a','const   ','EEC6D19D21CB4732BFE0707749861851'),(7966,'b','NULL  ','EEC6D19D21CB4732BFE0707749861851'),(7967,'c','false   ','EEC6D19D21CB4732BFE0707749861851'),(7968,'d','this  ','EEC6D19D21CB4732BFE0707749861851'),(7969,'a','start()    ','3A8265F8E32E498C89567B74996CEBE1'),(7970,'b','init()    ','3A8265F8E32E498C89567B74996CEBE1'),(7971,'c','run()    ','3A8265F8E32E498C89567B74996CEBE1'),(7972,'d','main()  ','3A8265F8E32E498C89567B74996CEBE1'),(7973,'a','编译错误 ','B46844E54A2147DC894F3A2F23223534'),(7974,'b','抛出运行时异常 ','B46844E54A2147DC894F3A2F23223534'),(7975,'c','输出：sleep ','B46844E54A2147DC894F3A2F23223534'),(7976,'d','代码正常运行，但是无输出 ','B46844E54A2147DC894F3A2F23223534'),(7977,'a','InputStreamReader','A844893EC77E42EEBA0D6A315CF5A1A8'),(7978,'b','BufferedReader','A844893EC77E42EEBA0D6A315CF5A1A8'),(7979,'c','FileInputStream','A844893EC77E42EEBA0D6A315CF5A1A8'),(7980,'d','InputStream','A844893EC77E42EEBA0D6A315CF5A1A8'),(7981,'a','输出：test ','95061B5665CB4E1A8C0BB901AFA78146'),(7982,'b','输出：Exception ','95061B5665CB4E1A8C0BB901AFA78146'),(7983,'c','编译失败 ','95061B5665CB4E1A8C0BB901AFA78146'),(7984,'d','输出：NullPointerException ','95061B5665CB4E1A8C0BB901AFA78146'),(7985,'a','Output is null.             ','79E40BEC55DB42219CF0E315810464D4'),(7986,'b','Output is 0 ','79E40BEC55DB42219CF0E315810464D4'),(7987,'c','编译时报错 ','79E40BEC55DB42219CF0E315810464D4'),(7988,'d','运行时报错','79E40BEC55DB42219CF0E315810464D4'),(7989,'a','将private int m改为 protected int m  ','1A40D359F56745CDB555C14820545EFC'),(7990,'b','将private int m改为 public int m    ','1A40D359F56745CDB555C14820545EFC'),(7991,'c','将private int m改为 static int m     ','1A40D359F56745CDB555C14820545EFC'),(7992,'d','将private int m改为int m ','1A40D359F56745CDB555C14820545EFC'),(7993,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','400DB2E46156492385A1317A5FCA549F'),(7994,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','400DB2E46156492385A1317A5FCA549F'),(7995,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','400DB2E46156492385A1317A5FCA549F'),(7996,'d','new InputStreamReader(\"1.dat\") ; ','400DB2E46156492385A1317A5FCA549F'),(7997,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','297A9757DDF349BFBB5C483640BB7696'),(7998,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','297A9757DDF349BFBB5C483640BB7696'),(7999,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','297A9757DDF349BFBB5C483640BB7696'),(8000,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','297A9757DDF349BFBB5C483640BB7696'),(8001,'a','sleep方法 ','076CEFB0BC0F4A7481FFDECEA04F491D'),(8002,'b','IO等待 ','076CEFB0BC0F4A7481FFDECEA04F491D'),(8003,'c','yield方法 ','076CEFB0BC0F4A7481FFDECEA04F491D'),(8004,'d','wait方法 ','076CEFB0BC0F4A7481FFDECEA04F491D'),(8005,'a','long 1 = 4990  ','81CBC08D8E5241BCA53AF8A7C46548BC'),(8006,'b','int i = 4L  ','81CBC08D8E5241BCA53AF8A7C46548BC'),(8007,'c','float f =1.1  ','81CBC08D8E5241BCA53AF8A7C46548BC'),(8008,'d','double d = 34.4','81CBC08D8E5241BCA53AF8A7C46548BC'),(8009,'a','public void method( int m){...}     ','44DF84B88590415EBF1268A084313CB7'),(8010,'b','public int method(){...} ','44DF84B88590415EBF1268A084313CB7'),(8011,'c','public void method2(){...}    ','44DF84B88590415EBF1268A084313CB7'),(8012,'d','public int method(int m，float f ){...} ','44DF84B88590415EBF1268A084313CB7'),(8013,'a','5.0','1FD5ECCB2E04424F918D815922BE8B16'),(8014,'b','4.0','1FD5ECCB2E04424F918D815922BE8B16'),(8015,'c','6.0','1FD5ECCB2E04424F918D815922BE8B16'),(8016,'d','finished','1FD5ECCB2E04424F918D815922BE8B16'),(8017,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','3D623D9B0DFD44AEA19510A6D05EF7A1'),(8018,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','3D623D9B0DFD44AEA19510A6D05EF7A1'),(8019,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','3D623D9B0DFD44AEA19510A6D05EF7A1'),(8020,'d','new InputStreamReader(\"dat\") ; ','3D623D9B0DFD44AEA19510A6D05EF7A1'),(8021,'a','编译错误 ','AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(8022,'b','实现向文件record.dat追加写入字符a ','AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(8023,'c','实现向文件record.dat覆盖写入字符a ','AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(8024,'d','文件record.dat无任何内容 ','AD1DF78AB65F4CC9BF8A1AB155B2DD59'),(8025,'a','名为dtThread的线程为守护线程 ','156E8B5E7C93431FB792453C2D6E9D58'),(8026,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','156E8B5E7C93431FB792453C2D6E9D58'),(8027,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','156E8B5E7C93431FB792453C2D6E9D58'),(8028,'d','main线程是守护线程 ','156E8B5E7C93431FB792453C2D6E9D58'),(8029,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','6DD3628513804EB78FB74DB67E45D1C5'),(8030,'b','垃圾收集将检查并释放不在使用的内存  ','6DD3628513804EB78FB74DB67E45D1C5'),(8031,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','6DD3628513804EB78FB74DB67E45D1C5'),(8032,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','6DD3628513804EB78FB74DB67E45D1C5'),(8033,'a','编译错误 ','60463487E503402F90BCB9AEDDC5D99F'),(8034,'b','实现向文件record.dat追加写入字符a ','60463487E503402F90BCB9AEDDC5D99F'),(8035,'c','实现向文件record.dat覆盖写入字符a ','60463487E503402F90BCB9AEDDC5D99F'),(8036,'d','文件record.dat无任何内容 ','60463487E503402F90BCB9AEDDC5D99F'),(8037,'a','输出：4 ','9056957ADD494F589B146903CC394E98'),(8038,'b','在运行时抛出NullPointerException异常 ','9056957ADD494F589B146903CC394E98'),(8039,'c','在运行时抛出NumberFormatException异常 ','9056957ADD494F589B146903CC394E98'),(8040,'d','在运行时抛出IllegalStateException异常 ','9056957ADD494F589B146903CC394E98'),(8041,'a','输出Exception ','F1C398E465994CE79819D3F1B1C5D711'),(8042,'b','输出A,B,Exception ','F1C398E465994CE79819D3F1B1C5D711'),(8043,'c','编译失败 ','F1C398E465994CE79819D3F1B1C5D711'),(8044,'d','在运行时抛出NullPointerException异常 ','F1C398E465994CE79819D3F1B1C5D711'),(8045,'a','输出：4 ','F6A089E2962B4732914FD841EEA27C7B'),(8046,'b','在运行时抛出NullPointerException异常 ','F6A089E2962B4732914FD841EEA27C7B'),(8047,'c','在运行时抛出NumberFormatException异常 ','F6A089E2962B4732914FD841EEA27C7B'),(8048,'d','在运行时抛出IllegalStateException异常 ','F6A089E2962B4732914FD841EEA27C7B'),(8049,'a','通过调用stop()方法而停止的线程。 ','BD2A0DB0A458476282B9FC3F1ED7DB8B'),(8050,'b','通过调用sleep()方法而停止的线程。 ','BD2A0DB0A458476282B9FC3F1ED7DB8B'),(8051,'c','通过调用wait()方法而停止的线程。 ','BD2A0DB0A458476282B9FC3F1ED7DB8B'),(8052,'d','通过调用suspend()方法而停止的线程。 ','BD2A0DB0A458476282B9FC3F1ED7DB8B'),(8053,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','7664BCD2D103432D9C558937F7F5D191'),(8054,'b','垃圾收集将检查并释放不在使用的内存  ','7664BCD2D103432D9C558937F7F5D191'),(8055,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','7664BCD2D103432D9C558937F7F5D191'),(8056,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','7664BCD2D103432D9C558937F7F5D191'),(8057,'a','名为dtThread的线程为守护线程 ','DCB623C8A76E41DC816C8BAD2BB2CD59'),(8058,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','DCB623C8A76E41DC816C8BAD2BB2CD59'),(8059,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','DCB623C8A76E41DC816C8BAD2BB2CD59'),(8060,'d','main线程是守护线程 ','DCB623C8A76E41DC816C8BAD2BB2CD59'),(8061,'a','start()    ','7D36760CBC1440D69A36DF89FD013338'),(8062,'b','init()    ','7D36760CBC1440D69A36DF89FD013338'),(8063,'c','run()    ','7D36760CBC1440D69A36DF89FD013338'),(8064,'d','main()  ','7D36760CBC1440D69A36DF89FD013338'),(8065,'a','public void method( int m){...}     ','98D182F413794EBA91A9FD3F82687B21'),(8066,'b','public int method(){...} ','98D182F413794EBA91A9FD3F82687B21'),(8067,'c','public void method2(){...}    ','98D182F413794EBA91A9FD3F82687B21'),(8068,'d','public int method(int m，float f ){...} ','98D182F413794EBA91A9FD3F82687B21'),(8069,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(8070,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(8071,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(8072,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','DA5A4B2759DE4F0FAADED9613E2CF6B0'),(8073,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','13FF147C440340DA91F44B48100BE441'),(8074,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','13FF147C440340DA91F44B48100BE441'),(8075,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','13FF147C440340DA91F44B48100BE441'),(8076,'d','new InputStreamReader(\"1.dat\") ; ','13FF147C440340DA91F44B48100BE441'),(8077,'a','private synchronized Object o; ','9BE7926A8D324EECAA919855688CFB7E'),(8078,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','9BE7926A8D324EECAA919855688CFB7E'),(8079,'c','public synchronized void go() { /* code here */ } ','9BE7926A8D324EECAA919855688CFB7E'),(8080,'d','private synchronized(this) void go() { /* code here */ } ','9BE7926A8D324EECAA919855688CFB7E'),(8081,'a','名为dtThread的线程为守护线程 ','986C403E14304F7681AFEC508B7D22ED'),(8082,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','986C403E14304F7681AFEC508B7D22ED'),(8083,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','986C403E14304F7681AFEC508B7D22ED'),(8084,'d','main线程是守护线程 ','986C403E14304F7681AFEC508B7D22ED'),(8085,'a','通过调用stop()方法而停止的线程。 ','D748D3A247074CB8A7A9CB435DCD7B8D'),(8086,'b','通过调用sleep()方法而停止的线程。 ','D748D3A247074CB8A7A9CB435DCD7B8D'),(8087,'c','通过调用wait()方法而停止的线程。 ','D748D3A247074CB8A7A9CB435DCD7B8D'),(8088,'d','通过调用suspend()方法而停止的线程。 ','D748D3A247074CB8A7A9CB435DCD7B8D'),(8089,'a','InputStreamReader','AB8D8CDCCF734AC4A27E9A32322A5496'),(8090,'b','BufferedReader','AB8D8CDCCF734AC4A27E9A32322A5496'),(8091,'c','FileInputStream','AB8D8CDCCF734AC4A27E9A32322A5496'),(8092,'d','InputStream','AB8D8CDCCF734AC4A27E9A32322A5496'),(8093,'a','s>>>=3   ','D4F8F230BA3A4E2F8A56A91524D59A2B'),(8094,'b','s[3]= “X”  ','D4F8F230BA3A4E2F8A56A91524D59A2B'),(8095,'c','int i = s.length()   ','D4F8F230BA3A4E2F8A56A91524D59A2B'),(8096,'d','s = s + 10 ','D4F8F230BA3A4E2F8A56A91524D59A2B'),(8097,'a','InputStreamReader','5233EDE8FDF745DE834CD083CC59E1E3'),(8098,'b','BufferedReader','5233EDE8FDF745DE834CD083CC59E1E3'),(8099,'c','FileInputStream','5233EDE8FDF745DE834CD083CC59E1E3'),(8100,'d','InputStream','5233EDE8FDF745DE834CD083CC59E1E3'),(8101,'a','5.0','3BC8A89BCE1746088FEABCD2902DD7B4'),(8102,'b','4.0','3BC8A89BCE1746088FEABCD2902DD7B4'),(8103,'c','6.0','3BC8A89BCE1746088FEABCD2902DD7B4'),(8104,'d','finished','3BC8A89BCE1746088FEABCD2902DD7B4'),(8105,'a','输出Exception ','CB4517418A7D4638A670C424823870F6'),(8106,'b','输出A,B,Exception ','CB4517418A7D4638A670C424823870F6'),(8107,'c','编译失败 ','CB4517418A7D4638A670C424823870F6'),(8108,'d','在运行时抛出NullPointerException异常 ','CB4517418A7D4638A670C424823870F6'),(8109,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','2492AFAA298E4BA4AD1F3075065F87CF'),(8110,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','2492AFAA298E4BA4AD1F3075065F87CF'),(8111,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','2492AFAA298E4BA4AD1F3075065F87CF'),(8112,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','2492AFAA298E4BA4AD1F3075065F87CF'),(8113,'a','栈是非线性结构        ','821254307B414DA98D8E60D2B0D0F1EF'),(8114,'b','栈是一种树状结构 ','821254307B414DA98D8E60D2B0D0F1EF'),(8115,'c','栈具有先进先出的特征  ','821254307B414DA98D8E60D2B0D0F1EF'),(8116,'d','栈具有后进先出的特征 ','821254307B414DA98D8E60D2B0D0F1EF'),(8117,'a','Output is null.             ','FBEA8FADE35345F3AF5F5F0574DA5002'),(8118,'b','Output is 0 ','FBEA8FADE35345F3AF5F5F0574DA5002'),(8119,'c','编译时报错 ','FBEA8FADE35345F3AF5F5F0574DA5002'),(8120,'d','运行时报错','FBEA8FADE35345F3AF5F5F0574DA5002'),(8121,'a','sleep方法 ','DDF25A56E5C14B95B5BF19E91728E051'),(8122,'b','IO等待 ','DDF25A56E5C14B95B5BF19E91728E051'),(8123,'c','yield方法 ','DDF25A56E5C14B95B5BF19E91728E051'),(8124,'d','wait方法 ','DDF25A56E5C14B95B5BF19E91728E051'),(8125,'a','编译错误 ','4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(8126,'b','程序可以通过编译，运行后文件company.txt没有任何改变','4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(8127,'c','程序可以通过编译，运行后文件company.txt的长度变为0','4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(8128,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','4EEDDBF4AA624D2B9C3F7E27CCCBD70E'),(8129,'a','通过调用stop()方法而停止的线程。 ','D81102D7D14241F8B371716B0FD4859A'),(8130,'b','通过调用sleep()方法而停止的线程。 ','D81102D7D14241F8B371716B0FD4859A'),(8131,'c','通过调用wait()方法而停止的线程。 ','D81102D7D14241F8B371716B0FD4859A'),(8132,'d','通过调用suspend()方法而停止的线程。 ','D81102D7D14241F8B371716B0FD4859A'),(8133,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','794BCCC1DBEB45518A8D0363904E0C4B'),(8134,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','794BCCC1DBEB45518A8D0363904E0C4B'),(8135,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','794BCCC1DBEB45518A8D0363904E0C4B'),(8136,'d','new InputStreamReader(\"1.dat\") ; ','794BCCC1DBEB45518A8D0363904E0C4B'),(8137,'a','一旦一个线程被创建，它就立即开始运行。  ','C705F7FABB504D9BBAF826DA3D21E59C'),(8138,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','C705F7FABB504D9BBAF826DA3D21E59C'),(8139,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','C705F7FABB504D9BBAF826DA3D21E59C'),(8140,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','C705F7FABB504D9BBAF826DA3D21E59C'),(8141,'a','Output is null.             ','41DE0D476F494701B834BBE012FAFD78'),(8142,'b','Output is 0 ','41DE0D476F494701B834BBE012FAFD78'),(8143,'c','编译时报错 ','41DE0D476F494701B834BBE012FAFD78'),(8144,'d','运行时报错','41DE0D476F494701B834BBE012FAFD78'),(8145,'a','m.length()    ','41742C6B9CF94E5781F45D0F061055C7'),(8146,'b','m.length   ','41742C6B9CF94E5781F45D0F061055C7'),(8147,'c','m.length()+1   ','41742C6B9CF94E5781F45D0F061055C7'),(8148,'d','m.length-1','41742C6B9CF94E5781F45D0F061055C7'),(8149,'a','s>>>=3   ','C575292F078447AD9941B6E6E42F0806'),(8150,'b','s[3]= “X”  ','C575292F078447AD9941B6E6E42F0806'),(8151,'c','int i = s.length()   ','C575292F078447AD9941B6E6E42F0806'),(8152,'d','s = s + 10 ','C575292F078447AD9941B6E6E42F0806'),(8153,'a','编译错误 ','C99E82801F1E45F086DE9F96D80C993B'),(8154,'b','程序可以通过编译，运行后文件company.txt没有任何改变','C99E82801F1E45F086DE9F96D80C993B'),(8155,'c','程序可以通过编译，运行后文件company.txt的长度变为0','C99E82801F1E45F086DE9F96D80C993B'),(8156,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','C99E82801F1E45F086DE9F96D80C993B'),(8157,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','B4EF7856980E43748E7B9859F808E67B'),(8158,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','B4EF7856980E43748E7B9859F808E67B'),(8159,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','B4EF7856980E43748E7B9859F808E67B'),(8160,'d','new InputStreamReader(\"dat\") ; ','B4EF7856980E43748E7B9859F808E67B'),(8161,'a','private synchronized Object o; ','E2AFBF3B95694022BEFE20EC4C7B747C'),(8162,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','E2AFBF3B95694022BEFE20EC4C7B747C'),(8163,'c','public synchronized void go() { /* code here */ } ','E2AFBF3B95694022BEFE20EC4C7B747C'),(8164,'d','private synchronized(this) void go() { /* code here */ } ','E2AFBF3B95694022BEFE20EC4C7B747C'),(8165,'a','InputStreamReader','74260B92A33447CF9FDA8BA2E2A685BA'),(8166,'b','BufferedReader','74260B92A33447CF9FDA8BA2E2A685BA'),(8167,'c','FileInputStream','74260B92A33447CF9FDA8BA2E2A685BA'),(8168,'d','InputStream','74260B92A33447CF9FDA8BA2E2A685BA'),(8169,'a','InputStreamReader','3CA7D367EB0F4607A7DC39B5DE62EFAA'),(8170,'b','BufferedReader','3CA7D367EB0F4607A7DC39B5DE62EFAA'),(8171,'c','FileInputStream','3CA7D367EB0F4607A7DC39B5DE62EFAA'),(8172,'d','InputStream','3CA7D367EB0F4607A7DC39B5DE62EFAA'),(8173,'a','编译错误 ','37AD758E189C4B4CBDE223B1FB7D61AB'),(8174,'b','实现向文件record.dat追加写入字符a ','37AD758E189C4B4CBDE223B1FB7D61AB'),(8175,'c','实现向文件record.dat覆盖写入字符a ','37AD758E189C4B4CBDE223B1FB7D61AB'),(8176,'d','文件record.dat无任何内容 ','37AD758E189C4B4CBDE223B1FB7D61AB'),(8177,'a','编译错误 ','0752EF6EDDDE455CA6C49863140CB513'),(8178,'b','实现向文件record.dat追加写入字符a ','0752EF6EDDDE455CA6C49863140CB513'),(8179,'c','实现向文件record.dat覆盖写入字符a ','0752EF6EDDDE455CA6C49863140CB513'),(8180,'d','文件record.dat无任何内容 ','0752EF6EDDDE455CA6C49863140CB513'),(8181,'a','名为dtThread的线程为守护线程 ','94D6EAFD46BE4F4A9118805424CEAE15'),(8182,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','94D6EAFD46BE4F4A9118805424CEAE15'),(8183,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','94D6EAFD46BE4F4A9118805424CEAE15'),(8184,'d','main线程是守护线程 ','94D6EAFD46BE4F4A9118805424CEAE15'),(8185,'a','start()    ','554F8738DEC2458DB09FB66BA804C373'),(8186,'b','init()    ','554F8738DEC2458DB09FB66BA804C373'),(8187,'c','run()    ','554F8738DEC2458DB09FB66BA804C373'),(8188,'d','main()  ','554F8738DEC2458DB09FB66BA804C373'),(8189,'a','const   ','55503C2075384150A0659E86B2B4D051'),(8190,'b','NULL  ','55503C2075384150A0659E86B2B4D051'),(8191,'c','false   ','55503C2075384150A0659E86B2B4D051'),(8192,'d','this  ','55503C2075384150A0659E86B2B4D051'),(8193,'a','名为dtThread的线程为守护线程 ','82E933EC76DB4F0CBD957CAE393EC4CB'),(8194,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','82E933EC76DB4F0CBD957CAE393EC4CB'),(8195,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','82E933EC76DB4F0CBD957CAE393EC4CB'),(8196,'d','main线程是守护线程 ','82E933EC76DB4F0CBD957CAE393EC4CB'),(8197,'a','第3行抛出异常 ','E8271D4DD51A47F194BBFFED7C32E7EF'),(8198,'b','第1行抛出异常 ','E8271D4DD51A47F194BBFFED7C32E7EF'),(8199,'c','第5行抛出异常 ','E8271D4DD51A47F194BBFFED7C32E7EF'),(8200,'d','第3行代码成功执行 ','E8271D4DD51A47F194BBFFED7C32E7EF'),(8201,'a','private synchronized Object o; ','FDEAEEFB35D24043BB41228EFDB76CC6'),(8202,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','FDEAEEFB35D24043BB41228EFDB76CC6'),(8203,'c','public synchronized void go() { /* code here */ } ','FDEAEEFB35D24043BB41228EFDB76CC6'),(8204,'d','private synchronized(this) void go() { /* code here */ } ','FDEAEEFB35D24043BB41228EFDB76CC6'),(8205,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','2D439F41FCCF4CFD91ED5028D3A3F38D'),(8206,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','2D439F41FCCF4CFD91ED5028D3A3F38D'),(8207,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','2D439F41FCCF4CFD91ED5028D3A3F38D'),(8208,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','2D439F41FCCF4CFD91ED5028D3A3F38D'),(8209,'a','start()    ','264C6D0D5C0E4EE99174003E5DFD1518'),(8210,'b','init()    ','264C6D0D5C0E4EE99174003E5DFD1518'),(8211,'c','run()    ','264C6D0D5C0E4EE99174003E5DFD1518'),(8212,'d','main()  ','264C6D0D5C0E4EE99174003E5DFD1518'),(8213,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','542393BDDF05480EB13913316E281D9E'),(8214,'b','垃圾收集将检查并释放不在使用的内存  ','542393BDDF05480EB13913316E281D9E'),(8215,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','542393BDDF05480EB13913316E281D9E'),(8216,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','542393BDDF05480EB13913316E281D9E'),(8217,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','B5A0BD7BB821475EA9EBACF96B2BDAEE'),(8218,'b','垃圾收集将检查并释放不在使用的内存  ','B5A0BD7BB821475EA9EBACF96B2BDAEE'),(8219,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','B5A0BD7BB821475EA9EBACF96B2BDAEE'),(8220,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','B5A0BD7BB821475EA9EBACF96B2BDAEE'),(8221,'a','输出Exception ','3A42BE66869346008A79E67FFD6DAFFA'),(8222,'b','输出A,B,Exception ','3A42BE66869346008A79E67FFD6DAFFA'),(8223,'c','编译失败 ','3A42BE66869346008A79E67FFD6DAFFA'),(8224,'d','在运行时抛出NullPointerException异常 ','3A42BE66869346008A79E67FFD6DAFFA'),(8225,'a','通过调用stop()方法而停止的线程。 ','A17978990F384C2A8561854648E23BA3'),(8226,'b','通过调用sleep()方法而停止的线程。 ','A17978990F384C2A8561854648E23BA3'),(8227,'c','通过调用wait()方法而停止的线程。 ','A17978990F384C2A8561854648E23BA3'),(8228,'d','通过调用suspend()方法而停止的线程。 ','A17978990F384C2A8561854648E23BA3'),(8229,'a','5.0','6B969D3F35E54FF7AE3FF917E75B43C3'),(8230,'b','4.0','6B969D3F35E54FF7AE3FF917E75B43C3'),(8231,'c','6.0','6B969D3F35E54FF7AE3FF917E75B43C3'),(8232,'d','finished','6B969D3F35E54FF7AE3FF917E75B43C3'),(8233,'a','m.length()    ','D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(8234,'b','m.length   ','D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(8235,'c','m.length()+1   ','D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(8236,'d','m.length-1','D38A8CCE1E6F42B78FF3B29A3CBCF45B'),(8237,'a','Output is null.             ','574E332F6CE849C38EB921C4BD14EDE4'),(8238,'b','Output is 0 ','574E332F6CE849C38EB921C4BD14EDE4'),(8239,'c','编译时报错 ','574E332F6CE849C38EB921C4BD14EDE4'),(8240,'d','运行时报错','574E332F6CE849C38EB921C4BD14EDE4'),(8241,'a','第3行抛出异常 ','08CEF9E8D3794A60B0E2BA898B4D0372'),(8242,'b','第1行抛出异常 ','08CEF9E8D3794A60B0E2BA898B4D0372'),(8243,'c','第5行抛出异常 ','08CEF9E8D3794A60B0E2BA898B4D0372'),(8244,'d','第3行代码成功执行 ','08CEF9E8D3794A60B0E2BA898B4D0372'),(8245,'a','start()    ','F94B004065BE4789BE003DDBA9E5A7E1'),(8246,'b','init()    ','F94B004065BE4789BE003DDBA9E5A7E1'),(8247,'c','run()    ','F94B004065BE4789BE003DDBA9E5A7E1'),(8248,'d','main()  ','F94B004065BE4789BE003DDBA9E5A7E1'),(8249,'a','一旦一个线程被创建，它就立即开始运行。  ','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(8250,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(8251,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(8252,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','E4E4FC0713AF4C38BDBFAAFE1E270F05'),(8253,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','77E24907FDE74C0EB6352655D741202E'),(8254,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','77E24907FDE74C0EB6352655D741202E'),(8255,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','77E24907FDE74C0EB6352655D741202E'),(8256,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','77E24907FDE74C0EB6352655D741202E'),(8257,'a','编译错误 ','32F637F4383F4B4D9F732FFDFEAE0241'),(8258,'b','抛出运行时异常 ','32F637F4383F4B4D9F732FFDFEAE0241'),(8259,'c','输出：bar ','32F637F4383F4B4D9F732FFDFEAE0241'),(8260,'d','代码正常运行，但是无输出 ','32F637F4383F4B4D9F732FFDFEAE0241'),(8261,'a','名为dtThread的线程为守护线程 ','2123A75041FD4CA497B8EBBCCE055F3C'),(8262,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','2123A75041FD4CA497B8EBBCCE055F3C'),(8263,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','2123A75041FD4CA497B8EBBCCE055F3C'),(8264,'d','main线程是守护线程 ','2123A75041FD4CA497B8EBBCCE055F3C'),(8265,'a','public void method( int m){...}     ','689F9322E20C4CA9B8F9CFCD95B4CEED'),(8266,'b','public int method(){...} ','689F9322E20C4CA9B8F9CFCD95B4CEED'),(8267,'c','public void method2(){...}    ','689F9322E20C4CA9B8F9CFCD95B4CEED'),(8268,'d','public int method(int m，float f ){...} ','689F9322E20C4CA9B8F9CFCD95B4CEED'),(8269,'a','输出Exception ','F682AE42507E4309BECEFD302C366344'),(8270,'b','输出A,B,Exception ','F682AE42507E4309BECEFD302C366344'),(8271,'c','编译失败 ','F682AE42507E4309BECEFD302C366344'),(8272,'d','在运行时抛出NullPointerException异常 ','F682AE42507E4309BECEFD302C366344'),(8273,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','7A1F95C5B0624DF699C792459FFA8EA5'),(8274,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','7A1F95C5B0624DF699C792459FFA8EA5'),(8275,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','7A1F95C5B0624DF699C792459FFA8EA5'),(8276,'d','new InputStreamReader(\"dat\") ; ','7A1F95C5B0624DF699C792459FFA8EA5'),(8277,'a','s>>>=3   ','98F3972BF354428297A1CC43A6285CE5'),(8278,'b','s[3]= “X”  ','98F3972BF354428297A1CC43A6285CE5'),(8279,'c','int i = s.length()   ','98F3972BF354428297A1CC43A6285CE5'),(8280,'d','s = s + 10 ','98F3972BF354428297A1CC43A6285CE5'),(8281,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','D21C46A2C9DA4A79ACEC1076F926122A'),(8282,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','D21C46A2C9DA4A79ACEC1076F926122A'),(8283,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','D21C46A2C9DA4A79ACEC1076F926122A'),(8284,'d','new InputStreamReader(\"1.dat\") ; ','D21C46A2C9DA4A79ACEC1076F926122A'),(8285,'a','栈是非线性结构        ','AE336B519BE94C9EA807AEBEB2FE34A2'),(8286,'b','栈是一种树状结构 ','AE336B519BE94C9EA807AEBEB2FE34A2'),(8287,'c','栈具有先进先出的特征  ','AE336B519BE94C9EA807AEBEB2FE34A2'),(8288,'d','栈具有后进先出的特征 ','AE336B519BE94C9EA807AEBEB2FE34A2'),(8289,'a','一旦一个线程被创建，它就立即开始运行。  ','52B2DA7003194018B637440BB6D5117C'),(8290,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','52B2DA7003194018B637440BB6D5117C'),(8291,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','52B2DA7003194018B637440BB6D5117C'),(8292,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','52B2DA7003194018B637440BB6D5117C'),(8293,'a','public void method( int m){...}     ','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(8294,'b','public int method(){...} ','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(8295,'c','public void method2(){...}    ','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(8296,'d','public int method(int m，float f ){...} ','7D3EB85B9CD34EB4A01F30FD3DBE9E5F'),(8297,'a','编译错误 ','BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(8298,'b','抛出运行时异常 ','BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(8299,'c','输出：bar ','BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(8300,'d','代码正常运行，但是无输出 ','BD6D383BCE5B48B5B0A0A1DF8F6FFBF2'),(8301,'a','编译错误 ','6C821B72A9E34DA3B8EC452A28BA8DD1'),(8302,'b','实现向文件record.dat追加写入字符a ','6C821B72A9E34DA3B8EC452A28BA8DD1'),(8303,'c','实现向文件record.dat覆盖写入字符a ','6C821B72A9E34DA3B8EC452A28BA8DD1'),(8304,'d','文件record.dat无任何内容 ','6C821B72A9E34DA3B8EC452A28BA8DD1'),(8305,'a','const   ','40021C153BB641B9A9DB258639614CA5'),(8306,'b','NULL  ','40021C153BB641B9A9DB258639614CA5'),(8307,'c','false   ','40021C153BB641B9A9DB258639614CA5'),(8308,'d','this  ','40021C153BB641B9A9DB258639614CA5'),(8309,'a','m.length()    ','81DE7B424655498DBE033A8DE42BE687'),(8310,'b','m.length   ','81DE7B424655498DBE033A8DE42BE687'),(8311,'c','m.length()+1   ','81DE7B424655498DBE033A8DE42BE687'),(8312,'d','m.length-1','81DE7B424655498DBE033A8DE42BE687'),(8313,'a','long 1 = 4990  ','23FA63D45DDF4D34B5385DFE651B0704'),(8314,'b','int i = 4L  ','23FA63D45DDF4D34B5385DFE651B0704'),(8315,'c','float f =1.1  ','23FA63D45DDF4D34B5385DFE651B0704'),(8316,'d','double d = 34.4','23FA63D45DDF4D34B5385DFE651B0704'),(8317,'a','输出：4 ','DAFDF3AF99734E7D9C59FF42A763FA41'),(8318,'b','在运行时抛出NullPointerException异常 ','DAFDF3AF99734E7D9C59FF42A763FA41'),(8319,'c','在运行时抛出NumberFormatException异常 ','DAFDF3AF99734E7D9C59FF42A763FA41'),(8320,'d','在运行时抛出IllegalStateException异常 ','DAFDF3AF99734E7D9C59FF42A763FA41'),(8321,'a','输出Exception ','A564020B59D84B2691A011045C3F1E8F'),(8322,'b','输出A,B,Exception ','A564020B59D84B2691A011045C3F1E8F'),(8323,'c','编译失败 ','A564020B59D84B2691A011045C3F1E8F'),(8324,'d','在运行时抛出NullPointerException异常 ','A564020B59D84B2691A011045C3F1E8F'),(8325,'a','通过调用stop()方法而停止的线程。 ','65FE9164C46042FC9E5249702D2DB01B'),(8326,'b','通过调用sleep()方法而停止的线程。 ','65FE9164C46042FC9E5249702D2DB01B'),(8327,'c','通过调用wait()方法而停止的线程。 ','65FE9164C46042FC9E5249702D2DB01B'),(8328,'d','通过调用suspend()方法而停止的线程。 ','65FE9164C46042FC9E5249702D2DB01B'),(8329,'a','long 1 = 4990  ','950D0F13630F413E8AC7C1204B8BF3A7'),(8330,'b','int i = 4L  ','950D0F13630F413E8AC7C1204B8BF3A7'),(8331,'c','float f =1.1  ','950D0F13630F413E8AC7C1204B8BF3A7'),(8332,'d','double d = 34.4','950D0F13630F413E8AC7C1204B8BF3A7'),(8333,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','FFDE9803781140E3AB49D331BAD62C68'),(8334,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','FFDE9803781140E3AB49D331BAD62C68'),(8335,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','FFDE9803781140E3AB49D331BAD62C68'),(8336,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','FFDE9803781140E3AB49D331BAD62C68'),(8337,'a','long 1 = 4990  ','7D356A076A924E8BB828CC797A02E772'),(8338,'b','int i = 4L  ','7D356A076A924E8BB828CC797A02E772'),(8339,'c','float f =1.1  ','7D356A076A924E8BB828CC797A02E772'),(8340,'d','double d = 34.4','7D356A076A924E8BB828CC797A02E772'),(8341,'a','编译错误 ','26D1F529943A4563BD9F9E90072998BD'),(8342,'b','抛出运行时异常 ','26D1F529943A4563BD9F9E90072998BD'),(8343,'c','输出：sleep ','26D1F529943A4563BD9F9E90072998BD'),(8344,'d','代码正常运行，但是无输出 ','26D1F529943A4563BD9F9E90072998BD'),(8345,'a','输出：test ','435FA646B2DC42C491410E5B3380E9B9'),(8346,'b','输出：Exception ','435FA646B2DC42C491410E5B3380E9B9'),(8347,'c','编译失败 ','435FA646B2DC42C491410E5B3380E9B9'),(8348,'d','输出：NullPointerException ','435FA646B2DC42C491410E5B3380E9B9'),(8349,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','37D7BA4ED95445449703BDF24D75F468'),(8350,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','37D7BA4ED95445449703BDF24D75F468'),(8351,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','37D7BA4ED95445449703BDF24D75F468'),(8352,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','37D7BA4ED95445449703BDF24D75F468'),(8353,'a','将private int m改为 protected int m  ','CC5D1A99998A4A6283EB1401734E0928'),(8354,'b','将private int m改为 public int m    ','CC5D1A99998A4A6283EB1401734E0928'),(8355,'c','将private int m改为 static int m     ','CC5D1A99998A4A6283EB1401734E0928'),(8356,'d','将private int m改为int m ','CC5D1A99998A4A6283EB1401734E0928'),(8357,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','88832E08CCCE4FAF989D4AC973C5287C'),(8358,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','88832E08CCCE4FAF989D4AC973C5287C'),(8359,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','88832E08CCCE4FAF989D4AC973C5287C'),(8360,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','88832E08CCCE4FAF989D4AC973C5287C'),(8361,'a','Output is null.             ','3AEB1FFADDBD46E188F3DC98EBAE5E13'),(8362,'b','Output is 0 ','3AEB1FFADDBD46E188F3DC98EBAE5E13'),(8363,'c','编译时报错 ','3AEB1FFADDBD46E188F3DC98EBAE5E13'),(8364,'d','运行时报错','3AEB1FFADDBD46E188F3DC98EBAE5E13'),(8365,'a','输出：test ','19747CBB70304669961950CFB1930E1A'),(8366,'b','输出：Exception ','19747CBB70304669961950CFB1930E1A'),(8367,'c','编译失败 ','19747CBB70304669961950CFB1930E1A'),(8368,'d','输出：NullPointerException ','19747CBB70304669961950CFB1930E1A'),(8369,'a','输出：test ','C70C3434ABFC4EE19B5EC06B8F7C59FD'),(8370,'b','输出：Exception ','C70C3434ABFC4EE19B5EC06B8F7C59FD'),(8371,'c','编译失败 ','C70C3434ABFC4EE19B5EC06B8F7C59FD'),(8372,'d','输出：NullPointerException ','C70C3434ABFC4EE19B5EC06B8F7C59FD'),(8373,'a','InputStreamReader','4AB398CB7DDA459A88B1E1F57E3EC6EE'),(8374,'b','BufferedReader','4AB398CB7DDA459A88B1E1F57E3EC6EE'),(8375,'c','FileInputStream','4AB398CB7DDA459A88B1E1F57E3EC6EE'),(8376,'d','InputStream','4AB398CB7DDA459A88B1E1F57E3EC6EE'),(8377,'a','5.0','D95DDC8A41EC44B284C6EBA47DA05436'),(8378,'b','4.0','D95DDC8A41EC44B284C6EBA47DA05436'),(8379,'c','6.0','D95DDC8A41EC44B284C6EBA47DA05436'),(8380,'d','finished','D95DDC8A41EC44B284C6EBA47DA05436'),(8381,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','F8FD938EC2B744149757D0BD8D4EA614'),(8382,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','F8FD938EC2B744149757D0BD8D4EA614'),(8383,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','F8FD938EC2B744149757D0BD8D4EA614'),(8384,'d','new InputStreamReader(\"1.dat\") ; ','F8FD938EC2B744149757D0BD8D4EA614'),(8385,'a','将private int m改为 protected int m  ','2BB702A78FD644FD8AEF5B13EA24AEB9'),(8386,'b','将private int m改为 public int m    ','2BB702A78FD644FD8AEF5B13EA24AEB9'),(8387,'c','将private int m改为 static int m     ','2BB702A78FD644FD8AEF5B13EA24AEB9'),(8388,'d','将private int m改为int m ','2BB702A78FD644FD8AEF5B13EA24AEB9'),(8389,'a','const   ','E53765164D154D50B8A656C344ED1622'),(8390,'b','NULL  ','E53765164D154D50B8A656C344ED1622'),(8391,'c','false   ','E53765164D154D50B8A656C344ED1622'),(8392,'d','this  ','E53765164D154D50B8A656C344ED1622'),(8393,'a','编译错误 ','C3BA7DD5E21647FC9CF238D991B6FAB5'),(8394,'b','实现向文件record.dat追加写入字符a ','C3BA7DD5E21647FC9CF238D991B6FAB5'),(8395,'c','实现向文件record.dat覆盖写入字符a ','C3BA7DD5E21647FC9CF238D991B6FAB5'),(8396,'d','文件record.dat无任何内容 ','C3BA7DD5E21647FC9CF238D991B6FAB5'),(8397,'a','编译错误 ','887695A4D51D4573B31901AD8FD3DB14'),(8398,'b','程序可以通过编译，运行后文件company.txt没有任何改变','887695A4D51D4573B31901AD8FD3DB14'),(8399,'c','程序可以通过编译，运行后文件company.txt的长度变为0','887695A4D51D4573B31901AD8FD3DB14'),(8400,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','887695A4D51D4573B31901AD8FD3DB14'),(8401,'a','sleep方法 ','6DC12F24337F4978B6BB3B6F29039D8D'),(8402,'b','IO等待 ','6DC12F24337F4978B6BB3B6F29039D8D'),(8403,'c','yield方法 ','6DC12F24337F4978B6BB3B6F29039D8D'),(8404,'d','wait方法 ','6DC12F24337F4978B6BB3B6F29039D8D'),(8405,'a','private synchronized Object o; ','C31F06002D4C4FBC80175DEEDF52CEF2'),(8406,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','C31F06002D4C4FBC80175DEEDF52CEF2'),(8407,'c','public synchronized void go() { /* code here */ } ','C31F06002D4C4FBC80175DEEDF52CEF2'),(8408,'d','private synchronized(this) void go() { /* code here */ } ','C31F06002D4C4FBC80175DEEDF52CEF2'),(8409,'a','将private int m改为 protected int m  ','430FE9095C004F3C9109EBB676B1279B'),(8410,'b','将private int m改为 public int m    ','430FE9095C004F3C9109EBB676B1279B'),(8411,'c','将private int m改为 static int m     ','430FE9095C004F3C9109EBB676B1279B'),(8412,'d','将private int m改为int m ','430FE9095C004F3C9109EBB676B1279B'),(8413,'a','sleep方法 ','43446A3C28F645D4899221ADE47FEA60'),(8414,'b','IO等待 ','43446A3C28F645D4899221ADE47FEA60'),(8415,'c','yield方法 ','43446A3C28F645D4899221ADE47FEA60'),(8416,'d','wait方法 ','43446A3C28F645D4899221ADE47FEA60'),(8417,'a','编译错误 ','BED615F09A814F769EDD8CD78CCD3DDD'),(8418,'b','抛出运行时异常 ','BED615F09A814F769EDD8CD78CCD3DDD'),(8419,'c','输出：sleep ','BED615F09A814F769EDD8CD78CCD3DDD'),(8420,'d','代码正常运行，但是无输出 ','BED615F09A814F769EDD8CD78CCD3DDD'),(8421,'a','编译错误 ','7D8F6FAB08C247069D94717924151EEB'),(8422,'b','抛出运行时异常 ','7D8F6FAB08C247069D94717924151EEB'),(8423,'c','输出：bar ','7D8F6FAB08C247069D94717924151EEB'),(8424,'d','代码正常运行，但是无输出 ','7D8F6FAB08C247069D94717924151EEB'),(8425,'a','栈是非线性结构        ','CF41A0C354414167906FCDDB9290B8F4'),(8426,'b','栈是一种树状结构 ','CF41A0C354414167906FCDDB9290B8F4'),(8427,'c','栈具有先进先出的特征  ','CF41A0C354414167906FCDDB9290B8F4'),(8428,'d','栈具有后进先出的特征 ','CF41A0C354414167906FCDDB9290B8F4'),(8429,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(8430,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(8431,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(8432,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','B6D0D17B82A74EFD8DB0E3921A8D6CC7'),(8433,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','8354BA5ED5BC4B3BADC817F11CD9F351'),(8434,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','8354BA5ED5BC4B3BADC817F11CD9F351'),(8435,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','8354BA5ED5BC4B3BADC817F11CD9F351'),(8436,'d','new InputStreamReader(\"dat\") ; ','8354BA5ED5BC4B3BADC817F11CD9F351'),(8437,'a','输出：4 ','7D2CB2D41DE946918514CAFDAC4C874A'),(8438,'b','在运行时抛出NullPointerException异常 ','7D2CB2D41DE946918514CAFDAC4C874A'),(8439,'c','在运行时抛出NumberFormatException异常 ','7D2CB2D41DE946918514CAFDAC4C874A'),(8440,'d','在运行时抛出IllegalStateException异常 ','7D2CB2D41DE946918514CAFDAC4C874A'),(8441,'a','输出：4 ','0D7CD7C532FA4B2692597B598CC88D28'),(8442,'b','在运行时抛出NullPointerException异常 ','0D7CD7C532FA4B2692597B598CC88D28'),(8443,'c','在运行时抛出NumberFormatException异常 ','0D7CD7C532FA4B2692597B598CC88D28'),(8444,'d','在运行时抛出IllegalStateException异常 ','0D7CD7C532FA4B2692597B598CC88D28'),(8445,'a','第3行抛出异常 ','47FA650F96204794AD1916AAA6191136'),(8446,'b','第1行抛出异常 ','47FA650F96204794AD1916AAA6191136'),(8447,'c','第5行抛出异常 ','47FA650F96204794AD1916AAA6191136'),(8448,'d','第3行代码成功执行 ','47FA650F96204794AD1916AAA6191136'),(8449,'a','public void method( int m){...}     ','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(8450,'b','public int method(){...} ','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(8451,'c','public void method2(){...}    ','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(8452,'d','public int method(int m，float f ){...} ','EA30B5319DE74B6181E8FDBDB8D8DFF1'),(8453,'a','编译错误 ','2BB4C85CF8844AC3978033DBFBA7E9E0'),(8454,'b','实现向文件record.dat追加写入字符a ','2BB4C85CF8844AC3978033DBFBA7E9E0'),(8455,'c','实现向文件record.dat覆盖写入字符a ','2BB4C85CF8844AC3978033DBFBA7E9E0'),(8456,'d','文件record.dat无任何内容 ','2BB4C85CF8844AC3978033DBFBA7E9E0'),(8457,'a','m.length()    ','13F6A99EF75F45A4827E6C2A75E8323A'),(8458,'b','m.length   ','13F6A99EF75F45A4827E6C2A75E8323A'),(8459,'c','m.length()+1   ','13F6A99EF75F45A4827E6C2A75E8323A'),(8460,'d','m.length-1','13F6A99EF75F45A4827E6C2A75E8323A'),(8461,'a','编译错误 ','0A291639601848D282938F42AB2D373F'),(8462,'b','抛出运行时异常 ','0A291639601848D282938F42AB2D373F'),(8463,'c','输出：bar ','0A291639601848D282938F42AB2D373F'),(8464,'d','代码正常运行，但是无输出 ','0A291639601848D282938F42AB2D373F'),(8465,'a','编译错误 ','7936CE192D814BD68328C4B805823371'),(8466,'b','抛出运行时异常 ','7936CE192D814BD68328C4B805823371'),(8467,'c','输出：bar ','7936CE192D814BD68328C4B805823371'),(8468,'d','代码正常运行，但是无输出 ','7936CE192D814BD68328C4B805823371'),(8469,'a','输出：4 ','19732F19153544BC99D4DF571B059685'),(8470,'b','在运行时抛出NullPointerException异常 ','19732F19153544BC99D4DF571B059685'),(8471,'c','在运行时抛出NumberFormatException异常 ','19732F19153544BC99D4DF571B059685'),(8472,'d','在运行时抛出IllegalStateException异常 ','19732F19153544BC99D4DF571B059685'),(8473,'a','名为dtThread的线程为守护线程 ','BF2CB74919AD4E1A950C0FFAE4423746'),(8474,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','BF2CB74919AD4E1A950C0FFAE4423746'),(8475,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','BF2CB74919AD4E1A950C0FFAE4423746'),(8476,'d','main线程是守护线程 ','BF2CB74919AD4E1A950C0FFAE4423746'),(8477,'a','通过调用stop()方法而停止的线程。 ','8C168A6DCDAA441F9997C7B0429067C5'),(8478,'b','通过调用sleep()方法而停止的线程。 ','8C168A6DCDAA441F9997C7B0429067C5'),(8479,'c','通过调用wait()方法而停止的线程。 ','8C168A6DCDAA441F9997C7B0429067C5'),(8480,'d','通过调用suspend()方法而停止的线程。 ','8C168A6DCDAA441F9997C7B0429067C5'),(8481,'a','5.0','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(8482,'b','4.0','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(8483,'c','6.0','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(8484,'d','finished','D2C5E6687B564BF88E3FBC2BD1C7AD3B'),(8485,'a','一旦一个线程被创建，它就立即开始运行。  ','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(8486,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(8487,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(8488,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','853DCDBAFD7D4B2CA9140691ABC4C7AB'),(8489,'a','s>>>=3   ','204884AD6616437CAA06B0071FDFEDBB'),(8490,'b','s[3]= “X”  ','204884AD6616437CAA06B0071FDFEDBB'),(8491,'c','int i = s.length()   ','204884AD6616437CAA06B0071FDFEDBB'),(8492,'d','s = s + 10 ','204884AD6616437CAA06B0071FDFEDBB'),(8493,'a','const   ','32E342CE591C48019499D242A3FA141B'),(8494,'b','NULL  ','32E342CE591C48019499D242A3FA141B'),(8495,'c','false   ','32E342CE591C48019499D242A3FA141B'),(8496,'d','this  ','32E342CE591C48019499D242A3FA141B'),(8497,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','BE7FA24BD9BD441C9947856D2F4B801E'),(8498,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','BE7FA24BD9BD441C9947856D2F4B801E'),(8499,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','BE7FA24BD9BD441C9947856D2F4B801E'),(8500,'d','new InputStreamReader(\"dat\") ; ','BE7FA24BD9BD441C9947856D2F4B801E'),(8501,'a','第3行抛出异常 ','0DD5F77D69F24CACAD16D51259D3F97E'),(8502,'b','第1行抛出异常 ','0DD5F77D69F24CACAD16D51259D3F97E'),(8503,'c','第5行抛出异常 ','0DD5F77D69F24CACAD16D51259D3F97E'),(8504,'d','第3行代码成功执行 ','0DD5F77D69F24CACAD16D51259D3F97E'),(8505,'a','输出Exception ','0A4B0A882BC2498CB5A8C5845736C3E3'),(8506,'b','输出A,B,Exception ','0A4B0A882BC2498CB5A8C5845736C3E3'),(8507,'c','编译失败 ','0A4B0A882BC2498CB5A8C5845736C3E3'),(8508,'d','在运行时抛出NullPointerException异常 ','0A4B0A882BC2498CB5A8C5845736C3E3'),(8509,'a','第3行抛出异常 ','A65E55C923E845BC98A71E9BE8EBEA27'),(8510,'b','第1行抛出异常 ','A65E55C923E845BC98A71E9BE8EBEA27'),(8511,'c','第5行抛出异常 ','A65E55C923E845BC98A71E9BE8EBEA27'),(8512,'d','第3行代码成功执行 ','A65E55C923E845BC98A71E9BE8EBEA27'),(8513,'a','编译错误 ','96FF1B8100254758AAB61E730FD504F6'),(8514,'b','实现向文件record.dat追加写入字符a ','96FF1B8100254758AAB61E730FD504F6'),(8515,'c','实现向文件record.dat覆盖写入字符a ','96FF1B8100254758AAB61E730FD504F6'),(8516,'d','文件record.dat无任何内容 ','96FF1B8100254758AAB61E730FD504F6'),(8517,'a','编译错误 ','0D05BD35FE5545D3BC9877D30497B5B4'),(8518,'b','实现向文件record.dat追加写入字符a ','0D05BD35FE5545D3BC9877D30497B5B4'),(8519,'c','实现向文件record.dat覆盖写入字符a ','0D05BD35FE5545D3BC9877D30497B5B4'),(8520,'d','文件record.dat无任何内容 ','0D05BD35FE5545D3BC9877D30497B5B4'),(8521,'a','输出：4 ','907C812FA29743DE9258DD4AA75B6891'),(8522,'b','在运行时抛出NullPointerException异常 ','907C812FA29743DE9258DD4AA75B6891'),(8523,'c','在运行时抛出NumberFormatException异常 ','907C812FA29743DE9258DD4AA75B6891'),(8524,'d','在运行时抛出IllegalStateException异常 ','907C812FA29743DE9258DD4AA75B6891'),(8525,'a','const   ','041C2D9C292C4FECAD356C628C2B8855'),(8526,'b','NULL  ','041C2D9C292C4FECAD356C628C2B8855'),(8527,'c','false   ','041C2D9C292C4FECAD356C628C2B8855'),(8528,'d','this  ','041C2D9C292C4FECAD356C628C2B8855'),(8529,'a','编译错误 ','DA579D4B61004E4A88071217B0FB4681'),(8530,'b','实现向文件record.dat追加写入字符a ','DA579D4B61004E4A88071217B0FB4681'),(8531,'c','实现向文件record.dat覆盖写入字符a ','DA579D4B61004E4A88071217B0FB4681'),(8532,'d','文件record.dat无任何内容 ','DA579D4B61004E4A88071217B0FB4681'),(8533,'a','通过调用stop()方法而停止的线程。 ','FE19B8FDD9724BF780886C6EDF2C7240'),(8534,'b','通过调用sleep()方法而停止的线程。 ','FE19B8FDD9724BF780886C6EDF2C7240'),(8535,'c','通过调用wait()方法而停止的线程。 ','FE19B8FDD9724BF780886C6EDF2C7240'),(8536,'d','通过调用suspend()方法而停止的线程。 ','FE19B8FDD9724BF780886C6EDF2C7240'),(8537,'a','编译错误 ','D293EF3344AD4743BE667BB79C071145'),(8538,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D293EF3344AD4743BE667BB79C071145'),(8539,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D293EF3344AD4743BE667BB79C071145'),(8540,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D293EF3344AD4743BE667BB79C071145'),(8541,'a','编译错误 ','F79726831AE443149EB651B6F4F78D16'),(8542,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F79726831AE443149EB651B6F4F78D16'),(8543,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F79726831AE443149EB651B6F4F78D16'),(8544,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F79726831AE443149EB651B6F4F78D16'),(8545,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','8D9A63138EA44A47B84637D046B6BA91'),(8546,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','8D9A63138EA44A47B84637D046B6BA91'),(8547,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','8D9A63138EA44A47B84637D046B6BA91'),(8548,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','8D9A63138EA44A47B84637D046B6BA91'),(8549,'a','栈是非线性结构        ','DCC0D546885F4B07A136BFD5CF9F57B3'),(8550,'b','栈是一种树状结构 ','DCC0D546885F4B07A136BFD5CF9F57B3'),(8551,'c','栈具有先进先出的特征  ','DCC0D546885F4B07A136BFD5CF9F57B3'),(8552,'d','栈具有后进先出的特征 ','DCC0D546885F4B07A136BFD5CF9F57B3'),(8553,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(8554,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(8555,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(8556,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','5C107ED74ACB4F4C8F6DA35DFD3D93CE'),(8557,'a','编译错误 ','0CFB7FD544D84AB1A433142DFA272701'),(8558,'b','程序可以通过编译，运行后文件company.txt没有任何改变','0CFB7FD544D84AB1A433142DFA272701'),(8559,'c','程序可以通过编译，运行后文件company.txt的长度变为0','0CFB7FD544D84AB1A433142DFA272701'),(8560,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','0CFB7FD544D84AB1A433142DFA272701'),(8561,'a','private synchronized Object o; ','E83CD3521D0540348CA629BAC36804D7'),(8562,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','E83CD3521D0540348CA629BAC36804D7'),(8563,'c','public synchronized void go() { /* code here */ } ','E83CD3521D0540348CA629BAC36804D7'),(8564,'d','private synchronized(this) void go() { /* code here */ } ','E83CD3521D0540348CA629BAC36804D7'),(8565,'a','private synchronized Object o; ','097B62E438D94105B8FCE64516C33069'),(8566,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','097B62E438D94105B8FCE64516C33069'),(8567,'c','public synchronized void go() { /* code here */ } ','097B62E438D94105B8FCE64516C33069'),(8568,'d','private synchronized(this) void go() { /* code here */ } ','097B62E438D94105B8FCE64516C33069'),(8569,'a','5.0','EF5406DD1DD744939057A196EC0FCB1F'),(8570,'b','4.0','EF5406DD1DD744939057A196EC0FCB1F'),(8571,'c','6.0','EF5406DD1DD744939057A196EC0FCB1F'),(8572,'d','finished','EF5406DD1DD744939057A196EC0FCB1F'),(8573,'a','输出：test ','4F77CD575E454E66B99EE8C15A780674'),(8574,'b','输出：Exception ','4F77CD575E454E66B99EE8C15A780674'),(8575,'c','编译失败 ','4F77CD575E454E66B99EE8C15A780674'),(8576,'d','输出：NullPointerException ','4F77CD575E454E66B99EE8C15A780674'),(8577,'a','5.0','3E55703F094C4BFAB71A559D13724FFE'),(8578,'b','4.0','3E55703F094C4BFAB71A559D13724FFE'),(8579,'c','6.0','3E55703F094C4BFAB71A559D13724FFE'),(8580,'d','finished','3E55703F094C4BFAB71A559D13724FFE'),(8581,'a','名为dtThread的线程为守护线程 ','9F0524B08DF144BC8E21C006E2771259'),(8582,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','9F0524B08DF144BC8E21C006E2771259'),(8583,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','9F0524B08DF144BC8E21C006E2771259'),(8584,'d','main线程是守护线程 ','9F0524B08DF144BC8E21C006E2771259'),(8585,'a','将private int m改为 protected int m  ','FB073C05A26649329FC7174BE0CA8E2E'),(8586,'b','将private int m改为 public int m    ','FB073C05A26649329FC7174BE0CA8E2E'),(8587,'c','将private int m改为 static int m     ','FB073C05A26649329FC7174BE0CA8E2E'),(8588,'d','将private int m改为int m ','FB073C05A26649329FC7174BE0CA8E2E'),(8589,'a','m.length()    ','797EA301F2AF4F37975671368F236DDA'),(8590,'b','m.length   ','797EA301F2AF4F37975671368F236DDA'),(8591,'c','m.length()+1   ','797EA301F2AF4F37975671368F236DDA'),(8592,'d','m.length-1','797EA301F2AF4F37975671368F236DDA'),(8593,'a','一旦一个线程被创建，它就立即开始运行。  ','884B4A3D383E4306938818C273AF6123'),(8594,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','884B4A3D383E4306938818C273AF6123'),(8595,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','884B4A3D383E4306938818C273AF6123'),(8596,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','884B4A3D383E4306938818C273AF6123'),(8597,'a','Output is null.             ','5569AEE989CF42609F70363B716E0C64'),(8598,'b','Output is 0 ','5569AEE989CF42609F70363B716E0C64'),(8599,'c','编译时报错 ','5569AEE989CF42609F70363B716E0C64'),(8600,'d','运行时报错','5569AEE989CF42609F70363B716E0C64'),(8601,'a','将private int m改为 protected int m  ','AEBA258A696F471EB84EBC30553BED7B'),(8602,'b','将private int m改为 public int m    ','AEBA258A696F471EB84EBC30553BED7B'),(8603,'c','将private int m改为 static int m     ','AEBA258A696F471EB84EBC30553BED7B'),(8604,'d','将private int m改为int m ','AEBA258A696F471EB84EBC30553BED7B'),(8605,'a','start()    ','6B94A3FA4D5743A7B7746B96DB3223E4'),(8606,'b','init()    ','6B94A3FA4D5743A7B7746B96DB3223E4'),(8607,'c','run()    ','6B94A3FA4D5743A7B7746B96DB3223E4'),(8608,'d','main()  ','6B94A3FA4D5743A7B7746B96DB3223E4'),(8609,'a','编译错误 ','B66C451B0C584D2B9DBAC960B7234C0C'),(8610,'b','抛出运行时异常 ','B66C451B0C584D2B9DBAC960B7234C0C'),(8611,'c','输出：sleep ','B66C451B0C584D2B9DBAC960B7234C0C'),(8612,'d','代码正常运行，但是无输出 ','B66C451B0C584D2B9DBAC960B7234C0C'),(8613,'a','InputStreamReader','F374A49AFCEE4993A9756AAE19F91B17'),(8614,'b','BufferedReader','F374A49AFCEE4993A9756AAE19F91B17'),(8615,'c','FileInputStream','F374A49AFCEE4993A9756AAE19F91B17'),(8616,'d','InputStream','F374A49AFCEE4993A9756AAE19F91B17'),(8617,'a','long 1 = 4990  ','C7B7826850B846118206DD1572B168E5'),(8618,'b','int i = 4L  ','C7B7826850B846118206DD1572B168E5'),(8619,'c','float f =1.1  ','C7B7826850B846118206DD1572B168E5'),(8620,'d','double d = 34.4','C7B7826850B846118206DD1572B168E5'),(8621,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','58088E2E412B4F9C8A86A56843C9A9F7'),(8622,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','58088E2E412B4F9C8A86A56843C9A9F7'),(8623,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','58088E2E412B4F9C8A86A56843C9A9F7'),(8624,'d','new InputStreamReader(\"dat\") ; ','58088E2E412B4F9C8A86A56843C9A9F7'),(8625,'a','编译错误 ','AE62CF5F9D57434CB529E8B7C188FBB9'),(8626,'b','实现向文件record.dat追加写入字符a ','AE62CF5F9D57434CB529E8B7C188FBB9'),(8627,'c','实现向文件record.dat覆盖写入字符a ','AE62CF5F9D57434CB529E8B7C188FBB9'),(8628,'d','文件record.dat无任何内容 ','AE62CF5F9D57434CB529E8B7C188FBB9'),(8629,'a','输出：4 ','09728B5452DB479691CCCDA46B7C13E7'),(8630,'b','在运行时抛出NullPointerException异常 ','09728B5452DB479691CCCDA46B7C13E7'),(8631,'c','在运行时抛出NumberFormatException异常 ','09728B5452DB479691CCCDA46B7C13E7'),(8632,'d','在运行时抛出IllegalStateException异常 ','09728B5452DB479691CCCDA46B7C13E7'),(8633,'a','s>>>=3   ','19D4308477F6464E90C6D2E8AA5CBE2E'),(8634,'b','s[3]= “X”  ','19D4308477F6464E90C6D2E8AA5CBE2E'),(8635,'c','int i = s.length()   ','19D4308477F6464E90C6D2E8AA5CBE2E'),(8636,'d','s = s + 10 ','19D4308477F6464E90C6D2E8AA5CBE2E'),(8637,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','1433B3C90E23486DA1986A75B5ED0685'),(8638,'b','垃圾收集将检查并释放不在使用的内存  ','1433B3C90E23486DA1986A75B5ED0685'),(8639,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','1433B3C90E23486DA1986A75B5ED0685'),(8640,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','1433B3C90E23486DA1986A75B5ED0685'),(8641,'a','第3行抛出异常 ','D135E998EF8D43D2AE2FD74BDA287FFA'),(8642,'b','第1行抛出异常 ','D135E998EF8D43D2AE2FD74BDA287FFA'),(8643,'c','第5行抛出异常 ','D135E998EF8D43D2AE2FD74BDA287FFA'),(8644,'d','第3行代码成功执行 ','D135E998EF8D43D2AE2FD74BDA287FFA'),(8645,'a','long 1 = 4990  ','38B1663D58F9473496D5D20D5B61441D'),(8646,'b','int i = 4L  ','38B1663D58F9473496D5D20D5B61441D'),(8647,'c','float f =1.1  ','38B1663D58F9473496D5D20D5B61441D'),(8648,'d','double d = 34.4','38B1663D58F9473496D5D20D5B61441D'),(8649,'a','一旦一个线程被创建，它就立即开始运行。  ','4B5F335108C2491C864249A36F08A567'),(8650,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','4B5F335108C2491C864249A36F08A567'),(8651,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','4B5F335108C2491C864249A36F08A567'),(8652,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','4B5F335108C2491C864249A36F08A567'),(8653,'a','start()    ','33E7132926E344638BD380C1AFF7C8FA'),(8654,'b','init()    ','33E7132926E344638BD380C1AFF7C8FA'),(8655,'c','run()    ','33E7132926E344638BD380C1AFF7C8FA'),(8656,'d','main()  ','33E7132926E344638BD380C1AFF7C8FA'),(8657,'a','编译错误 ','8805EE75C60148CF978F5D33F149970B'),(8658,'b','抛出运行时异常 ','8805EE75C60148CF978F5D33F149970B'),(8659,'c','输出：bar ','8805EE75C60148CF978F5D33F149970B'),(8660,'d','代码正常运行，但是无输出 ','8805EE75C60148CF978F5D33F149970B'),(8661,'a','输出Exception ','75C06802E3FC4EDAB9DB7B421402FB4C'),(8662,'b','输出A,B,Exception ','75C06802E3FC4EDAB9DB7B421402FB4C'),(8663,'c','编译失败 ','75C06802E3FC4EDAB9DB7B421402FB4C'),(8664,'d','在运行时抛出NullPointerException异常 ','75C06802E3FC4EDAB9DB7B421402FB4C'),(8665,'a','将private int m改为 protected int m  ','31F7E98361E84D189A1A91270E6270D2'),(8666,'b','将private int m改为 public int m    ','31F7E98361E84D189A1A91270E6270D2'),(8667,'c','将private int m改为 static int m     ','31F7E98361E84D189A1A91270E6270D2'),(8668,'d','将private int m改为int m ','31F7E98361E84D189A1A91270E6270D2'),(8669,'a','InputStreamReader','B3687DBC3A124A1E93FFE261520FBE3B'),(8670,'b','BufferedReader','B3687DBC3A124A1E93FFE261520FBE3B'),(8671,'c','FileInputStream','B3687DBC3A124A1E93FFE261520FBE3B'),(8672,'d','InputStream','B3687DBC3A124A1E93FFE261520FBE3B'),(8673,'a','public void method( int m){...}     ','8674C4EAED544AA8B644D6B5988BE841'),(8674,'b','public int method(){...} ','8674C4EAED544AA8B644D6B5988BE841'),(8675,'c','public void method2(){...}    ','8674C4EAED544AA8B644D6B5988BE841'),(8676,'d','public int method(int m，float f ){...} ','8674C4EAED544AA8B644D6B5988BE841'),(8677,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','F326B4B5824643C3A4F74EFF485A9198'),(8678,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','F326B4B5824643C3A4F74EFF485A9198'),(8679,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','F326B4B5824643C3A4F74EFF485A9198'),(8680,'d','new InputStreamReader(\"1.dat\") ; ','F326B4B5824643C3A4F74EFF485A9198'),(8681,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','557A9CA3EE784D4189D909524A3ED3DD'),(8682,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','557A9CA3EE784D4189D909524A3ED3DD'),(8683,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','557A9CA3EE784D4189D909524A3ED3DD'),(8684,'d','new InputStreamReader(\"1.dat\") ; ','557A9CA3EE784D4189D909524A3ED3DD'),(8685,'a','编译错误 ','AAD8E50F58E8414AAC5F8DFC37AC1E78'),(8686,'b','实现向文件record.dat追加写入字符a ','AAD8E50F58E8414AAC5F8DFC37AC1E78'),(8687,'c','实现向文件record.dat覆盖写入字符a ','AAD8E50F58E8414AAC5F8DFC37AC1E78'),(8688,'d','文件record.dat无任何内容 ','AAD8E50F58E8414AAC5F8DFC37AC1E78'),(8689,'a','Output is null.             ','B99EB7C3639A431B9A0B97C75DDD3F8E'),(8690,'b','Output is 0 ','B99EB7C3639A431B9A0B97C75DDD3F8E'),(8691,'c','编译时报错 ','B99EB7C3639A431B9A0B97C75DDD3F8E'),(8692,'d','运行时报错','B99EB7C3639A431B9A0B97C75DDD3F8E'),(8693,'a','编译错误 ','BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(8694,'b','抛出运行时异常 ','BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(8695,'c','输出：sleep ','BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(8696,'d','代码正常运行，但是无输出 ','BA8C80FBDA4143CAAEAE3F8BD843A7E5'),(8697,'a','通过调用stop()方法而停止的线程。 ','3D3BDB177B4840FAB0CC1D41C6DB074A'),(8698,'b','通过调用sleep()方法而停止的线程。 ','3D3BDB177B4840FAB0CC1D41C6DB074A'),(8699,'c','通过调用wait()方法而停止的线程。 ','3D3BDB177B4840FAB0CC1D41C6DB074A'),(8700,'d','通过调用suspend()方法而停止的线程。 ','3D3BDB177B4840FAB0CC1D41C6DB074A'),(8701,'a','编译错误 ','3CD696406D1A4919B3A9A72B428F13B2'),(8702,'b','抛出运行时异常 ','3CD696406D1A4919B3A9A72B428F13B2'),(8703,'c','输出：sleep ','3CD696406D1A4919B3A9A72B428F13B2'),(8704,'d','代码正常运行，但是无输出 ','3CD696406D1A4919B3A9A72B428F13B2'),(8705,'a','m.length()    ','8325DCDE005942F4B3968D2C90A6821E'),(8706,'b','m.length   ','8325DCDE005942F4B3968D2C90A6821E'),(8707,'c','m.length()+1   ','8325DCDE005942F4B3968D2C90A6821E'),(8708,'d','m.length-1','8325DCDE005942F4B3968D2C90A6821E'),(8709,'a','sleep方法 ','6D24A5C9A32A40848E83F2320AA28A1D'),(8710,'b','IO等待 ','6D24A5C9A32A40848E83F2320AA28A1D'),(8711,'c','yield方法 ','6D24A5C9A32A40848E83F2320AA28A1D'),(8712,'d','wait方法 ','6D24A5C9A32A40848E83F2320AA28A1D'),(8713,'a','public void method( int m){...}     ','DCE4EA8707424C63ACB7C09B3590B279'),(8714,'b','public int method(){...} ','DCE4EA8707424C63ACB7C09B3590B279'),(8715,'c','public void method2(){...}    ','DCE4EA8707424C63ACB7C09B3590B279'),(8716,'d','public int method(int m，float f ){...} ','DCE4EA8707424C63ACB7C09B3590B279'),(8717,'a','栈是非线性结构        ','BADA7322AF1748B694766B7D43309A92'),(8718,'b','栈是一种树状结构 ','BADA7322AF1748B694766B7D43309A92'),(8719,'c','栈具有先进先出的特征  ','BADA7322AF1748B694766B7D43309A92'),(8720,'d','栈具有后进先出的特征 ','BADA7322AF1748B694766B7D43309A92'),(8721,'a','sleep方法 ','EC3E7DB0643E459188D39940E6A234E3'),(8722,'b','IO等待 ','EC3E7DB0643E459188D39940E6A234E3'),(8723,'c','yield方法 ','EC3E7DB0643E459188D39940E6A234E3'),(8724,'d','wait方法 ','EC3E7DB0643E459188D39940E6A234E3'),(8725,'a','s>>>=3   ','95E14927E2334FDFBFCC880871CFBE4C'),(8726,'b','s[3]= “X”  ','95E14927E2334FDFBFCC880871CFBE4C'),(8727,'c','int i = s.length()   ','95E14927E2334FDFBFCC880871CFBE4C'),(8728,'d','s = s + 10 ','95E14927E2334FDFBFCC880871CFBE4C'),(8729,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(8730,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(8731,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(8732,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','46F33D21A68A4A2F9DE5B1B2EDB571A2'),(8733,'a','Output is null.             ','78F9B177E2EA45389A83958891DAEA60'),(8734,'b','Output is 0 ','78F9B177E2EA45389A83958891DAEA60'),(8735,'c','编译时报错 ','78F9B177E2EA45389A83958891DAEA60'),(8736,'d','运行时报错','78F9B177E2EA45389A83958891DAEA60'),(8737,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','6DF46658B6494DF59A3D0C9B4CB4D58F'),(8738,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','6DF46658B6494DF59A3D0C9B4CB4D58F'),(8739,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','6DF46658B6494DF59A3D0C9B4CB4D58F'),(8740,'d','new InputStreamReader(\"dat\") ; ','6DF46658B6494DF59A3D0C9B4CB4D58F'),(8741,'a','输出Exception ','3DF17A806C6F41A9A08424F8620C9160'),(8742,'b','输出A,B,Exception ','3DF17A806C6F41A9A08424F8620C9160'),(8743,'c','编译失败 ','3DF17A806C6F41A9A08424F8620C9160'),(8744,'d','在运行时抛出NullPointerException异常 ','3DF17A806C6F41A9A08424F8620C9160'),(8745,'a','private synchronized Object o; ','7DE0DD0894B54C11B0C15E7481A1BBB4'),(8746,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','7DE0DD0894B54C11B0C15E7481A1BBB4'),(8747,'c','public synchronized void go() { /* code here */ } ','7DE0DD0894B54C11B0C15E7481A1BBB4'),(8748,'d','private synchronized(this) void go() { /* code here */ } ','7DE0DD0894B54C11B0C15E7481A1BBB4'),(8749,'a','InputStreamReader','0D37714BF0344AE6B78C817AB34A0560'),(8750,'b','BufferedReader','0D37714BF0344AE6B78C817AB34A0560'),(8751,'c','FileInputStream','0D37714BF0344AE6B78C817AB34A0560'),(8752,'d','InputStream','0D37714BF0344AE6B78C817AB34A0560'),(8753,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','100C13CF364441F79259E88CA9EB59FB'),(8754,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','100C13CF364441F79259E88CA9EB59FB'),(8755,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','100C13CF364441F79259E88CA9EB59FB'),(8756,'d','new InputStreamReader(\"1.dat\") ; ','100C13CF364441F79259E88CA9EB59FB'),(8757,'a','const   ','3689E90FE66040E1B6002D67BA4CC19F'),(8758,'b','NULL  ','3689E90FE66040E1B6002D67BA4CC19F'),(8759,'c','false   ','3689E90FE66040E1B6002D67BA4CC19F'),(8760,'d','this  ','3689E90FE66040E1B6002D67BA4CC19F'),(8761,'a','栈是非线性结构        ','51740FDB8AB3453194FA79410FD417BD'),(8762,'b','栈是一种树状结构 ','51740FDB8AB3453194FA79410FD417BD'),(8763,'c','栈具有先进先出的特征  ','51740FDB8AB3453194FA79410FD417BD'),(8764,'d','栈具有后进先出的特征 ','51740FDB8AB3453194FA79410FD417BD'),(8765,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','897F8E63F86B4F20BE4025B254FE4EB2'),(8766,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','897F8E63F86B4F20BE4025B254FE4EB2'),(8767,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','897F8E63F86B4F20BE4025B254FE4EB2'),(8768,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','897F8E63F86B4F20BE4025B254FE4EB2'),(8769,'a','输出：test ','7AF53BC6C137409BA5BFCBC482135683'),(8770,'b','输出：Exception ','7AF53BC6C137409BA5BFCBC482135683'),(8771,'c','编译失败 ','7AF53BC6C137409BA5BFCBC482135683'),(8772,'d','输出：NullPointerException ','7AF53BC6C137409BA5BFCBC482135683'),(8773,'a','输出：test ','69F5B79B55AD41638CB033E7BE0BAF4F'),(8774,'b','输出：Exception ','69F5B79B55AD41638CB033E7BE0BAF4F'),(8775,'c','编译失败 ','69F5B79B55AD41638CB033E7BE0BAF4F'),(8776,'d','输出：NullPointerException ','69F5B79B55AD41638CB033E7BE0BAF4F'),(8777,'a','一旦一个线程被创建，它就立即开始运行。  ','CFD648F1A75E4FB499314B6C254AB00D'),(8778,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','CFD648F1A75E4FB499314B6C254AB00D'),(8779,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','CFD648F1A75E4FB499314B6C254AB00D'),(8780,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','CFD648F1A75E4FB499314B6C254AB00D'),(8781,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','0B75C0F0F2C9471BA54A29B30AA19987'),(8782,'b','垃圾收集将检查并释放不在使用的内存  ','0B75C0F0F2C9471BA54A29B30AA19987'),(8783,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','0B75C0F0F2C9471BA54A29B30AA19987'),(8784,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','0B75C0F0F2C9471BA54A29B30AA19987'),(8785,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','0D990B41618C4E02907669182389572F'),(8786,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','0D990B41618C4E02907669182389572F'),(8787,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','0D990B41618C4E02907669182389572F'),(8788,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','0D990B41618C4E02907669182389572F'),(8789,'a','编译错误 ','36151239BBC64E30ADE1091FA360E3B4'),(8790,'b','抛出运行时异常 ','36151239BBC64E30ADE1091FA360E3B4'),(8791,'c','输出：sleep ','36151239BBC64E30ADE1091FA360E3B4'),(8792,'d','代码正常运行，但是无输出 ','36151239BBC64E30ADE1091FA360E3B4'),(8793,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','3EC715768B6E459C87D684C3D10B9192'),(8794,'b','垃圾收集将检查并释放不在使用的内存  ','3EC715768B6E459C87D684C3D10B9192'),(8795,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','3EC715768B6E459C87D684C3D10B9192'),(8796,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','3EC715768B6E459C87D684C3D10B9192'),(8797,'a','栈是非线性结构        ','76E50FF39C054726B3513B2900B893C2'),(8798,'b','栈是一种树状结构 ','76E50FF39C054726B3513B2900B893C2'),(8799,'c','栈具有先进先出的特征  ','76E50FF39C054726B3513B2900B893C2'),(8800,'d','栈具有后进先出的特征 ','76E50FF39C054726B3513B2900B893C2'),(8801,'a','编译错误 ','12367529D8EC4FBDAEC3F52C47BE3FF9'),(8802,'b','抛出运行时异常 ','12367529D8EC4FBDAEC3F52C47BE3FF9'),(8803,'c','输出：bar ','12367529D8EC4FBDAEC3F52C47BE3FF9'),(8804,'d','代码正常运行，但是无输出 ','12367529D8EC4FBDAEC3F52C47BE3FF9'),(8805,'a','private synchronized Object o; ','E7DCFB11C80C4BDC90E0AB3B77CDC761'),(8806,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','E7DCFB11C80C4BDC90E0AB3B77CDC761'),(8807,'c','public synchronized void go() { /* code here */ } ','E7DCFB11C80C4BDC90E0AB3B77CDC761'),(8808,'d','private synchronized(this) void go() { /* code here */ } ','E7DCFB11C80C4BDC90E0AB3B77CDC761'),(8809,'a','start()    ','6CF08D3C564545C596C5CF7DD8C808F6'),(8810,'b','init()    ','6CF08D3C564545C596C5CF7DD8C808F6'),(8811,'c','run()    ','6CF08D3C564545C596C5CF7DD8C808F6'),(8812,'d','main()  ','6CF08D3C564545C596C5CF7DD8C808F6'),(8813,'a','编译错误 ','F614748966A24A4ABE09982B17613B12'),(8814,'b','实现向文件record.dat追加写入字符a ','F614748966A24A4ABE09982B17613B12'),(8815,'c','实现向文件record.dat覆盖写入字符a ','F614748966A24A4ABE09982B17613B12'),(8816,'d','文件record.dat无任何内容 ','F614748966A24A4ABE09982B17613B12'),(8817,'a','名为dtThread的线程为守护线程 ','CCE040334B144163A85C501736D10707'),(8818,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','CCE040334B144163A85C501736D10707'),(8819,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','CCE040334B144163A85C501736D10707'),(8820,'d','main线程是守护线程 ','CCE040334B144163A85C501736D10707'),(8821,'a','5.0','51A97DC8CFC04E729781BA052D62DA62'),(8822,'b','4.0','51A97DC8CFC04E729781BA052D62DA62'),(8823,'c','6.0','51A97DC8CFC04E729781BA052D62DA62'),(8824,'d','finished','51A97DC8CFC04E729781BA052D62DA62'),(8825,'a','将private int m改为 protected int m  ','849C1AA4560E460FBB7534B24D6DE56E'),(8826,'b','将private int m改为 public int m    ','849C1AA4560E460FBB7534B24D6DE56E'),(8827,'c','将private int m改为 static int m     ','849C1AA4560E460FBB7534B24D6DE56E'),(8828,'d','将private int m改为int m ','849C1AA4560E460FBB7534B24D6DE56E'),(8829,'a','m.length()    ','A31D67C5C5A04E209505E4839BDDD44B'),(8830,'b','m.length   ','A31D67C5C5A04E209505E4839BDDD44B'),(8831,'c','m.length()+1   ','A31D67C5C5A04E209505E4839BDDD44B'),(8832,'d','m.length-1','A31D67C5C5A04E209505E4839BDDD44B'),(8833,'a','输出Exception ','1507F6D2A79D4E118DFB24858D224EFC'),(8834,'b','输出A,B,Exception ','1507F6D2A79D4E118DFB24858D224EFC'),(8835,'c','编译失败 ','1507F6D2A79D4E118DFB24858D224EFC'),(8836,'d','在运行时抛出NullPointerException异常 ','1507F6D2A79D4E118DFB24858D224EFC'),(8837,'a','第3行抛出异常 ','71DB815A83274531B7CEE78097091E79'),(8838,'b','第1行抛出异常 ','71DB815A83274531B7CEE78097091E79'),(8839,'c','第5行抛出异常 ','71DB815A83274531B7CEE78097091E79'),(8840,'d','第3行代码成功执行 ','71DB815A83274531B7CEE78097091E79'),(8841,'a','public void method( int m){...}     ','343A11A1AC9B41009AB07A05A321F264'),(8842,'b','public int method(){...} ','343A11A1AC9B41009AB07A05A321F264'),(8843,'c','public void method2(){...}    ','343A11A1AC9B41009AB07A05A321F264'),(8844,'d','public int method(int m，float f ){...} ','343A11A1AC9B41009AB07A05A321F264'),(8845,'a','编译错误 ','6B22D9B6238B447896FD44AC7E9DB385'),(8846,'b','抛出运行时异常 ','6B22D9B6238B447896FD44AC7E9DB385'),(8847,'c','输出：sleep ','6B22D9B6238B447896FD44AC7E9DB385'),(8848,'d','代码正常运行，但是无输出 ','6B22D9B6238B447896FD44AC7E9DB385'),(8849,'a','public void method( int m){...}     ','456FB5AA7C1849EABB961A1F7D79C518'),(8850,'b','public int method(){...} ','456FB5AA7C1849EABB961A1F7D79C518'),(8851,'c','public void method2(){...}    ','456FB5AA7C1849EABB961A1F7D79C518'),(8852,'d','public int method(int m，float f ){...} ','456FB5AA7C1849EABB961A1F7D79C518'),(8853,'a','第3行抛出异常 ','05A44F76F5B84BAEACBC73BFC01F1451'),(8854,'b','第1行抛出异常 ','05A44F76F5B84BAEACBC73BFC01F1451'),(8855,'c','第5行抛出异常 ','05A44F76F5B84BAEACBC73BFC01F1451'),(8856,'d','第3行代码成功执行 ','05A44F76F5B84BAEACBC73BFC01F1451'),(8857,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','C1318305A2E441DB822CD1A097F58874'),(8858,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','C1318305A2E441DB822CD1A097F58874'),(8859,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','C1318305A2E441DB822CD1A097F58874'),(8860,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','C1318305A2E441DB822CD1A097F58874'),(8861,'a','const   ','9C8A1DAD051849C2816DF4B739FA6942'),(8862,'b','NULL  ','9C8A1DAD051849C2816DF4B739FA6942'),(8863,'c','false   ','9C8A1DAD051849C2816DF4B739FA6942'),(8864,'d','this  ','9C8A1DAD051849C2816DF4B739FA6942'),(8865,'a','m.length()    ','056BD98C07154426A296D11E86A01CC4'),(8866,'b','m.length   ','056BD98C07154426A296D11E86A01CC4'),(8867,'c','m.length()+1   ','056BD98C07154426A296D11E86A01CC4'),(8868,'d','m.length-1','056BD98C07154426A296D11E86A01CC4'),(8869,'a','通过调用stop()方法而停止的线程。 ','A8417123407C434FBC4B4E8B4CA0B609'),(8870,'b','通过调用sleep()方法而停止的线程。 ','A8417123407C434FBC4B4E8B4CA0B609'),(8871,'c','通过调用wait()方法而停止的线程。 ','A8417123407C434FBC4B4E8B4CA0B609'),(8872,'d','通过调用suspend()方法而停止的线程。 ','A8417123407C434FBC4B4E8B4CA0B609'),(8873,'a','编译错误 ','826F7B4B344F4FA2A85751D96C49DB6C'),(8874,'b','程序可以通过编译，运行后文件company.txt没有任何改变','826F7B4B344F4FA2A85751D96C49DB6C'),(8875,'c','程序可以通过编译，运行后文件company.txt的长度变为0','826F7B4B344F4FA2A85751D96C49DB6C'),(8876,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','826F7B4B344F4FA2A85751D96C49DB6C'),(8877,'a','编译错误 ','782795B974B2436284C2EC9917A3ACFE'),(8878,'b','抛出运行时异常 ','782795B974B2436284C2EC9917A3ACFE'),(8879,'c','输出：sleep ','782795B974B2436284C2EC9917A3ACFE'),(8880,'d','代码正常运行，但是无输出 ','782795B974B2436284C2EC9917A3ACFE'),(8881,'a','private synchronized Object o; ','40794D1645CD4A4582B24ADB351537B3'),(8882,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','40794D1645CD4A4582B24ADB351537B3'),(8883,'c','public synchronized void go() { /* code here */ } ','40794D1645CD4A4582B24ADB351537B3'),(8884,'d','private synchronized(this) void go() { /* code here */ } ','40794D1645CD4A4582B24ADB351537B3'),(8885,'a','通过调用stop()方法而停止的线程。 ','A24DFD9699CD4BC39C1D45A5E727B9AF'),(8886,'b','通过调用sleep()方法而停止的线程。 ','A24DFD9699CD4BC39C1D45A5E727B9AF'),(8887,'c','通过调用wait()方法而停止的线程。 ','A24DFD9699CD4BC39C1D45A5E727B9AF'),(8888,'d','通过调用suspend()方法而停止的线程。 ','A24DFD9699CD4BC39C1D45A5E727B9AF'),(8889,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','7A6E0F0EA26D4262B238329C00AC5511'),(8890,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','7A6E0F0EA26D4262B238329C00AC5511'),(8891,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','7A6E0F0EA26D4262B238329C00AC5511'),(8892,'d','new InputStreamReader(\"1.dat\") ; ','7A6E0F0EA26D4262B238329C00AC5511'),(8893,'a','InputStreamReader','58A2547D3B994BDC8FD48111791C9572'),(8894,'b','BufferedReader','58A2547D3B994BDC8FD48111791C9572'),(8895,'c','FileInputStream','58A2547D3B994BDC8FD48111791C9572'),(8896,'d','InputStream','58A2547D3B994BDC8FD48111791C9572'),(8897,'a','输出：4 ','4A7D76E2E30E47379C991C09CA22489F'),(8898,'b','在运行时抛出NullPointerException异常 ','4A7D76E2E30E47379C991C09CA22489F'),(8899,'c','在运行时抛出NumberFormatException异常 ','4A7D76E2E30E47379C991C09CA22489F'),(8900,'d','在运行时抛出IllegalStateException异常 ','4A7D76E2E30E47379C991C09CA22489F'),(8901,'a','5.0','36058E13DB6B45858DF2D464CFDDDDC5'),(8902,'b','4.0','36058E13DB6B45858DF2D464CFDDDDC5'),(8903,'c','6.0','36058E13DB6B45858DF2D464CFDDDDC5'),(8904,'d','finished','36058E13DB6B45858DF2D464CFDDDDC5'),(8905,'a','InputStreamReader','C9FF3B79499E4753BB612FCC437A817E'),(8906,'b','BufferedReader','C9FF3B79499E4753BB612FCC437A817E'),(8907,'c','FileInputStream','C9FF3B79499E4753BB612FCC437A817E'),(8908,'d','InputStream','C9FF3B79499E4753BB612FCC437A817E'),(8909,'a','m.length()    ','D54CBFF879384DD09D786211A8D5003B'),(8910,'b','m.length   ','D54CBFF879384DD09D786211A8D5003B'),(8911,'c','m.length()+1   ','D54CBFF879384DD09D786211A8D5003B'),(8912,'d','m.length-1','D54CBFF879384DD09D786211A8D5003B'),(8913,'a','输出：test ','31B0BA226D13454D90050D4961110F9A'),(8914,'b','输出：Exception ','31B0BA226D13454D90050D4961110F9A'),(8915,'c','编译失败 ','31B0BA226D13454D90050D4961110F9A'),(8916,'d','输出：NullPointerException ','31B0BA226D13454D90050D4961110F9A'),(8917,'a','s>>>=3   ','3988954DE6094D0A99A369FEAC5DA692'),(8918,'b','s[3]= “X”  ','3988954DE6094D0A99A369FEAC5DA692'),(8919,'c','int i = s.length()   ','3988954DE6094D0A99A369FEAC5DA692'),(8920,'d','s = s + 10 ','3988954DE6094D0A99A369FEAC5DA692'),(8921,'a','将private int m改为 protected int m  ','2A0F921BBB90462C8F62E70DAAC5F00E'),(8922,'b','将private int m改为 public int m    ','2A0F921BBB90462C8F62E70DAAC5F00E'),(8923,'c','将private int m改为 static int m     ','2A0F921BBB90462C8F62E70DAAC5F00E'),(8924,'d','将private int m改为int m ','2A0F921BBB90462C8F62E70DAAC5F00E'),(8925,'a','编译错误 ','F7401A00985740DFA5208DDACA2BED4A'),(8926,'b','实现向文件record.dat追加写入字符a ','F7401A00985740DFA5208DDACA2BED4A'),(8927,'c','实现向文件record.dat覆盖写入字符a ','F7401A00985740DFA5208DDACA2BED4A'),(8928,'d','文件record.dat无任何内容 ','F7401A00985740DFA5208DDACA2BED4A'),(8929,'a','栈是非线性结构        ','DBF269C2D90743078334F7AC0AF668D3'),(8930,'b','栈是一种树状结构 ','DBF269C2D90743078334F7AC0AF668D3'),(8931,'c','栈具有先进先出的特征  ','DBF269C2D90743078334F7AC0AF668D3'),(8932,'d','栈具有后进先出的特征 ','DBF269C2D90743078334F7AC0AF668D3'),(8933,'a','输出：test ','9FC31EA4A8E146E6A3546957CD13E96C'),(8934,'b','输出：Exception ','9FC31EA4A8E146E6A3546957CD13E96C'),(8935,'c','编译失败 ','9FC31EA4A8E146E6A3546957CD13E96C'),(8936,'d','输出：NullPointerException ','9FC31EA4A8E146E6A3546957CD13E96C'),(8937,'a','sleep方法 ','F358507CC32C4B0DA17C6F6F02D32D9D'),(8938,'b','IO等待 ','F358507CC32C4B0DA17C6F6F02D32D9D'),(8939,'c','yield方法 ','F358507CC32C4B0DA17C6F6F02D32D9D'),(8940,'d','wait方法 ','F358507CC32C4B0DA17C6F6F02D32D9D'),(8941,'a','long 1 = 4990  ','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(8942,'b','int i = 4L  ','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(8943,'c','float f =1.1  ','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(8944,'d','double d = 34.4','3C82966CAE0F4C79B0E93FBC8CBAE4AC'),(8945,'a','long 1 = 4990  ','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(8946,'b','int i = 4L  ','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(8947,'c','float f =1.1  ','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(8948,'d','double d = 34.4','D83AEEDBE0E64DFD8B35F8AAF404B54E'),(8949,'a','编译错误 ','F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(8950,'b','程序可以通过编译，运行后文件company.txt没有任何改变','F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(8951,'c','程序可以通过编译，运行后文件company.txt的长度变为0','F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(8952,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','F2C1CD03ED5C48A68CB76DEE3E5D9F96'),(8953,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','B2A14C45157C4792B7474B18A8B3025F'),(8954,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','B2A14C45157C4792B7474B18A8B3025F'),(8955,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','B2A14C45157C4792B7474B18A8B3025F'),(8956,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','B2A14C45157C4792B7474B18A8B3025F'),(8957,'a','s>>>=3   ','DB89A81F42B645C7B7755F3E15300D23'),(8958,'b','s[3]= “X”  ','DB89A81F42B645C7B7755F3E15300D23'),(8959,'c','int i = s.length()   ','DB89A81F42B645C7B7755F3E15300D23'),(8960,'d','s = s + 10 ','DB89A81F42B645C7B7755F3E15300D23'),(8961,'a','Output is null.             ','01AB7988D33E48F4BA19741AB0E71572'),(8962,'b','Output is 0 ','01AB7988D33E48F4BA19741AB0E71572'),(8963,'c','编译时报错 ','01AB7988D33E48F4BA19741AB0E71572'),(8964,'d','运行时报错','01AB7988D33E48F4BA19741AB0E71572'),(8965,'a','start()    ','B058660D59B548CFA3626F66B41544C3'),(8966,'b','init()    ','B058660D59B548CFA3626F66B41544C3'),(8967,'c','run()    ','B058660D59B548CFA3626F66B41544C3'),(8968,'d','main()  ','B058660D59B548CFA3626F66B41544C3'),(8969,'a','start()    ','E72611F9FC56437C820D9C4762F6B98A'),(8970,'b','init()    ','E72611F9FC56437C820D9C4762F6B98A'),(8971,'c','run()    ','E72611F9FC56437C820D9C4762F6B98A'),(8972,'d','main()  ','E72611F9FC56437C820D9C4762F6B98A'),(8973,'a','编译错误 ','919334B660AC4E09AEA4461628F3135B'),(8974,'b','程序可以通过编译，运行后文件company.txt没有任何改变','919334B660AC4E09AEA4461628F3135B'),(8975,'c','程序可以通过编译，运行后文件company.txt的长度变为0','919334B660AC4E09AEA4461628F3135B'),(8976,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','919334B660AC4E09AEA4461628F3135B'),(8977,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(8978,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(8979,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(8980,'d','new InputStreamReader(\"1.dat\") ; ','16FDB77F6A734DBDA26CCDDA1A6BCD2A'),(8981,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','2400C908F76C4A38B55C77D6642160CD'),(8982,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','2400C908F76C4A38B55C77D6642160CD'),(8983,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','2400C908F76C4A38B55C77D6642160CD'),(8984,'d','new InputStreamReader(\"dat\") ; ','2400C908F76C4A38B55C77D6642160CD'),(8985,'a','s>>>=3   ','4C152C4553DA45349B9C2C73FB085A59'),(8986,'b','s[3]= “X”  ','4C152C4553DA45349B9C2C73FB085A59'),(8987,'c','int i = s.length()   ','4C152C4553DA45349B9C2C73FB085A59'),(8988,'d','s = s + 10 ','4C152C4553DA45349B9C2C73FB085A59'),(8989,'a','栈是非线性结构        ','C56F058D5A0E4B4B80476A42B8819613'),(8990,'b','栈是一种树状结构 ','C56F058D5A0E4B4B80476A42B8819613'),(8991,'c','栈具有先进先出的特征  ','C56F058D5A0E4B4B80476A42B8819613'),(8992,'d','栈具有后进先出的特征 ','C56F058D5A0E4B4B80476A42B8819613'),(8993,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(8994,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(8995,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(8996,'d','new InputStreamReader(\"dat\") ; ','BA2C60BD76CC4DF0B79C7BFB8DD268B3'),(8997,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','57F223C050484D9580B283D91EE42A59'),(8998,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','57F223C050484D9580B283D91EE42A59'),(8999,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','57F223C050484D9580B283D91EE42A59'),(9000,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','57F223C050484D9580B283D91EE42A59'),(9001,'a','const   ','6D5ED0C2A05841489C4D33C80C041A9D'),(9002,'b','NULL  ','6D5ED0C2A05841489C4D33C80C041A9D'),(9003,'c','false   ','6D5ED0C2A05841489C4D33C80C041A9D'),(9004,'d','this  ','6D5ED0C2A05841489C4D33C80C041A9D'),(9005,'a','编译错误 ','9CB357F050764DB28B6FBE740AB5CD98'),(9006,'b','实现向文件record.dat追加写入字符a ','9CB357F050764DB28B6FBE740AB5CD98'),(9007,'c','实现向文件record.dat覆盖写入字符a ','9CB357F050764DB28B6FBE740AB5CD98'),(9008,'d','文件record.dat无任何内容 ','9CB357F050764DB28B6FBE740AB5CD98'),(9009,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','337BD57A3C814928818FAA8EA5332F2C'),(9010,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','337BD57A3C814928818FAA8EA5332F2C'),(9011,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','337BD57A3C814928818FAA8EA5332F2C'),(9012,'d','new InputStreamReader(\"1.dat\") ; ','337BD57A3C814928818FAA8EA5332F2C'),(9013,'a','输出Exception ','48A3077A348942E680282A6D5FF62CD0'),(9014,'b','输出A,B,Exception ','48A3077A348942E680282A6D5FF62CD0'),(9015,'c','编译失败 ','48A3077A348942E680282A6D5FF62CD0'),(9016,'d','在运行时抛出NullPointerException异常 ','48A3077A348942E680282A6D5FF62CD0'),(9017,'a','long 1 = 4990  ','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(9018,'b','int i = 4L  ','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(9019,'c','float f =1.1  ','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(9020,'d','double d = 34.4','EA2AE8B2158A49AEAF06D52C8AAC4B44'),(9021,'a','Output is null.             ','08B2626E55054529AD02C7E5F1573F56'),(9022,'b','Output is 0 ','08B2626E55054529AD02C7E5F1573F56'),(9023,'c','编译时报错 ','08B2626E55054529AD02C7E5F1573F56'),(9024,'d','运行时报错','08B2626E55054529AD02C7E5F1573F56'),(9025,'a','第3行抛出异常 ','56CC5B59FFE54E759CE1131B9BD1C6F9'),(9026,'b','第1行抛出异常 ','56CC5B59FFE54E759CE1131B9BD1C6F9'),(9027,'c','第5行抛出异常 ','56CC5B59FFE54E759CE1131B9BD1C6F9'),(9028,'d','第3行代码成功执行 ','56CC5B59FFE54E759CE1131B9BD1C6F9'),(9029,'a','编译错误 ','69AD3CDE36DF45D59D3A27835D7815EA'),(9030,'b','抛出运行时异常 ','69AD3CDE36DF45D59D3A27835D7815EA'),(9031,'c','输出：bar ','69AD3CDE36DF45D59D3A27835D7815EA'),(9032,'d','代码正常运行，但是无输出 ','69AD3CDE36DF45D59D3A27835D7815EA'),(9033,'a','const   ','FC120AE84877414AB4DEBDFC3A68C9D8'),(9034,'b','NULL  ','FC120AE84877414AB4DEBDFC3A68C9D8'),(9035,'c','false   ','FC120AE84877414AB4DEBDFC3A68C9D8'),(9036,'d','this  ','FC120AE84877414AB4DEBDFC3A68C9D8'),(9037,'a','输出Exception ','38B1680643D1402A8C3209D857BD75B5'),(9038,'b','输出A,B,Exception ','38B1680643D1402A8C3209D857BD75B5'),(9039,'c','编译失败 ','38B1680643D1402A8C3209D857BD75B5'),(9040,'d','在运行时抛出NullPointerException异常 ','38B1680643D1402A8C3209D857BD75B5'),(9041,'a','名为dtThread的线程为守护线程 ','A4570309855B4DDE9D20BFD8CCA90232'),(9042,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','A4570309855B4DDE9D20BFD8CCA90232'),(9043,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','A4570309855B4DDE9D20BFD8CCA90232'),(9044,'d','main线程是守护线程 ','A4570309855B4DDE9D20BFD8CCA90232'),(9045,'a','sleep方法 ','00BFB07A88334474A11C494379F9D47A'),(9046,'b','IO等待 ','00BFB07A88334474A11C494379F9D47A'),(9047,'c','yield方法 ','00BFB07A88334474A11C494379F9D47A'),(9048,'d','wait方法 ','00BFB07A88334474A11C494379F9D47A'),(9049,'a','编译错误 ','2E8B180D59174612B80CD3B976FE3780'),(9050,'b','实现向文件record.dat追加写入字符a ','2E8B180D59174612B80CD3B976FE3780'),(9051,'c','实现向文件record.dat覆盖写入字符a ','2E8B180D59174612B80CD3B976FE3780'),(9052,'d','文件record.dat无任何内容 ','2E8B180D59174612B80CD3B976FE3780'),(9053,'a','编译错误 ','BB1C3CA8285947B7985F7943A607BCAF'),(9054,'b','抛出运行时异常 ','BB1C3CA8285947B7985F7943A607BCAF'),(9055,'c','输出：bar ','BB1C3CA8285947B7985F7943A607BCAF'),(9056,'d','代码正常运行，但是无输出 ','BB1C3CA8285947B7985F7943A607BCAF'),(9057,'a','输出：test ','D88B4115C8E042829068C9F9925DB871'),(9058,'b','输出：Exception ','D88B4115C8E042829068C9F9925DB871'),(9059,'c','编译失败 ','D88B4115C8E042829068C9F9925DB871'),(9060,'d','输出：NullPointerException ','D88B4115C8E042829068C9F9925DB871'),(9061,'a','将private int m改为 protected int m  ','69CFD1EEE73C4F99B567D022FBB2D9DF'),(9062,'b','将private int m改为 public int m    ','69CFD1EEE73C4F99B567D022FBB2D9DF'),(9063,'c','将private int m改为 static int m     ','69CFD1EEE73C4F99B567D022FBB2D9DF'),(9064,'d','将private int m改为int m ','69CFD1EEE73C4F99B567D022FBB2D9DF'),(9065,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','C9FFCD49E7B5491190A4BF252BE91FFE'),(9066,'b','垃圾收集将检查并释放不在使用的内存  ','C9FFCD49E7B5491190A4BF252BE91FFE'),(9067,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','C9FFCD49E7B5491190A4BF252BE91FFE'),(9068,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','C9FFCD49E7B5491190A4BF252BE91FFE'),(9069,'a','public void method( int m){...}     ','E3E5206AE35348DD9A32648BF70F78B2'),(9070,'b','public int method(){...} ','E3E5206AE35348DD9A32648BF70F78B2'),(9071,'c','public void method2(){...}    ','E3E5206AE35348DD9A32648BF70F78B2'),(9072,'d','public int method(int m，float f ){...} ','E3E5206AE35348DD9A32648BF70F78B2'),(9073,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','B403973A869848F983231EE84C8BADC4'),(9074,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','B403973A869848F983231EE84C8BADC4'),(9075,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','B403973A869848F983231EE84C8BADC4'),(9076,'d','new InputStreamReader(\"dat\") ; ','B403973A869848F983231EE84C8BADC4'),(9077,'a','名为dtThread的线程为守护线程 ','380A732D59B54AF59C6DA8916B7CFF12'),(9078,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','380A732D59B54AF59C6DA8916B7CFF12'),(9079,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','380A732D59B54AF59C6DA8916B7CFF12'),(9080,'d','main线程是守护线程 ','380A732D59B54AF59C6DA8916B7CFF12'),(9081,'a','InputStreamReader','2D96E3D9FF08496BBF19491D345909F0'),(9082,'b','BufferedReader','2D96E3D9FF08496BBF19491D345909F0'),(9083,'c','FileInputStream','2D96E3D9FF08496BBF19491D345909F0'),(9084,'d','InputStream','2D96E3D9FF08496BBF19491D345909F0'),(9085,'a','编译错误 ','CC57E02B65F5457CAC7E99A9EA5FDE96'),(9086,'b','实现向文件record.dat追加写入字符a ','CC57E02B65F5457CAC7E99A9EA5FDE96'),(9087,'c','实现向文件record.dat覆盖写入字符a ','CC57E02B65F5457CAC7E99A9EA5FDE96'),(9088,'d','文件record.dat无任何内容 ','CC57E02B65F5457CAC7E99A9EA5FDE96'),(9089,'a','5.0','473F363F30CB411DA28F2B9646502AE3'),(9090,'b','4.0','473F363F30CB411DA28F2B9646502AE3'),(9091,'c','6.0','473F363F30CB411DA28F2B9646502AE3'),(9092,'d','finished','473F363F30CB411DA28F2B9646502AE3'),(9093,'a','编译错误 ','002A1E80FFBF4BCAB32159B0C0C2347F'),(9094,'b','实现向文件record.dat追加写入字符a ','002A1E80FFBF4BCAB32159B0C0C2347F'),(9095,'c','实现向文件record.dat覆盖写入字符a ','002A1E80FFBF4BCAB32159B0C0C2347F'),(9096,'d','文件record.dat无任何内容 ','002A1E80FFBF4BCAB32159B0C0C2347F'),(9097,'a','输出：4 ','30491B50AF2C4181A623CD69BF22B5E8'),(9098,'b','在运行时抛出NullPointerException异常 ','30491B50AF2C4181A623CD69BF22B5E8'),(9099,'c','在运行时抛出NumberFormatException异常 ','30491B50AF2C4181A623CD69BF22B5E8'),(9100,'d','在运行时抛出IllegalStateException异常 ','30491B50AF2C4181A623CD69BF22B5E8'),(9101,'a','sleep方法 ','EA1422BBF4B04045AFF8AAEFB5253DE4'),(9102,'b','IO等待 ','EA1422BBF4B04045AFF8AAEFB5253DE4'),(9103,'c','yield方法 ','EA1422BBF4B04045AFF8AAEFB5253DE4'),(9104,'d','wait方法 ','EA1422BBF4B04045AFF8AAEFB5253DE4'),(9105,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','0D72DF82DA5E4E27AFC1C4C12001C246'),(9106,'b','垃圾收集将检查并释放不在使用的内存  ','0D72DF82DA5E4E27AFC1C4C12001C246'),(9107,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','0D72DF82DA5E4E27AFC1C4C12001C246'),(9108,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','0D72DF82DA5E4E27AFC1C4C12001C246'),(9109,'a','通过调用stop()方法而停止的线程。 ','BE764AB8E1494296B05858C2E013C09D'),(9110,'b','通过调用sleep()方法而停止的线程。 ','BE764AB8E1494296B05858C2E013C09D'),(9111,'c','通过调用wait()方法而停止的线程。 ','BE764AB8E1494296B05858C2E013C09D'),(9112,'d','通过调用suspend()方法而停止的线程。 ','BE764AB8E1494296B05858C2E013C09D'),(9113,'a','InputStreamReader','1A020FCD7B0B4E13A23A493FADA22FA2'),(9114,'b','BufferedReader','1A020FCD7B0B4E13A23A493FADA22FA2'),(9115,'c','FileInputStream','1A020FCD7B0B4E13A23A493FADA22FA2'),(9116,'d','InputStream','1A020FCD7B0B4E13A23A493FADA22FA2'),(9117,'a','编译错误 ','DABA85128E00448FA65E10FFE7AD7CEC'),(9118,'b','抛出运行时异常 ','DABA85128E00448FA65E10FFE7AD7CEC'),(9119,'c','输出：bar ','DABA85128E00448FA65E10FFE7AD7CEC'),(9120,'d','代码正常运行，但是无输出 ','DABA85128E00448FA65E10FFE7AD7CEC'),(9121,'a','start()    ','869EE067DCA64D82854C1E112F89E100'),(9122,'b','init()    ','869EE067DCA64D82854C1E112F89E100'),(9123,'c','run()    ','869EE067DCA64D82854C1E112F89E100'),(9124,'d','main()  ','869EE067DCA64D82854C1E112F89E100'),(9125,'a','Output is null.             ','11212DBDD1A44058934324708EA4D36E'),(9126,'b','Output is 0 ','11212DBDD1A44058934324708EA4D36E'),(9127,'c','编译时报错 ','11212DBDD1A44058934324708EA4D36E'),(9128,'d','运行时报错','11212DBDD1A44058934324708EA4D36E'),(9129,'a','输出Exception ','363F2350E6EF415DAF2ADC888F91FC36'),(9130,'b','输出A,B,Exception ','363F2350E6EF415DAF2ADC888F91FC36'),(9131,'c','编译失败 ','363F2350E6EF415DAF2ADC888F91FC36'),(9132,'d','在运行时抛出NullPointerException异常 ','363F2350E6EF415DAF2ADC888F91FC36'),(9133,'a','输出：test ','F2D0D99EEF2A4E5193051947648AB39A'),(9134,'b','输出：Exception ','F2D0D99EEF2A4E5193051947648AB39A'),(9135,'c','编译失败 ','F2D0D99EEF2A4E5193051947648AB39A'),(9136,'d','输出：NullPointerException ','F2D0D99EEF2A4E5193051947648AB39A'),(9137,'a','输出Exception ','611D4AEC80094769AEAE9C4BC95D8881'),(9138,'b','输出A,B,Exception ','611D4AEC80094769AEAE9C4BC95D8881'),(9139,'c','编译失败 ','611D4AEC80094769AEAE9C4BC95D8881'),(9140,'d','在运行时抛出NullPointerException异常 ','611D4AEC80094769AEAE9C4BC95D8881'),(9141,'a','编译错误 ','5AB184E5D8B847BAB42E4E157895D4D8'),(9142,'b','抛出运行时异常 ','5AB184E5D8B847BAB42E4E157895D4D8'),(9143,'c','输出：sleep ','5AB184E5D8B847BAB42E4E157895D4D8'),(9144,'d','代码正常运行，但是无输出 ','5AB184E5D8B847BAB42E4E157895D4D8'),(9145,'a','通过调用stop()方法而停止的线程。 ','1EC1500ED4074D7B8C30FFBBBAA6C04F'),(9146,'b','通过调用sleep()方法而停止的线程。 ','1EC1500ED4074D7B8C30FFBBBAA6C04F'),(9147,'c','通过调用wait()方法而停止的线程。 ','1EC1500ED4074D7B8C30FFBBBAA6C04F'),(9148,'d','通过调用suspend()方法而停止的线程。 ','1EC1500ED4074D7B8C30FFBBBAA6C04F'),(9149,'a','s>>>=3   ','F2E5C52372504E2B9CDF61A9A63A209C'),(9150,'b','s[3]= “X”  ','F2E5C52372504E2B9CDF61A9A63A209C'),(9151,'c','int i = s.length()   ','F2E5C52372504E2B9CDF61A9A63A209C'),(9152,'d','s = s + 10 ','F2E5C52372504E2B9CDF61A9A63A209C'),(9153,'a','编译错误 ','51F51B0BDA244ECF92D31C95F19EAA5E'),(9154,'b','抛出运行时异常 ','51F51B0BDA244ECF92D31C95F19EAA5E'),(9155,'c','输出：sleep ','51F51B0BDA244ECF92D31C95F19EAA5E'),(9156,'d','代码正常运行，但是无输出 ','51F51B0BDA244ECF92D31C95F19EAA5E'),(9157,'a','编译错误 ','A1017607321A4A5EB2BE8680453F80D5'),(9158,'b','实现向文件record.dat追加写入字符a ','A1017607321A4A5EB2BE8680453F80D5'),(9159,'c','实现向文件record.dat覆盖写入字符a ','A1017607321A4A5EB2BE8680453F80D5'),(9160,'d','文件record.dat无任何内容 ','A1017607321A4A5EB2BE8680453F80D5'),(9161,'a','private synchronized Object o; ','07053EEADBE04BEBB398F2D483A70F99'),(9162,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','07053EEADBE04BEBB398F2D483A70F99'),(9163,'c','public synchronized void go() { /* code here */ } ','07053EEADBE04BEBB398F2D483A70F99'),(9164,'d','private synchronized(this) void go() { /* code here */ } ','07053EEADBE04BEBB398F2D483A70F99'),(9165,'a','long 1 = 4990  ','68CCF557034442B281878CF9E6BFD4DE'),(9166,'b','int i = 4L  ','68CCF557034442B281878CF9E6BFD4DE'),(9167,'c','float f =1.1  ','68CCF557034442B281878CF9E6BFD4DE'),(9168,'d','double d = 34.4','68CCF557034442B281878CF9E6BFD4DE'),(9169,'a','编译错误 ','5A933E2EEBBC4A229559620E98E90B90'),(9170,'b','抛出运行时异常 ','5A933E2EEBBC4A229559620E98E90B90'),(9171,'c','输出：bar ','5A933E2EEBBC4A229559620E98E90B90'),(9172,'d','代码正常运行，但是无输出 ','5A933E2EEBBC4A229559620E98E90B90'),(9173,'a','public void method( int m){...}     ','B12C8EC45F3545FA82803E97CC85D14D'),(9174,'b','public int method(){...} ','B12C8EC45F3545FA82803E97CC85D14D'),(9175,'c','public void method2(){...}    ','B12C8EC45F3545FA82803E97CC85D14D'),(9176,'d','public int method(int m，float f ){...} ','B12C8EC45F3545FA82803E97CC85D14D'),(9177,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','532107F14CC54242AB262B56B8296256'),(9178,'b','垃圾收集将检查并释放不在使用的内存  ','532107F14CC54242AB262B56B8296256'),(9179,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','532107F14CC54242AB262B56B8296256'),(9180,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','532107F14CC54242AB262B56B8296256'),(9181,'a','栈是非线性结构        ','761BD4B1E7414414AD58669E18B4DCF2'),(9182,'b','栈是一种树状结构 ','761BD4B1E7414414AD58669E18B4DCF2'),(9183,'c','栈具有先进先出的特征  ','761BD4B1E7414414AD58669E18B4DCF2'),(9184,'d','栈具有后进先出的特征 ','761BD4B1E7414414AD58669E18B4DCF2'),(9185,'a','编译错误 ','3E02A49E8BEF4AF697DC269A35EFCCCF'),(9186,'b','程序可以通过编译，运行后文件company.txt没有任何改变','3E02A49E8BEF4AF697DC269A35EFCCCF'),(9187,'c','程序可以通过编译，运行后文件company.txt的长度变为0','3E02A49E8BEF4AF697DC269A35EFCCCF'),(9188,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','3E02A49E8BEF4AF697DC269A35EFCCCF'),(9189,'a','const   ','260768D9F1034266916A21BABAD2523E'),(9190,'b','NULL  ','260768D9F1034266916A21BABAD2523E'),(9191,'c','false   ','260768D9F1034266916A21BABAD2523E'),(9192,'d','this  ','260768D9F1034266916A21BABAD2523E'),(9193,'a','5.0','E20410F206D74944A4E8666E35938B8C'),(9194,'b','4.0','E20410F206D74944A4E8666E35938B8C'),(9195,'c','6.0','E20410F206D74944A4E8666E35938B8C'),(9196,'d','finished','E20410F206D74944A4E8666E35938B8C'),(9197,'a','将private int m改为 protected int m  ','8603F7C70EE14A2FABEDA2B3B16B6690'),(9198,'b','将private int m改为 public int m    ','8603F7C70EE14A2FABEDA2B3B16B6690'),(9199,'c','将private int m改为 static int m     ','8603F7C70EE14A2FABEDA2B3B16B6690'),(9200,'d','将private int m改为int m ','8603F7C70EE14A2FABEDA2B3B16B6690'),(9201,'a','const   ','0083C71347CC4797AB96263E4185F889'),(9202,'b','NULL  ','0083C71347CC4797AB96263E4185F889'),(9203,'c','false   ','0083C71347CC4797AB96263E4185F889'),(9204,'d','this  ','0083C71347CC4797AB96263E4185F889'),(9205,'a','将private int m改为 protected int m  ','CE32D8F81A3A4799891423AEE1340405'),(9206,'b','将private int m改为 public int m    ','CE32D8F81A3A4799891423AEE1340405'),(9207,'c','将private int m改为 static int m     ','CE32D8F81A3A4799891423AEE1340405'),(9208,'d','将private int m改为int m ','CE32D8F81A3A4799891423AEE1340405'),(9209,'a','通过调用stop()方法而停止的线程。 ','313E2F7B9922463B88BF759DEEBF2A7A'),(9210,'b','通过调用sleep()方法而停止的线程。 ','313E2F7B9922463B88BF759DEEBF2A7A'),(9211,'c','通过调用wait()方法而停止的线程。 ','313E2F7B9922463B88BF759DEEBF2A7A'),(9212,'d','通过调用suspend()方法而停止的线程。 ','313E2F7B9922463B88BF759DEEBF2A7A'),(9213,'a','编译错误 ','1624520090D94AD9B15CB097BBAC75BA'),(9214,'b','抛出运行时异常 ','1624520090D94AD9B15CB097BBAC75BA'),(9215,'c','输出：sleep ','1624520090D94AD9B15CB097BBAC75BA'),(9216,'d','代码正常运行，但是无输出 ','1624520090D94AD9B15CB097BBAC75BA'),(9217,'a','public void method( int m){...}     ','BDEF71151BB541A89958AD77AD4FADAC'),(9218,'b','public int method(){...} ','BDEF71151BB541A89958AD77AD4FADAC'),(9219,'c','public void method2(){...}    ','BDEF71151BB541A89958AD77AD4FADAC'),(9220,'d','public int method(int m，float f ){...} ','BDEF71151BB541A89958AD77AD4FADAC'),(9221,'a','输出：test ','2B112C8E4CCB408084F3C8693D04FDA3'),(9222,'b','输出：Exception ','2B112C8E4CCB408084F3C8693D04FDA3'),(9223,'c','编译失败 ','2B112C8E4CCB408084F3C8693D04FDA3'),(9224,'d','输出：NullPointerException ','2B112C8E4CCB408084F3C8693D04FDA3'),(9225,'a','s>>>=3   ','E7A1E270F6524A3A972760128DB50840'),(9226,'b','s[3]= “X”  ','E7A1E270F6524A3A972760128DB50840'),(9227,'c','int i = s.length()   ','E7A1E270F6524A3A972760128DB50840'),(9228,'d','s = s + 10 ','E7A1E270F6524A3A972760128DB50840'),(9229,'a','start()    ','07EB2BB685EC44C8884849B912F7CB7A'),(9230,'b','init()    ','07EB2BB685EC44C8884849B912F7CB7A'),(9231,'c','run()    ','07EB2BB685EC44C8884849B912F7CB7A'),(9232,'d','main()  ','07EB2BB685EC44C8884849B912F7CB7A'),(9233,'a','private synchronized Object o; ','321F2A7F05F24E6597D4FED785B45242'),(9234,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','321F2A7F05F24E6597D4FED785B45242'),(9235,'c','public synchronized void go() { /* code here */ } ','321F2A7F05F24E6597D4FED785B45242'),(9236,'d','private synchronized(this) void go() { /* code here */ } ','321F2A7F05F24E6597D4FED785B45242'),(9237,'a','sleep方法 ','D097C02401F1444CBF529D9790BE4D77'),(9238,'b','IO等待 ','D097C02401F1444CBF529D9790BE4D77'),(9239,'c','yield方法 ','D097C02401F1444CBF529D9790BE4D77'),(9240,'d','wait方法 ','D097C02401F1444CBF529D9790BE4D77'),(9241,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','D3BD2E6097594BF6897FA4773996D18D'),(9242,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','D3BD2E6097594BF6897FA4773996D18D'),(9243,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','D3BD2E6097594BF6897FA4773996D18D'),(9244,'d','new InputStreamReader(\"dat\") ; ','D3BD2E6097594BF6897FA4773996D18D'),(9245,'a','m.length()    ','38FA66E9834D4302AB1F526F0CB6C64C'),(9246,'b','m.length   ','38FA66E9834D4302AB1F526F0CB6C64C'),(9247,'c','m.length()+1   ','38FA66E9834D4302AB1F526F0CB6C64C'),(9248,'d','m.length-1','38FA66E9834D4302AB1F526F0CB6C64C'),(9249,'a','栈是非线性结构        ','8719133627C3459B8DA46936379D3E79'),(9250,'b','栈是一种树状结构 ','8719133627C3459B8DA46936379D3E79'),(9251,'c','栈具有先进先出的特征  ','8719133627C3459B8DA46936379D3E79'),(9252,'d','栈具有后进先出的特征 ','8719133627C3459B8DA46936379D3E79'),(9253,'a','将private int m改为 protected int m  ','6689209CD93F413C93678412C34B4E70'),(9254,'b','将private int m改为 public int m    ','6689209CD93F413C93678412C34B4E70'),(9255,'c','将private int m改为 static int m     ','6689209CD93F413C93678412C34B4E70'),(9256,'d','将private int m改为int m ','6689209CD93F413C93678412C34B4E70'),(9257,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','89E9C70714B04A18B1C300B2FDB5D7CF'),(9258,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','89E9C70714B04A18B1C300B2FDB5D7CF'),(9259,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','89E9C70714B04A18B1C300B2FDB5D7CF'),(9260,'d','new InputStreamReader(\"1.dat\") ; ','89E9C70714B04A18B1C300B2FDB5D7CF'),(9261,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','EADC8D24941E4F16AB713B5517F13B32'),(9262,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','EADC8D24941E4F16AB713B5517F13B32'),(9263,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','EADC8D24941E4F16AB713B5517F13B32'),(9264,'d','new InputStreamReader(\"1.dat\") ; ','EADC8D24941E4F16AB713B5517F13B32'),(9265,'a','编译错误 ','C47CB190F06C47EA81265325F6C27490'),(9266,'b','抛出运行时异常 ','C47CB190F06C47EA81265325F6C27490'),(9267,'c','输出：bar ','C47CB190F06C47EA81265325F6C27490'),(9268,'d','代码正常运行，但是无输出 ','C47CB190F06C47EA81265325F6C27490'),(9269,'a','long 1 = 4990  ','C7D9906B8C6C497DAE70F6674253F880'),(9270,'b','int i = 4L  ','C7D9906B8C6C497DAE70F6674253F880'),(9271,'c','float f =1.1  ','C7D9906B8C6C497DAE70F6674253F880'),(9272,'d','double d = 34.4','C7D9906B8C6C497DAE70F6674253F880'),(9273,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','721E4B443AB245538B65D16E7081D393'),(9274,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','721E4B443AB245538B65D16E7081D393'),(9275,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','721E4B443AB245538B65D16E7081D393'),(9276,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','721E4B443AB245538B65D16E7081D393'),(9277,'a','输出：4 ','55C7DEE9F0DC491797A5C5658FB1D231'),(9278,'b','在运行时抛出NullPointerException异常 ','55C7DEE9F0DC491797A5C5658FB1D231'),(9279,'c','在运行时抛出NumberFormatException异常 ','55C7DEE9F0DC491797A5C5658FB1D231'),(9280,'d','在运行时抛出IllegalStateException异常 ','55C7DEE9F0DC491797A5C5658FB1D231'),(9281,'a','名为dtThread的线程为守护线程 ','6105CCBD5536476792F6E35FA318F00D'),(9282,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','6105CCBD5536476792F6E35FA318F00D'),(9283,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','6105CCBD5536476792F6E35FA318F00D'),(9284,'d','main线程是守护线程 ','6105CCBD5536476792F6E35FA318F00D'),(9285,'a','编译错误 ','5B9D54CCE7CE48C1B0905B35DACD2F64'),(9286,'b','程序可以通过编译，运行后文件company.txt没有任何改变','5B9D54CCE7CE48C1B0905B35DACD2F64'),(9287,'c','程序可以通过编译，运行后文件company.txt的长度变为0','5B9D54CCE7CE48C1B0905B35DACD2F64'),(9288,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','5B9D54CCE7CE48C1B0905B35DACD2F64'),(9289,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','5F5B20CD56B849D980022DF0E5B9F388'),(9290,'b','垃圾收集将检查并释放不在使用的内存  ','5F5B20CD56B849D980022DF0E5B9F388'),(9291,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','5F5B20CD56B849D980022DF0E5B9F388'),(9292,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','5F5B20CD56B849D980022DF0E5B9F388'),(9293,'a','编译错误 ','B4CA7B491A94493094E3C9ADCF6E6C7D'),(9294,'b','实现向文件record.dat追加写入字符a ','B4CA7B491A94493094E3C9ADCF6E6C7D'),(9295,'c','实现向文件record.dat覆盖写入字符a ','B4CA7B491A94493094E3C9ADCF6E6C7D'),(9296,'d','文件record.dat无任何内容 ','B4CA7B491A94493094E3C9ADCF6E6C7D'),(9297,'a','编译错误 ','9BD1404A37234ECA826E696291EEA8C7'),(9298,'b','实现向文件record.dat追加写入字符a ','9BD1404A37234ECA826E696291EEA8C7'),(9299,'c','实现向文件record.dat覆盖写入字符a ','9BD1404A37234ECA826E696291EEA8C7'),(9300,'d','文件record.dat无任何内容 ','9BD1404A37234ECA826E696291EEA8C7'),(9301,'a','编译错误 ','4EDF44D4038B401E893CFFFB525DAEF6'),(9302,'b','实现向文件record.dat追加写入字符a ','4EDF44D4038B401E893CFFFB525DAEF6'),(9303,'c','实现向文件record.dat覆盖写入字符a ','4EDF44D4038B401E893CFFFB525DAEF6'),(9304,'d','文件record.dat无任何内容 ','4EDF44D4038B401E893CFFFB525DAEF6'),(9305,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','AEBA9B7D3D4D41778A14BFA9821E7FDD'),(9306,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','AEBA9B7D3D4D41778A14BFA9821E7FDD'),(9307,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','AEBA9B7D3D4D41778A14BFA9821E7FDD'),(9308,'d','new InputStreamReader(\"dat\") ; ','AEBA9B7D3D4D41778A14BFA9821E7FDD'),(9309,'a','private synchronized Object o; ','C0C7F2C266A9444C94EFE8C101869FAA'),(9310,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','C0C7F2C266A9444C94EFE8C101869FAA'),(9311,'c','public synchronized void go() { /* code here */ } ','C0C7F2C266A9444C94EFE8C101869FAA'),(9312,'d','private synchronized(this) void go() { /* code here */ } ','C0C7F2C266A9444C94EFE8C101869FAA'),(9313,'a','InputStreamReader','55635C9C01044E2E9F98AA5188D7A798'),(9314,'b','BufferedReader','55635C9C01044E2E9F98AA5188D7A798'),(9315,'c','FileInputStream','55635C9C01044E2E9F98AA5188D7A798'),(9316,'d','InputStream','55635C9C01044E2E9F98AA5188D7A798'),(9317,'a','输出：test ','FCD456FE19D74DCF870577A64775F01A'),(9318,'b','输出：Exception ','FCD456FE19D74DCF870577A64775F01A'),(9319,'c','编译失败 ','FCD456FE19D74DCF870577A64775F01A'),(9320,'d','输出：NullPointerException ','FCD456FE19D74DCF870577A64775F01A'),(9321,'a','第3行抛出异常 ','385356F3A7B34BE99CD61E859A40CCFB'),(9322,'b','第1行抛出异常 ','385356F3A7B34BE99CD61E859A40CCFB'),(9323,'c','第5行抛出异常 ','385356F3A7B34BE99CD61E859A40CCFB'),(9324,'d','第3行代码成功执行 ','385356F3A7B34BE99CD61E859A40CCFB'),(9325,'a','start()    ','A3AA8B2BAA9B4ABCAD8016754B27805F'),(9326,'b','init()    ','A3AA8B2BAA9B4ABCAD8016754B27805F'),(9327,'c','run()    ','A3AA8B2BAA9B4ABCAD8016754B27805F'),(9328,'d','main()  ','A3AA8B2BAA9B4ABCAD8016754B27805F'),(9329,'a','编译错误 ','34FD832E1C674363BC6A484873D625FB'),(9330,'b','实现向文件record.dat追加写入字符a ','34FD832E1C674363BC6A484873D625FB'),(9331,'c','实现向文件record.dat覆盖写入字符a ','34FD832E1C674363BC6A484873D625FB'),(9332,'d','文件record.dat无任何内容 ','34FD832E1C674363BC6A484873D625FB'),(9333,'a','输出Exception ','BAF617ABC55C451B848D8BA7831392DA'),(9334,'b','输出A,B,Exception ','BAF617ABC55C451B848D8BA7831392DA'),(9335,'c','编译失败 ','BAF617ABC55C451B848D8BA7831392DA'),(9336,'d','在运行时抛出NullPointerException异常 ','BAF617ABC55C451B848D8BA7831392DA'),(9337,'a','输出：4 ','4AAC582906B74BA7B24E8912C307E761'),(9338,'b','在运行时抛出NullPointerException异常 ','4AAC582906B74BA7B24E8912C307E761'),(9339,'c','在运行时抛出NumberFormatException异常 ','4AAC582906B74BA7B24E8912C307E761'),(9340,'d','在运行时抛出IllegalStateException异常 ','4AAC582906B74BA7B24E8912C307E761'),(9341,'a','编译错误 ','E5119048041048BA8FD71047961E2C13'),(9342,'b','实现向文件record.dat追加写入字符a ','E5119048041048BA8FD71047961E2C13'),(9343,'c','实现向文件record.dat覆盖写入字符a ','E5119048041048BA8FD71047961E2C13'),(9344,'d','文件record.dat无任何内容 ','E5119048041048BA8FD71047961E2C13'),(9345,'a','编译错误 ','83C621712001443098043C47D3CA1B93'),(9346,'b','程序可以通过编译，运行后文件company.txt没有任何改变','83C621712001443098043C47D3CA1B93'),(9347,'c','程序可以通过编译，运行后文件company.txt的长度变为0','83C621712001443098043C47D3CA1B93'),(9348,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','83C621712001443098043C47D3CA1B93'),(9349,'a','m.length()    ','49B8A0C78E3D46119C60500AE935AA9A'),(9350,'b','m.length   ','49B8A0C78E3D46119C60500AE935AA9A'),(9351,'c','m.length()+1   ','49B8A0C78E3D46119C60500AE935AA9A'),(9352,'d','m.length-1','49B8A0C78E3D46119C60500AE935AA9A'),(9353,'a','输出：4 ','09CF76033C224B3B81F30BC17455DA12'),(9354,'b','在运行时抛出NullPointerException异常 ','09CF76033C224B3B81F30BC17455DA12'),(9355,'c','在运行时抛出NumberFormatException异常 ','09CF76033C224B3B81F30BC17455DA12'),(9356,'d','在运行时抛出IllegalStateException异常 ','09CF76033C224B3B81F30BC17455DA12'),(9357,'a','名为dtThread的线程为守护线程 ','042472B1E50D421F86E921B1B7EE1F82'),(9358,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','042472B1E50D421F86E921B1B7EE1F82'),(9359,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','042472B1E50D421F86E921B1B7EE1F82'),(9360,'d','main线程是守护线程 ','042472B1E50D421F86E921B1B7EE1F82'),(9361,'a','s>>>=3   ','6D71DC33FC6E476EA47186F7CA7FC016'),(9362,'b','s[3]= “X”  ','6D71DC33FC6E476EA47186F7CA7FC016'),(9363,'c','int i = s.length()   ','6D71DC33FC6E476EA47186F7CA7FC016'),(9364,'d','s = s + 10 ','6D71DC33FC6E476EA47186F7CA7FC016'),(9365,'a','Output is null.             ','C38A8CF0A2084E658C518CF1617880DB'),(9366,'b','Output is 0 ','C38A8CF0A2084E658C518CF1617880DB'),(9367,'c','编译时报错 ','C38A8CF0A2084E658C518CF1617880DB'),(9368,'d','运行时报错','C38A8CF0A2084E658C518CF1617880DB'),(9369,'a','栈是非线性结构        ','586E65D652464C2B94F87A6CA6FAF00C'),(9370,'b','栈是一种树状结构 ','586E65D652464C2B94F87A6CA6FAF00C'),(9371,'c','栈具有先进先出的特征  ','586E65D652464C2B94F87A6CA6FAF00C'),(9372,'d','栈具有后进先出的特征 ','586E65D652464C2B94F87A6CA6FAF00C'),(9373,'a','InputStreamReader','7042FE042FA54970A3ED2B3A236558A1'),(9374,'b','BufferedReader','7042FE042FA54970A3ED2B3A236558A1'),(9375,'c','FileInputStream','7042FE042FA54970A3ED2B3A236558A1'),(9376,'d','InputStream','7042FE042FA54970A3ED2B3A236558A1'),(9377,'a','long 1 = 4990  ','A5A168F938A64E85920ECD9A2F9A6B69'),(9378,'b','int i = 4L  ','A5A168F938A64E85920ECD9A2F9A6B69'),(9379,'c','float f =1.1  ','A5A168F938A64E85920ECD9A2F9A6B69'),(9380,'d','double d = 34.4','A5A168F938A64E85920ECD9A2F9A6B69'),(9381,'a','sleep方法 ','F5DD3F49C76847B09CBEA42BD9323B3B'),(9382,'b','IO等待 ','F5DD3F49C76847B09CBEA42BD9323B3B'),(9383,'c','yield方法 ','F5DD3F49C76847B09CBEA42BD9323B3B'),(9384,'d','wait方法 ','F5DD3F49C76847B09CBEA42BD9323B3B'),(9385,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','2E6ACD1A03D1404197ECD3972F7E6B88'),(9386,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','2E6ACD1A03D1404197ECD3972F7E6B88'),(9387,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','2E6ACD1A03D1404197ECD3972F7E6B88'),(9388,'d','new InputStreamReader(\"dat\") ; ','2E6ACD1A03D1404197ECD3972F7E6B88'),(9389,'a','5.0','A940442C9A6747A1A96FCDBE13F4AE5F'),(9390,'b','4.0','A940442C9A6747A1A96FCDBE13F4AE5F'),(9391,'c','6.0','A940442C9A6747A1A96FCDBE13F4AE5F'),(9392,'d','finished','A940442C9A6747A1A96FCDBE13F4AE5F'),(9393,'a','第3行抛出异常 ','9F204C2DD5224C92B44B14741EDD5988'),(9394,'b','第1行抛出异常 ','9F204C2DD5224C92B44B14741EDD5988'),(9395,'c','第5行抛出异常 ','9F204C2DD5224C92B44B14741EDD5988'),(9396,'d','第3行代码成功执行 ','9F204C2DD5224C92B44B14741EDD5988'),(9397,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','E0B30D2F47E842BFB1134BE11021AA61'),(9398,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','E0B30D2F47E842BFB1134BE11021AA61'),(9399,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','E0B30D2F47E842BFB1134BE11021AA61'),(9400,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','E0B30D2F47E842BFB1134BE11021AA61'),(9401,'a','Output is null.             ','D01E062FAC054FCFB0AD66A7B61C2B40'),(9402,'b','Output is 0 ','D01E062FAC054FCFB0AD66A7B61C2B40'),(9403,'c','编译时报错 ','D01E062FAC054FCFB0AD66A7B61C2B40'),(9404,'d','运行时报错','D01E062FAC054FCFB0AD66A7B61C2B40'),(9405,'a','public void method( int m){...}     ','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(9406,'b','public int method(){...} ','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(9407,'c','public void method2(){...}    ','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(9408,'d','public int method(int m，float f ){...} ','9BD122DAC5CE47E0BD1B91ABEEFEDCFB'),(9409,'a','一旦一个线程被创建，它就立即开始运行。  ','F2E0C6ED9B474867AFA94CCA2F095F2E'),(9410,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','F2E0C6ED9B474867AFA94CCA2F095F2E'),(9411,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','F2E0C6ED9B474867AFA94CCA2F095F2E'),(9412,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','F2E0C6ED9B474867AFA94CCA2F095F2E'),(9413,'a','一旦一个线程被创建，它就立即开始运行。  ','FCA04C0045614350B3402FDA90B58777'),(9414,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','FCA04C0045614350B3402FDA90B58777'),(9415,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','FCA04C0045614350B3402FDA90B58777'),(9416,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','FCA04C0045614350B3402FDA90B58777'),(9417,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','6FF06E61B42944F8994D8AA47CF71681'),(9418,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','6FF06E61B42944F8994D8AA47CF71681'),(9419,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','6FF06E61B42944F8994D8AA47CF71681'),(9420,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','6FF06E61B42944F8994D8AA47CF71681'),(9421,'a','一旦一个线程被创建，它就立即开始运行。  ','76D31335BB6743518A442A1EDB033B4D'),(9422,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','76D31335BB6743518A442A1EDB033B4D'),(9423,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','76D31335BB6743518A442A1EDB033B4D'),(9424,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','76D31335BB6743518A442A1EDB033B4D'),(9425,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','FCEA2218EAAF4B96B857416F87C7E646'),(9426,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','FCEA2218EAAF4B96B857416F87C7E646'),(9427,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','FCEA2218EAAF4B96B857416F87C7E646'),(9428,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','FCEA2218EAAF4B96B857416F87C7E646'),(9429,'a','m.length()    ','00AACD826F4A4DC9A8DAEA3F69A9DC78'),(9430,'b','m.length   ','00AACD826F4A4DC9A8DAEA3F69A9DC78'),(9431,'c','m.length()+1   ','00AACD826F4A4DC9A8DAEA3F69A9DC78'),(9432,'d','m.length-1','00AACD826F4A4DC9A8DAEA3F69A9DC78'),(9433,'a','start()    ','25D1744CEA2845109266340BB9E5B7F0'),(9434,'b','init()    ','25D1744CEA2845109266340BB9E5B7F0'),(9435,'c','run()    ','25D1744CEA2845109266340BB9E5B7F0'),(9436,'d','main()  ','25D1744CEA2845109266340BB9E5B7F0'),(9437,'a','通过调用stop()方法而停止的线程。 ','E5212F7F4EA94EA3AD2695433FF75151'),(9438,'b','通过调用sleep()方法而停止的线程。 ','E5212F7F4EA94EA3AD2695433FF75151'),(9439,'c','通过调用wait()方法而停止的线程。 ','E5212F7F4EA94EA3AD2695433FF75151'),(9440,'d','通过调用suspend()方法而停止的线程。 ','E5212F7F4EA94EA3AD2695433FF75151'),(9441,'a','5.0','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(9442,'b','4.0','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(9443,'c','6.0','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(9444,'d','finished','82519CE2251D4FE2BDD2DC6DF86E2A0E'),(9445,'a','输出：test ','833F382A883F48CAAB42D61FAD7A9C3C'),(9446,'b','输出：Exception ','833F382A883F48CAAB42D61FAD7A9C3C'),(9447,'c','编译失败 ','833F382A883F48CAAB42D61FAD7A9C3C'),(9448,'d','输出：NullPointerException ','833F382A883F48CAAB42D61FAD7A9C3C'),(9449,'a','Output is null.             ','C15207E7452B406A8346FC84FA8B600A'),(9450,'b','Output is 0 ','C15207E7452B406A8346FC84FA8B600A'),(9451,'c','编译时报错 ','C15207E7452B406A8346FC84FA8B600A'),(9452,'d','运行时报错','C15207E7452B406A8346FC84FA8B600A'),(9453,'a','编译错误 ','10C92B8730C848249813116A972D3351'),(9454,'b','抛出运行时异常 ','10C92B8730C848249813116A972D3351'),(9455,'c','输出：bar ','10C92B8730C848249813116A972D3351'),(9456,'d','代码正常运行，但是无输出 ','10C92B8730C848249813116A972D3351'),(9457,'a','一旦一个线程被创建，它就立即开始运行。  ','6FEA99C5CFF04D7FBF84C69FC85536B4'),(9458,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','6FEA99C5CFF04D7FBF84C69FC85536B4'),(9459,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','6FEA99C5CFF04D7FBF84C69FC85536B4'),(9460,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','6FEA99C5CFF04D7FBF84C69FC85536B4'),(9461,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','5418643DE3974F9B92BFF27FEC134C0D'),(9462,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','5418643DE3974F9B92BFF27FEC134C0D'),(9463,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','5418643DE3974F9B92BFF27FEC134C0D'),(9464,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','5418643DE3974F9B92BFF27FEC134C0D'),(9465,'a','s>>>=3   ','68B15C3DC2D843A2BEFD678C72D5700D'),(9466,'b','s[3]= “X”  ','68B15C3DC2D843A2BEFD678C72D5700D'),(9467,'c','int i = s.length()   ','68B15C3DC2D843A2BEFD678C72D5700D'),(9468,'d','s = s + 10 ','68B15C3DC2D843A2BEFD678C72D5700D'),(9469,'a','第3行抛出异常 ','836E0657B0EF4D3FA87B7246E3E5D1B8'),(9470,'b','第1行抛出异常 ','836E0657B0EF4D3FA87B7246E3E5D1B8'),(9471,'c','第5行抛出异常 ','836E0657B0EF4D3FA87B7246E3E5D1B8'),(9472,'d','第3行代码成功执行 ','836E0657B0EF4D3FA87B7246E3E5D1B8'),(9473,'a','s>>>=3   ','587FB668F67C426AAF46742C2AEE85BC'),(9474,'b','s[3]= “X”  ','587FB668F67C426AAF46742C2AEE85BC'),(9475,'c','int i = s.length()   ','587FB668F67C426AAF46742C2AEE85BC'),(9476,'d','s = s + 10 ','587FB668F67C426AAF46742C2AEE85BC'),(9477,'a','m.length()    ','E11D352C3A5B41FEB3FFD4993593F09C'),(9478,'b','m.length   ','E11D352C3A5B41FEB3FFD4993593F09C'),(9479,'c','m.length()+1   ','E11D352C3A5B41FEB3FFD4993593F09C'),(9480,'d','m.length-1','E11D352C3A5B41FEB3FFD4993593F09C'),(9481,'a','通过调用stop()方法而停止的线程。 ','31EA8C2AA2AD4E77ABF8031A027DA4AC'),(9482,'b','通过调用sleep()方法而停止的线程。 ','31EA8C2AA2AD4E77ABF8031A027DA4AC'),(9483,'c','通过调用wait()方法而停止的线程。 ','31EA8C2AA2AD4E77ABF8031A027DA4AC'),(9484,'d','通过调用suspend()方法而停止的线程。 ','31EA8C2AA2AD4E77ABF8031A027DA4AC'),(9485,'a','InputStreamReader','BFF7FF82F64342399FF27D06BB8430A1'),(9486,'b','BufferedReader','BFF7FF82F64342399FF27D06BB8430A1'),(9487,'c','FileInputStream','BFF7FF82F64342399FF27D06BB8430A1'),(9488,'d','InputStream','BFF7FF82F64342399FF27D06BB8430A1'),(9489,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','3F1BA41B9D884B8281C390CC84CC4099'),(9490,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','3F1BA41B9D884B8281C390CC84CC4099'),(9491,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','3F1BA41B9D884B8281C390CC84CC4099'),(9492,'d','new InputStreamReader(\"1.dat\") ; ','3F1BA41B9D884B8281C390CC84CC4099'),(9493,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','099AEDF7DA4F442AA7C83489588EF4CA'),(9494,'b','垃圾收集将检查并释放不在使用的内存  ','099AEDF7DA4F442AA7C83489588EF4CA'),(9495,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','099AEDF7DA4F442AA7C83489588EF4CA'),(9496,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','099AEDF7DA4F442AA7C83489588EF4CA'),(9497,'a','Output is null.             ','E6A8E448B14A4B51B68A5D6DB552D2CB'),(9498,'b','Output is 0 ','E6A8E448B14A4B51B68A5D6DB552D2CB'),(9499,'c','编译时报错 ','E6A8E448B14A4B51B68A5D6DB552D2CB'),(9500,'d','运行时报错','E6A8E448B14A4B51B68A5D6DB552D2CB'),(9501,'a','将private int m改为 protected int m  ','40FAF9EE1CA34B4897823CC919830A13'),(9502,'b','将private int m改为 public int m    ','40FAF9EE1CA34B4897823CC919830A13'),(9503,'c','将private int m改为 static int m     ','40FAF9EE1CA34B4897823CC919830A13'),(9504,'d','将private int m改为int m ','40FAF9EE1CA34B4897823CC919830A13'),(9505,'a','将private int m改为 protected int m  ','CF3A4A97B1F049F28301E2BF6D77FC69'),(9506,'b','将private int m改为 public int m    ','CF3A4A97B1F049F28301E2BF6D77FC69'),(9507,'c','将private int m改为 static int m     ','CF3A4A97B1F049F28301E2BF6D77FC69'),(9508,'d','将private int m改为int m ','CF3A4A97B1F049F28301E2BF6D77FC69'),(9509,'a','通过调用stop()方法而停止的线程。 ','D0AECE6F725141C8B87EF739D8FFA824'),(9510,'b','通过调用sleep()方法而停止的线程。 ','D0AECE6F725141C8B87EF739D8FFA824'),(9511,'c','通过调用wait()方法而停止的线程。 ','D0AECE6F725141C8B87EF739D8FFA824'),(9512,'d','通过调用suspend()方法而停止的线程。 ','D0AECE6F725141C8B87EF739D8FFA824'),(9513,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','81C05B163FD341698EE3315AE8DAEBEA'),(9514,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','81C05B163FD341698EE3315AE8DAEBEA'),(9515,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','81C05B163FD341698EE3315AE8DAEBEA'),(9516,'d','new InputStreamReader(\"dat\") ; ','81C05B163FD341698EE3315AE8DAEBEA'),(9517,'a','名为dtThread的线程为守护线程 ','1580B09A53B2421190FD1956925C0EE3'),(9518,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','1580B09A53B2421190FD1956925C0EE3'),(9519,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','1580B09A53B2421190FD1956925C0EE3'),(9520,'d','main线程是守护线程 ','1580B09A53B2421190FD1956925C0EE3'),(9521,'a','long 1 = 4990  ','DD89C18AFABA42FA92E65DAFF569EDB1'),(9522,'b','int i = 4L  ','DD89C18AFABA42FA92E65DAFF569EDB1'),(9523,'c','float f =1.1  ','DD89C18AFABA42FA92E65DAFF569EDB1'),(9524,'d','double d = 34.4','DD89C18AFABA42FA92E65DAFF569EDB1'),(9525,'a','sleep方法 ','06589A904E3944C19374F445C3ED7C5C'),(9526,'b','IO等待 ','06589A904E3944C19374F445C3ED7C5C'),(9527,'c','yield方法 ','06589A904E3944C19374F445C3ED7C5C'),(9528,'d','wait方法 ','06589A904E3944C19374F445C3ED7C5C'),(9529,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','0D99252C648A4578A8089E982BCD8331'),(9530,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','0D99252C648A4578A8089E982BCD8331'),(9531,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','0D99252C648A4578A8089E982BCD8331'),(9532,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','0D99252C648A4578A8089E982BCD8331'),(9533,'a','5.0','7B76658AA67546F797523B33605421F5'),(9534,'b','4.0','7B76658AA67546F797523B33605421F5'),(9535,'c','6.0','7B76658AA67546F797523B33605421F5'),(9536,'d','finished','7B76658AA67546F797523B33605421F5'),(9537,'a','名为dtThread的线程为守护线程 ','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(9538,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(9539,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(9540,'d','main线程是守护线程 ','C3F081DDE5F54FF0AE3A2E86173F5AD6'),(9541,'a','编译错误 ','EC30AFFCAF674872AAA22936E6C1ABD0'),(9542,'b','抛出运行时异常 ','EC30AFFCAF674872AAA22936E6C1ABD0'),(9543,'c','输出：sleep ','EC30AFFCAF674872AAA22936E6C1ABD0'),(9544,'d','代码正常运行，但是无输出 ','EC30AFFCAF674872AAA22936E6C1ABD0'),(9545,'a','InputStreamReader','D6B319073120466AAD0FD53565B7573B'),(9546,'b','BufferedReader','D6B319073120466AAD0FD53565B7573B'),(9547,'c','FileInputStream','D6B319073120466AAD0FD53565B7573B'),(9548,'d','InputStream','D6B319073120466AAD0FD53565B7573B'),(9549,'a','const   ','A06DC45F726040989335C1E67A96EDB9'),(9550,'b','NULL  ','A06DC45F726040989335C1E67A96EDB9'),(9551,'c','false   ','A06DC45F726040989335C1E67A96EDB9'),(9552,'d','this  ','A06DC45F726040989335C1E67A96EDB9'),(9553,'a','5.0','CAE89907A4C84839A8D14281D2EA93D7'),(9554,'b','4.0','CAE89907A4C84839A8D14281D2EA93D7'),(9555,'c','6.0','CAE89907A4C84839A8D14281D2EA93D7'),(9556,'d','finished','CAE89907A4C84839A8D14281D2EA93D7'),(9557,'a','编译错误 ','EE500293852D44BB96FA44B02C49240E'),(9558,'b','实现向文件record.dat追加写入字符a ','EE500293852D44BB96FA44B02C49240E'),(9559,'c','实现向文件record.dat覆盖写入字符a ','EE500293852D44BB96FA44B02C49240E'),(9560,'d','文件record.dat无任何内容 ','EE500293852D44BB96FA44B02C49240E'),(9561,'a','第3行抛出异常 ','B2DB8EEE147F4094A43B46C6FAEC13C9'),(9562,'b','第1行抛出异常 ','B2DB8EEE147F4094A43B46C6FAEC13C9'),(9563,'c','第5行抛出异常 ','B2DB8EEE147F4094A43B46C6FAEC13C9'),(9564,'d','第3行代码成功执行 ','B2DB8EEE147F4094A43B46C6FAEC13C9'),(9565,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','E8513B120F344F9D8F71ABDC795D8089'),(9566,'b','垃圾收集将检查并释放不在使用的内存  ','E8513B120F344F9D8F71ABDC795D8089'),(9567,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','E8513B120F344F9D8F71ABDC795D8089'),(9568,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','E8513B120F344F9D8F71ABDC795D8089'),(9569,'a','输出：4 ','890DF060C28D479EA02CAECB82B57EEF'),(9570,'b','在运行时抛出NullPointerException异常 ','890DF060C28D479EA02CAECB82B57EEF'),(9571,'c','在运行时抛出NumberFormatException异常 ','890DF060C28D479EA02CAECB82B57EEF'),(9572,'d','在运行时抛出IllegalStateException异常 ','890DF060C28D479EA02CAECB82B57EEF'),(9573,'a','编译错误 ','C7D85EC8A9614BBFB89DED4988C6BB59'),(9574,'b','实现向文件record.dat追加写入字符a ','C7D85EC8A9614BBFB89DED4988C6BB59'),(9575,'c','实现向文件record.dat覆盖写入字符a ','C7D85EC8A9614BBFB89DED4988C6BB59'),(9576,'d','文件record.dat无任何内容 ','C7D85EC8A9614BBFB89DED4988C6BB59'),(9577,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','FE8C619C1F57498CA1715384B824FFC6'),(9578,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','FE8C619C1F57498CA1715384B824FFC6'),(9579,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','FE8C619C1F57498CA1715384B824FFC6'),(9580,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','FE8C619C1F57498CA1715384B824FFC6'),(9581,'a','private synchronized Object o; ','AC726D85E28A4E6C90451508591C83B4'),(9582,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','AC726D85E28A4E6C90451508591C83B4'),(9583,'c','public synchronized void go() { /* code here */ } ','AC726D85E28A4E6C90451508591C83B4'),(9584,'d','private synchronized(this) void go() { /* code here */ } ','AC726D85E28A4E6C90451508591C83B4'),(9585,'a','const   ','CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(9586,'b','NULL  ','CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(9587,'c','false   ','CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(9588,'d','this  ','CCEBE8A50B6C4743BC4CD7DF7DC6BE35'),(9589,'a','start()    ','CA9371AC226A468CB60FA0F8872ED2A1'),(9590,'b','init()    ','CA9371AC226A468CB60FA0F8872ED2A1'),(9591,'c','run()    ','CA9371AC226A468CB60FA0F8872ED2A1'),(9592,'d','main()  ','CA9371AC226A468CB60FA0F8872ED2A1'),(9593,'a','编译错误 ','18A4504BFA7E4804867563234764F3C4'),(9594,'b','程序可以通过编译，运行后文件company.txt没有任何改变','18A4504BFA7E4804867563234764F3C4'),(9595,'c','程序可以通过编译，运行后文件company.txt的长度变为0','18A4504BFA7E4804867563234764F3C4'),(9596,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','18A4504BFA7E4804867563234764F3C4'),(9597,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','6BCB57D0A7F84F27B3C4E6A852803175'),(9598,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','6BCB57D0A7F84F27B3C4E6A852803175'),(9599,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','6BCB57D0A7F84F27B3C4E6A852803175'),(9600,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','6BCB57D0A7F84F27B3C4E6A852803175'),(9601,'a','public void method( int m){...}     ','9806288D7CF14AD4888AE7A6B4C1D4FC'),(9602,'b','public int method(){...} ','9806288D7CF14AD4888AE7A6B4C1D4FC'),(9603,'c','public void method2(){...}    ','9806288D7CF14AD4888AE7A6B4C1D4FC'),(9604,'d','public int method(int m，float f ){...} ','9806288D7CF14AD4888AE7A6B4C1D4FC'),(9605,'a','一旦一个线程被创建，它就立即开始运行。  ','3AFD96EFC3A64996BB8244B58989D188'),(9606,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','3AFD96EFC3A64996BB8244B58989D188'),(9607,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','3AFD96EFC3A64996BB8244B58989D188'),(9608,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','3AFD96EFC3A64996BB8244B58989D188'),(9609,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','4CE57B2F42C147028A4287A6226AFC2A'),(9610,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','4CE57B2F42C147028A4287A6226AFC2A'),(9611,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','4CE57B2F42C147028A4287A6226AFC2A'),(9612,'d','new InputStreamReader(\"dat\") ; ','4CE57B2F42C147028A4287A6226AFC2A'),(9613,'a','名为dtThread的线程为守护线程 ','18888E5C88D145729DE1207DAA84C86A'),(9614,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','18888E5C88D145729DE1207DAA84C86A'),(9615,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','18888E5C88D145729DE1207DAA84C86A'),(9616,'d','main线程是守护线程 ','18888E5C88D145729DE1207DAA84C86A'),(9617,'a','public void method( int m){...}     ','636BFC576A2B44E592BBE8FA2AF21612'),(9618,'b','public int method(){...} ','636BFC576A2B44E592BBE8FA2AF21612'),(9619,'c','public void method2(){...}    ','636BFC576A2B44E592BBE8FA2AF21612'),(9620,'d','public int method(int m，float f ){...} ','636BFC576A2B44E592BBE8FA2AF21612'),(9621,'a','一旦一个线程被创建，它就立即开始运行。  ','8AA8059A98CF491C9243AB13A6FDDECF'),(9622,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','8AA8059A98CF491C9243AB13A6FDDECF'),(9623,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','8AA8059A98CF491C9243AB13A6FDDECF'),(9624,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','8AA8059A98CF491C9243AB13A6FDDECF'),(9625,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','828F2870EA394075B9477E3D69B4320B'),(9626,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','828F2870EA394075B9477E3D69B4320B'),(9627,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','828F2870EA394075B9477E3D69B4320B'),(9628,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','828F2870EA394075B9477E3D69B4320B'),(9629,'a','输出：test ','2E187FD1394E41C9BDD608AC338A6A31'),(9630,'b','输出：Exception ','2E187FD1394E41C9BDD608AC338A6A31'),(9631,'c','编译失败 ','2E187FD1394E41C9BDD608AC338A6A31'),(9632,'d','输出：NullPointerException ','2E187FD1394E41C9BDD608AC338A6A31'),(9633,'a','start()    ','F72E94DC22BA4393861DA5BB949FA9E5'),(9634,'b','init()    ','F72E94DC22BA4393861DA5BB949FA9E5'),(9635,'c','run()    ','F72E94DC22BA4393861DA5BB949FA9E5'),(9636,'d','main()  ','F72E94DC22BA4393861DA5BB949FA9E5'),(9637,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','B6A9C8BBA71E4B27B0882FE8436C979A'),(9638,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','B6A9C8BBA71E4B27B0882FE8436C979A'),(9639,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','B6A9C8BBA71E4B27B0882FE8436C979A'),(9640,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','B6A9C8BBA71E4B27B0882FE8436C979A'),(9641,'a','m.length()    ','8AC157A0E68744408824363480E9CCA6'),(9642,'b','m.length   ','8AC157A0E68744408824363480E9CCA6'),(9643,'c','m.length()+1   ','8AC157A0E68744408824363480E9CCA6'),(9644,'d','m.length-1','8AC157A0E68744408824363480E9CCA6'),(9645,'a','编译错误 ','A3C4A7BACCCD4E86935D4F075C87D4E3'),(9646,'b','实现向文件record.dat追加写入字符a ','A3C4A7BACCCD4E86935D4F075C87D4E3'),(9647,'c','实现向文件record.dat覆盖写入字符a ','A3C4A7BACCCD4E86935D4F075C87D4E3'),(9648,'d','文件record.dat无任何内容 ','A3C4A7BACCCD4E86935D4F075C87D4E3'),(9649,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0B7152F46F78437C8DADBECCACA0EEFF'),(9650,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0B7152F46F78437C8DADBECCACA0EEFF'),(9651,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0B7152F46F78437C8DADBECCACA0EEFF'),(9652,'d','new InputStreamReader(\"1.dat\") ; ','0B7152F46F78437C8DADBECCACA0EEFF'),(9653,'a','long 1 = 4990  ','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(9654,'b','int i = 4L  ','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(9655,'c','float f =1.1  ','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(9656,'d','double d = 34.4','BB5FDCD7D0744111A1F8A4BCBEBCCADE'),(9657,'a','编译错误 ','1DDC15491A174F9B8B40E3650FE6168B'),(9658,'b','实现向文件record.dat追加写入字符a ','1DDC15491A174F9B8B40E3650FE6168B'),(9659,'c','实现向文件record.dat覆盖写入字符a ','1DDC15491A174F9B8B40E3650FE6168B'),(9660,'d','文件record.dat无任何内容 ','1DDC15491A174F9B8B40E3650FE6168B'),(9661,'a','sleep方法 ','73CB3C7F6D144A35B2958AB3E7547493'),(9662,'b','IO等待 ','73CB3C7F6D144A35B2958AB3E7547493'),(9663,'c','yield方法 ','73CB3C7F6D144A35B2958AB3E7547493'),(9664,'d','wait方法 ','73CB3C7F6D144A35B2958AB3E7547493'),(9665,'a','InputStreamReader','E7C0DBDBDC144904B18929C1CB357027'),(9666,'b','BufferedReader','E7C0DBDBDC144904B18929C1CB357027'),(9667,'c','FileInputStream','E7C0DBDBDC144904B18929C1CB357027'),(9668,'d','InputStream','E7C0DBDBDC144904B18929C1CB357027'),(9669,'a','long 1 = 4990  ','445DBA57689B4DFC90E19EC07DD1A756'),(9670,'b','int i = 4L  ','445DBA57689B4DFC90E19EC07DD1A756'),(9671,'c','float f =1.1  ','445DBA57689B4DFC90E19EC07DD1A756'),(9672,'d','double d = 34.4','445DBA57689B4DFC90E19EC07DD1A756'),(9673,'a','编译错误 ','4210953AF462433EA4A369E1864D8090'),(9674,'b','抛出运行时异常 ','4210953AF462433EA4A369E1864D8090'),(9675,'c','输出：bar ','4210953AF462433EA4A369E1864D8090'),(9676,'d','代码正常运行，但是无输出 ','4210953AF462433EA4A369E1864D8090'),(9677,'a','编译错误 ','D93A487FA268463385013B6FD70F52CE'),(9678,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D93A487FA268463385013B6FD70F52CE'),(9679,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D93A487FA268463385013B6FD70F52CE'),(9680,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D93A487FA268463385013B6FD70F52CE'),(9681,'a','第3行抛出异常 ','9F5E5121F7964F9093E1026393E6F20B'),(9682,'b','第1行抛出异常 ','9F5E5121F7964F9093E1026393E6F20B'),(9683,'c','第5行抛出异常 ','9F5E5121F7964F9093E1026393E6F20B'),(9684,'d','第3行代码成功执行 ','9F5E5121F7964F9093E1026393E6F20B'),(9685,'a','编译错误 ','27D67D5731AE4CF7BBEFE1DB9E160C42'),(9686,'b','抛出运行时异常 ','27D67D5731AE4CF7BBEFE1DB9E160C42'),(9687,'c','输出：sleep ','27D67D5731AE4CF7BBEFE1DB9E160C42'),(9688,'d','代码正常运行，但是无输出 ','27D67D5731AE4CF7BBEFE1DB9E160C42'),(9689,'a','private synchronized Object o; ','BBC7FA02A7664CDA8181CD4F01EE0D1A'),(9690,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','BBC7FA02A7664CDA8181CD4F01EE0D1A'),(9691,'c','public synchronized void go() { /* code here */ } ','BBC7FA02A7664CDA8181CD4F01EE0D1A'),(9692,'d','private synchronized(this) void go() { /* code here */ } ','BBC7FA02A7664CDA8181CD4F01EE0D1A'),(9693,'a','输出：4 ','86B8DB0A20344012B50ABEEAF739E4AA'),(9694,'b','在运行时抛出NullPointerException异常 ','86B8DB0A20344012B50ABEEAF739E4AA'),(9695,'c','在运行时抛出NumberFormatException异常 ','86B8DB0A20344012B50ABEEAF739E4AA'),(9696,'d','在运行时抛出IllegalStateException异常 ','86B8DB0A20344012B50ABEEAF739E4AA'),(9697,'a','编译错误 ','FF4D8CA3ABE34BC1AFA822D4B4504E42'),(9698,'b','程序可以通过编译，运行后文件company.txt没有任何改变','FF4D8CA3ABE34BC1AFA822D4B4504E42'),(9699,'c','程序可以通过编译，运行后文件company.txt的长度变为0','FF4D8CA3ABE34BC1AFA822D4B4504E42'),(9700,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','FF4D8CA3ABE34BC1AFA822D4B4504E42'),(9701,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','E97DBD1F42F549298DD8042133E42162'),(9702,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','E97DBD1F42F549298DD8042133E42162'),(9703,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','E97DBD1F42F549298DD8042133E42162'),(9704,'d','new InputStreamReader(\"dat\") ; ','E97DBD1F42F549298DD8042133E42162'),(9705,'a','private synchronized Object o; ','93A8F00159984F7C94BF3E058511CBF6'),(9706,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','93A8F00159984F7C94BF3E058511CBF6'),(9707,'c','public synchronized void go() { /* code here */ } ','93A8F00159984F7C94BF3E058511CBF6'),(9708,'d','private synchronized(this) void go() { /* code here */ } ','93A8F00159984F7C94BF3E058511CBF6'),(9709,'a','栈是非线性结构        ','8DC355F938A24150B2EC698F89DD7577'),(9710,'b','栈是一种树状结构 ','8DC355F938A24150B2EC698F89DD7577'),(9711,'c','栈具有先进先出的特征  ','8DC355F938A24150B2EC698F89DD7577'),(9712,'d','栈具有后进先出的特征 ','8DC355F938A24150B2EC698F89DD7577'),(9713,'a','编译错误 ','E51DCBBBE50146F1A844BBDAAA9E5E7B'),(9714,'b','实现向文件record.dat追加写入字符a ','E51DCBBBE50146F1A844BBDAAA9E5E7B'),(9715,'c','实现向文件record.dat覆盖写入字符a ','E51DCBBBE50146F1A844BBDAAA9E5E7B'),(9716,'d','文件record.dat无任何内容 ','E51DCBBBE50146F1A844BBDAAA9E5E7B'),(9717,'a','sleep方法 ','0187DDB1A64541CB91AAD43C8C4D893B'),(9718,'b','IO等待 ','0187DDB1A64541CB91AAD43C8C4D893B'),(9719,'c','yield方法 ','0187DDB1A64541CB91AAD43C8C4D893B'),(9720,'d','wait方法 ','0187DDB1A64541CB91AAD43C8C4D893B'),(9721,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','C79815780E524013B0DA285ABD8BE6D5'),(9722,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','C79815780E524013B0DA285ABD8BE6D5'),(9723,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','C79815780E524013B0DA285ABD8BE6D5'),(9724,'d','new InputStreamReader(\"1.dat\") ; ','C79815780E524013B0DA285ABD8BE6D5'),(9725,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','E1804B69F6654A8EB5C93BAB44496924'),(9726,'b','垃圾收集将检查并释放不在使用的内存  ','E1804B69F6654A8EB5C93BAB44496924'),(9727,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','E1804B69F6654A8EB5C93BAB44496924'),(9728,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','E1804B69F6654A8EB5C93BAB44496924'),(9729,'a','编译错误 ','59315ACF311C46678C74334C65F8AE56'),(9730,'b','抛出运行时异常 ','59315ACF311C46678C74334C65F8AE56'),(9731,'c','输出：bar ','59315ACF311C46678C74334C65F8AE56'),(9732,'d','代码正常运行，但是无输出 ','59315ACF311C46678C74334C65F8AE56'),(9733,'a','输出Exception ','9363EE7CC3CA465192C0F0C5ADE4FAE8'),(9734,'b','输出A,B,Exception ','9363EE7CC3CA465192C0F0C5ADE4FAE8'),(9735,'c','编译失败 ','9363EE7CC3CA465192C0F0C5ADE4FAE8'),(9736,'d','在运行时抛出NullPointerException异常 ','9363EE7CC3CA465192C0F0C5ADE4FAE8'),(9737,'a','s>>>=3   ','AA628A9D894C40F4985AA0859AF2F5C6'),(9738,'b','s[3]= “X”  ','AA628A9D894C40F4985AA0859AF2F5C6'),(9739,'c','int i = s.length()   ','AA628A9D894C40F4985AA0859AF2F5C6'),(9740,'d','s = s + 10 ','AA628A9D894C40F4985AA0859AF2F5C6'),(9741,'a','输出：4 ','1D6B31E30FC342C4A6282642CD20E420'),(9742,'b','在运行时抛出NullPointerException异常 ','1D6B31E30FC342C4A6282642CD20E420'),(9743,'c','在运行时抛出NumberFormatException异常 ','1D6B31E30FC342C4A6282642CD20E420'),(9744,'d','在运行时抛出IllegalStateException异常 ','1D6B31E30FC342C4A6282642CD20E420'),(9745,'a','栈是非线性结构        ','B593B60625BA4BBF95E7887D05369FC3'),(9746,'b','栈是一种树状结构 ','B593B60625BA4BBF95E7887D05369FC3'),(9747,'c','栈具有先进先出的特征  ','B593B60625BA4BBF95E7887D05369FC3'),(9748,'d','栈具有后进先出的特征 ','B593B60625BA4BBF95E7887D05369FC3'),(9749,'a','编译错误 ','16C2365819974E789AA08B8578C8AF51'),(9750,'b','实现向文件record.dat追加写入字符a ','16C2365819974E789AA08B8578C8AF51'),(9751,'c','实现向文件record.dat覆盖写入字符a ','16C2365819974E789AA08B8578C8AF51'),(9752,'d','文件record.dat无任何内容 ','16C2365819974E789AA08B8578C8AF51'),(9753,'a','编译错误 ','D84DD65E84964D0AB771F2C782C4812C'),(9754,'b','抛出运行时异常 ','D84DD65E84964D0AB771F2C782C4812C'),(9755,'c','输出：bar ','D84DD65E84964D0AB771F2C782C4812C'),(9756,'d','代码正常运行，但是无输出 ','D84DD65E84964D0AB771F2C782C4812C'),(9757,'a','start()    ','827C478ED184485AA4F64EC554B8A06A'),(9758,'b','init()    ','827C478ED184485AA4F64EC554B8A06A'),(9759,'c','run()    ','827C478ED184485AA4F64EC554B8A06A'),(9760,'d','main()  ','827C478ED184485AA4F64EC554B8A06A'),(9761,'a','输出Exception ','A51915FFDEFC44869C3F1D0A322F6922'),(9762,'b','输出A,B,Exception ','A51915FFDEFC44869C3F1D0A322F6922'),(9763,'c','编译失败 ','A51915FFDEFC44869C3F1D0A322F6922'),(9764,'d','在运行时抛出NullPointerException异常 ','A51915FFDEFC44869C3F1D0A322F6922'),(9765,'a','一旦一个线程被创建，它就立即开始运行。  ','2496A0B50F454B258AA43B6088B89E31'),(9766,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','2496A0B50F454B258AA43B6088B89E31'),(9767,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','2496A0B50F454B258AA43B6088B89E31'),(9768,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','2496A0B50F454B258AA43B6088B89E31'),(9769,'a','通过调用stop()方法而停止的线程。 ','DF01EAC0D0B1413386200EEF87093AC3'),(9770,'b','通过调用sleep()方法而停止的线程。 ','DF01EAC0D0B1413386200EEF87093AC3'),(9771,'c','通过调用wait()方法而停止的线程。 ','DF01EAC0D0B1413386200EEF87093AC3'),(9772,'d','通过调用suspend()方法而停止的线程。 ','DF01EAC0D0B1413386200EEF87093AC3'),(9773,'a','public void method( int m){...}     ','E08ECA9A1B044C26AFEB25B0360CDD91'),(9774,'b','public int method(){...} ','E08ECA9A1B044C26AFEB25B0360CDD91'),(9775,'c','public void method2(){...}    ','E08ECA9A1B044C26AFEB25B0360CDD91'),(9776,'d','public int method(int m，float f ){...} ','E08ECA9A1B044C26AFEB25B0360CDD91'),(9777,'a','Output is null.             ','0CD67EE2697F4C3291A13DD4646D310F'),(9778,'b','Output is 0 ','0CD67EE2697F4C3291A13DD4646D310F'),(9779,'c','编译时报错 ','0CD67EE2697F4C3291A13DD4646D310F'),(9780,'d','运行时报错','0CD67EE2697F4C3291A13DD4646D310F'),(9781,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','11127C77AACE419BA648D1CD4453FA92'),(9782,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','11127C77AACE419BA648D1CD4453FA92'),(9783,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','11127C77AACE419BA648D1CD4453FA92'),(9784,'d','new InputStreamReader(\"dat\") ; ','11127C77AACE419BA648D1CD4453FA92'),(9785,'a','将private int m改为 protected int m  ','641D0B5317F44561A113792B251C8D6E'),(9786,'b','将private int m改为 public int m    ','641D0B5317F44561A113792B251C8D6E'),(9787,'c','将private int m改为 static int m     ','641D0B5317F44561A113792B251C8D6E'),(9788,'d','将private int m改为int m ','641D0B5317F44561A113792B251C8D6E'),(9789,'a','编译错误 ','4B7689B59C4345F5BF12BE380BCE66E5'),(9790,'b','实现向文件record.dat追加写入字符a ','4B7689B59C4345F5BF12BE380BCE66E5'),(9791,'c','实现向文件record.dat覆盖写入字符a ','4B7689B59C4345F5BF12BE380BCE66E5'),(9792,'d','文件record.dat无任何内容 ','4B7689B59C4345F5BF12BE380BCE66E5'),(9793,'a','第3行抛出异常 ','FC1B330CAEF446DD9391A0E74169E88A'),(9794,'b','第1行抛出异常 ','FC1B330CAEF446DD9391A0E74169E88A'),(9795,'c','第5行抛出异常 ','FC1B330CAEF446DD9391A0E74169E88A'),(9796,'d','第3行代码成功执行 ','FC1B330CAEF446DD9391A0E74169E88A'),(9797,'a','long 1 = 4990  ','94C8949770CA43F19833AD4EA4B2265D'),(9798,'b','int i = 4L  ','94C8949770CA43F19833AD4EA4B2265D'),(9799,'c','float f =1.1  ','94C8949770CA43F19833AD4EA4B2265D'),(9800,'d','double d = 34.4','94C8949770CA43F19833AD4EA4B2265D'),(9801,'a','long 1 = 4990  ','DD22A69007974128B49075A981795973'),(9802,'b','int i = 4L  ','DD22A69007974128B49075A981795973'),(9803,'c','float f =1.1  ','DD22A69007974128B49075A981795973'),(9804,'d','double d = 34.4','DD22A69007974128B49075A981795973'),(9805,'a','start()    ','D4989B486CB34251B822DEB9BCBE98B5'),(9806,'b','init()    ','D4989B486CB34251B822DEB9BCBE98B5'),(9807,'c','run()    ','D4989B486CB34251B822DEB9BCBE98B5'),(9808,'d','main()  ','D4989B486CB34251B822DEB9BCBE98B5'),(9809,'a','const   ','FD3E2D92485A4E5A816E1DF8AC408122'),(9810,'b','NULL  ','FD3E2D92485A4E5A816E1DF8AC408122'),(9811,'c','false   ','FD3E2D92485A4E5A816E1DF8AC408122'),(9812,'d','this  ','FD3E2D92485A4E5A816E1DF8AC408122'),(9813,'a','栈是非线性结构        ','8432B9942E2C440ABA0AD08DCAE82645'),(9814,'b','栈是一种树状结构 ','8432B9942E2C440ABA0AD08DCAE82645'),(9815,'c','栈具有先进先出的特征  ','8432B9942E2C440ABA0AD08DCAE82645'),(9816,'d','栈具有后进先出的特征 ','8432B9942E2C440ABA0AD08DCAE82645'),(9817,'a','名为dtThread的线程为守护线程 ','C111F2F9370B41F4A841763D39FCFAA8'),(9818,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C111F2F9370B41F4A841763D39FCFAA8'),(9819,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C111F2F9370B41F4A841763D39FCFAA8'),(9820,'d','main线程是守护线程 ','C111F2F9370B41F4A841763D39FCFAA8'),(9821,'a','编译错误 ','438A253AECEB412DAC47BE5479F43ADE'),(9822,'b','程序可以通过编译，运行后文件company.txt没有任何改变','438A253AECEB412DAC47BE5479F43ADE'),(9823,'c','程序可以通过编译，运行后文件company.txt的长度变为0','438A253AECEB412DAC47BE5479F43ADE'),(9824,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','438A253AECEB412DAC47BE5479F43ADE'),(9825,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','E5CFBFC734EB47959ECA217B258B7BAF'),(9826,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','E5CFBFC734EB47959ECA217B258B7BAF'),(9827,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','E5CFBFC734EB47959ECA217B258B7BAF'),(9828,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','E5CFBFC734EB47959ECA217B258B7BAF'),(9829,'a','const   ','3A4D516356214E38A30A0DC4C2302566'),(9830,'b','NULL  ','3A4D516356214E38A30A0DC4C2302566'),(9831,'c','false   ','3A4D516356214E38A30A0DC4C2302566'),(9832,'d','this  ','3A4D516356214E38A30A0DC4C2302566'),(9833,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','5100A97BD3894E5E99F081EFBC0B6F55'),(9834,'b','垃圾收集将检查并释放不在使用的内存  ','5100A97BD3894E5E99F081EFBC0B6F55'),(9835,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','5100A97BD3894E5E99F081EFBC0B6F55'),(9836,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','5100A97BD3894E5E99F081EFBC0B6F55'),(9837,'a','InputStreamReader','A6A7044A7F7A462FBD0C561B58864BEC'),(9838,'b','BufferedReader','A6A7044A7F7A462FBD0C561B58864BEC'),(9839,'c','FileInputStream','A6A7044A7F7A462FBD0C561B58864BEC'),(9840,'d','InputStream','A6A7044A7F7A462FBD0C561B58864BEC'),(9841,'a','名为dtThread的线程为守护线程 ','2BC68E5DEA9142B0A111E6D926D05FB3'),(9842,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','2BC68E5DEA9142B0A111E6D926D05FB3'),(9843,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','2BC68E5DEA9142B0A111E6D926D05FB3'),(9844,'d','main线程是守护线程 ','2BC68E5DEA9142B0A111E6D926D05FB3'),(9845,'a','s>>>=3   ','23C5F1ED218C45FD89BA63EEE5847E70'),(9846,'b','s[3]= “X”  ','23C5F1ED218C45FD89BA63EEE5847E70'),(9847,'c','int i = s.length()   ','23C5F1ED218C45FD89BA63EEE5847E70'),(9848,'d','s = s + 10 ','23C5F1ED218C45FD89BA63EEE5847E70'),(9849,'a','编译错误 ','B2938B9D22E8498EA3018846F3A9D081'),(9850,'b','实现向文件record.dat追加写入字符a ','B2938B9D22E8498EA3018846F3A9D081'),(9851,'c','实现向文件record.dat覆盖写入字符a ','B2938B9D22E8498EA3018846F3A9D081'),(9852,'d','文件record.dat无任何内容 ','B2938B9D22E8498EA3018846F3A9D081'),(9853,'a','编译错误 ','D9A92C688BD14147AFFF9576828956ED'),(9854,'b','抛出运行时异常 ','D9A92C688BD14147AFFF9576828956ED'),(9855,'c','输出：sleep ','D9A92C688BD14147AFFF9576828956ED'),(9856,'d','代码正常运行，但是无输出 ','D9A92C688BD14147AFFF9576828956ED'),(9857,'a','编译错误 ','780C6CA9224B441CB4E4F2FD59AEC03C'),(9858,'b','抛出运行时异常 ','780C6CA9224B441CB4E4F2FD59AEC03C'),(9859,'c','输出：bar ','780C6CA9224B441CB4E4F2FD59AEC03C'),(9860,'d','代码正常运行，但是无输出 ','780C6CA9224B441CB4E4F2FD59AEC03C'),(9861,'a','编译错误 ','3B1438E8B5504EA4ACA30F2208D35EB7'),(9862,'b','抛出运行时异常 ','3B1438E8B5504EA4ACA30F2208D35EB7'),(9863,'c','输出：sleep ','3B1438E8B5504EA4ACA30F2208D35EB7'),(9864,'d','代码正常运行，但是无输出 ','3B1438E8B5504EA4ACA30F2208D35EB7'),(9865,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','A5697D6E64AA4A628FFAFE6FF3EC8215'),(9866,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','A5697D6E64AA4A628FFAFE6FF3EC8215'),(9867,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','A5697D6E64AA4A628FFAFE6FF3EC8215'),(9868,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','A5697D6E64AA4A628FFAFE6FF3EC8215'),(9869,'a','输出：4 ','8CC2A798185B421BB3F49B3069CD9506'),(9870,'b','在运行时抛出NullPointerException异常 ','8CC2A798185B421BB3F49B3069CD9506'),(9871,'c','在运行时抛出NumberFormatException异常 ','8CC2A798185B421BB3F49B3069CD9506'),(9872,'d','在运行时抛出IllegalStateException异常 ','8CC2A798185B421BB3F49B3069CD9506'),(9873,'a','栈是非线性结构        ','4FA8AA54627E4DDE9737E07F9C12E37A'),(9874,'b','栈是一种树状结构 ','4FA8AA54627E4DDE9737E07F9C12E37A'),(9875,'c','栈具有先进先出的特征  ','4FA8AA54627E4DDE9737E07F9C12E37A'),(9876,'d','栈具有后进先出的特征 ','4FA8AA54627E4DDE9737E07F9C12E37A'),(9877,'a','5.0','103FCE24367F4B23BF2CD87FBF800B85'),(9878,'b','4.0','103FCE24367F4B23BF2CD87FBF800B85'),(9879,'c','6.0','103FCE24367F4B23BF2CD87FBF800B85'),(9880,'d','finished','103FCE24367F4B23BF2CD87FBF800B85'),(9881,'a','编译错误 ','2F4E3D268EB64FEBBC712BC578172F98'),(9882,'b','程序可以通过编译，运行后文件company.txt没有任何改变','2F4E3D268EB64FEBBC712BC578172F98'),(9883,'c','程序可以通过编译，运行后文件company.txt的长度变为0','2F4E3D268EB64FEBBC712BC578172F98'),(9884,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','2F4E3D268EB64FEBBC712BC578172F98'),(9885,'a','编译错误 ','4123AA4AE4114D5EA7775911B4E0DDDD'),(9886,'b','实现向文件record.dat追加写入字符a ','4123AA4AE4114D5EA7775911B4E0DDDD'),(9887,'c','实现向文件record.dat覆盖写入字符a ','4123AA4AE4114D5EA7775911B4E0DDDD'),(9888,'d','文件record.dat无任何内容 ','4123AA4AE4114D5EA7775911B4E0DDDD'),(9889,'a','一旦一个线程被创建，它就立即开始运行。  ','C2D91934ACB644B0BFC86D36559128D7'),(9890,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','C2D91934ACB644B0BFC86D36559128D7'),(9891,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','C2D91934ACB644B0BFC86D36559128D7'),(9892,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','C2D91934ACB644B0BFC86D36559128D7'),(9893,'a','将private int m改为 protected int m  ','6759A728F5E44C70BFA99D12D3F0AC42'),(9894,'b','将private int m改为 public int m    ','6759A728F5E44C70BFA99D12D3F0AC42'),(9895,'c','将private int m改为 static int m     ','6759A728F5E44C70BFA99D12D3F0AC42'),(9896,'d','将private int m改为int m ','6759A728F5E44C70BFA99D12D3F0AC42'),(9897,'a','m.length()    ','E4936DC1453542B4A1F8FC037110B48A'),(9898,'b','m.length   ','E4936DC1453542B4A1F8FC037110B48A'),(9899,'c','m.length()+1   ','E4936DC1453542B4A1F8FC037110B48A'),(9900,'d','m.length-1','E4936DC1453542B4A1F8FC037110B48A'),(9901,'a','名为dtThread的线程为守护线程 ','FA5D46B793274E24A6AF3907C67607DA'),(9902,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','FA5D46B793274E24A6AF3907C67607DA'),(9903,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','FA5D46B793274E24A6AF3907C67607DA'),(9904,'d','main线程是守护线程 ','FA5D46B793274E24A6AF3907C67607DA'),(9905,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','7C480FEDACD94F4583BADDEE72673709'),(9906,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','7C480FEDACD94F4583BADDEE72673709'),(9907,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','7C480FEDACD94F4583BADDEE72673709'),(9908,'d','new InputStreamReader(\"dat\") ; ','7C480FEDACD94F4583BADDEE72673709'),(9909,'a','5.0','A73EAC86CDEA4CA3B1978419292F521F'),(9910,'b','4.0','A73EAC86CDEA4CA3B1978419292F521F'),(9911,'c','6.0','A73EAC86CDEA4CA3B1978419292F521F'),(9912,'d','finished','A73EAC86CDEA4CA3B1978419292F521F'),(9913,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','7BB4084D5F8A48CA8796677F2E26020D'),(9914,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','7BB4084D5F8A48CA8796677F2E26020D'),(9915,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','7BB4084D5F8A48CA8796677F2E26020D'),(9916,'d','new InputStreamReader(\"dat\") ; ','7BB4084D5F8A48CA8796677F2E26020D'),(9917,'a','m.length()    ','30C86F6F4CDD485F893EF185C0EA288E'),(9918,'b','m.length   ','30C86F6F4CDD485F893EF185C0EA288E'),(9919,'c','m.length()+1   ','30C86F6F4CDD485F893EF185C0EA288E'),(9920,'d','m.length-1','30C86F6F4CDD485F893EF185C0EA288E'),(9921,'a','输出Exception ','8CF52CFA53484BE9BC1028D23111189A'),(9922,'b','输出A,B,Exception ','8CF52CFA53484BE9BC1028D23111189A'),(9923,'c','编译失败 ','8CF52CFA53484BE9BC1028D23111189A'),(9924,'d','在运行时抛出NullPointerException异常 ','8CF52CFA53484BE9BC1028D23111189A'),(9925,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','3249367217DF42C5AE1E5E0D314EF3EA'),(9926,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','3249367217DF42C5AE1E5E0D314EF3EA'),(9927,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','3249367217DF42C5AE1E5E0D314EF3EA'),(9928,'d','new InputStreamReader(\"1.dat\") ; ','3249367217DF42C5AE1E5E0D314EF3EA'),(9929,'a','public void method( int m){...}     ','1FDD83077F8B4768920979D1E5BA6838'),(9930,'b','public int method(){...} ','1FDD83077F8B4768920979D1E5BA6838'),(9931,'c','public void method2(){...}    ','1FDD83077F8B4768920979D1E5BA6838'),(9932,'d','public int method(int m，float f ){...} ','1FDD83077F8B4768920979D1E5BA6838'),(9933,'a','通过调用stop()方法而停止的线程。 ','7C2EF35E3A434842A84696967CE3D00D'),(9934,'b','通过调用sleep()方法而停止的线程。 ','7C2EF35E3A434842A84696967CE3D00D'),(9935,'c','通过调用wait()方法而停止的线程。 ','7C2EF35E3A434842A84696967CE3D00D'),(9936,'d','通过调用suspend()方法而停止的线程。 ','7C2EF35E3A434842A84696967CE3D00D'),(9937,'a','Output is null.             ','93C17CB3F8E144F1973780D64C13195B'),(9938,'b','Output is 0 ','93C17CB3F8E144F1973780D64C13195B'),(9939,'c','编译时报错 ','93C17CB3F8E144F1973780D64C13195B'),(9940,'d','运行时报错','93C17CB3F8E144F1973780D64C13195B'),(9941,'a','编译错误 ','7D3B3D3ADBEC4D53BAACC875C32C4819'),(9942,'b','实现向文件record.dat追加写入字符a ','7D3B3D3ADBEC4D53BAACC875C32C4819'),(9943,'c','实现向文件record.dat覆盖写入字符a ','7D3B3D3ADBEC4D53BAACC875C32C4819'),(9944,'d','文件record.dat无任何内容 ','7D3B3D3ADBEC4D53BAACC875C32C4819'),(9945,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','9EBB8CFA0722497CA4B7393EB741569B'),(9946,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','9EBB8CFA0722497CA4B7393EB741569B'),(9947,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','9EBB8CFA0722497CA4B7393EB741569B'),(9948,'d','new InputStreamReader(\"1.dat\") ; ','9EBB8CFA0722497CA4B7393EB741569B'),(9949,'a','通过调用stop()方法而停止的线程。 ','669189E0EE974AD99EC186D906A60EDE'),(9950,'b','通过调用sleep()方法而停止的线程。 ','669189E0EE974AD99EC186D906A60EDE'),(9951,'c','通过调用wait()方法而停止的线程。 ','669189E0EE974AD99EC186D906A60EDE'),(9952,'d','通过调用suspend()方法而停止的线程。 ','669189E0EE974AD99EC186D906A60EDE'),(9953,'a','编译错误 ','8F6A1449C82A4C41B033BC59B2687735'),(9954,'b','抛出运行时异常 ','8F6A1449C82A4C41B033BC59B2687735'),(9955,'c','输出：sleep ','8F6A1449C82A4C41B033BC59B2687735'),(9956,'d','代码正常运行，但是无输出 ','8F6A1449C82A4C41B033BC59B2687735'),(9957,'a','输出：test ','3387171FEF3E46B1BC2296D1785AE6FF'),(9958,'b','输出：Exception ','3387171FEF3E46B1BC2296D1785AE6FF'),(9959,'c','编译失败 ','3387171FEF3E46B1BC2296D1785AE6FF'),(9960,'d','输出：NullPointerException ','3387171FEF3E46B1BC2296D1785AE6FF'),(9961,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','DF82C86C753143D99DD58C43809362A2'),(9962,'b','垃圾收集将检查并释放不在使用的内存  ','DF82C86C753143D99DD58C43809362A2'),(9963,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','DF82C86C753143D99DD58C43809362A2'),(9964,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','DF82C86C753143D99DD58C43809362A2'),(9965,'a','InputStreamReader','549DB8591D884A16A54A1F9F35580428'),(9966,'b','BufferedReader','549DB8591D884A16A54A1F9F35580428'),(9967,'c','FileInputStream','549DB8591D884A16A54A1F9F35580428'),(9968,'d','InputStream','549DB8591D884A16A54A1F9F35580428'),(9969,'a','private synchronized Object o; ','18B6974807F4499682F53E051B05C4A1'),(9970,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','18B6974807F4499682F53E051B05C4A1'),(9971,'c','public synchronized void go() { /* code here */ } ','18B6974807F4499682F53E051B05C4A1'),(9972,'d','private synchronized(this) void go() { /* code here */ } ','18B6974807F4499682F53E051B05C4A1'),(9973,'a','InputStreamReader','7C2F1161CC50473ABD2A332AB51293E3'),(9974,'b','BufferedReader','7C2F1161CC50473ABD2A332AB51293E3'),(9975,'c','FileInputStream','7C2F1161CC50473ABD2A332AB51293E3'),(9976,'d','InputStream','7C2F1161CC50473ABD2A332AB51293E3'),(9977,'a','start()    ','9D6F98CD105B4762A513CE99EB04E0DC'),(9978,'b','init()    ','9D6F98CD105B4762A513CE99EB04E0DC'),(9979,'c','run()    ','9D6F98CD105B4762A513CE99EB04E0DC'),(9980,'d','main()  ','9D6F98CD105B4762A513CE99EB04E0DC'),(9981,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','BDEE8D43E8D14381ADA8AE3FCC08EF13'),(9982,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','BDEE8D43E8D14381ADA8AE3FCC08EF13'),(9983,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','BDEE8D43E8D14381ADA8AE3FCC08EF13'),(9984,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','BDEE8D43E8D14381ADA8AE3FCC08EF13'),(9985,'a','Output is null.             ','27314DD2BFDA4EA7A01DF90CE1A9A026'),(9986,'b','Output is 0 ','27314DD2BFDA4EA7A01DF90CE1A9A026'),(9987,'c','编译时报错 ','27314DD2BFDA4EA7A01DF90CE1A9A026'),(9988,'d','运行时报错','27314DD2BFDA4EA7A01DF90CE1A9A026'),(9989,'a','将private int m改为 protected int m  ','F25C6A663FB14D9384D1DFF79046F13B'),(9990,'b','将private int m改为 public int m    ','F25C6A663FB14D9384D1DFF79046F13B'),(9991,'c','将private int m改为 static int m     ','F25C6A663FB14D9384D1DFF79046F13B'),(9992,'d','将private int m改为int m ','F25C6A663FB14D9384D1DFF79046F13B'),(9993,'a','s>>>=3   ','FDA049824048422AA1E88A55B7E14D5C'),(9994,'b','s[3]= “X”  ','FDA049824048422AA1E88A55B7E14D5C'),(9995,'c','int i = s.length()   ','FDA049824048422AA1E88A55B7E14D5C'),(9996,'d','s = s + 10 ','FDA049824048422AA1E88A55B7E14D5C'),(9997,'a','private synchronized Object o; ','5B981D45D2684B32914A4574AFF765C0'),(9998,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','5B981D45D2684B32914A4574AFF765C0'),(9999,'c','public synchronized void go() { /* code here */ } ','5B981D45D2684B32914A4574AFF765C0'),(10000,'d','private synchronized(this) void go() { /* code here */ } ','5B981D45D2684B32914A4574AFF765C0'),(10001,'a','const   ','9540F6F4BE2141A684F641E7C822C053'),(10002,'b','NULL  ','9540F6F4BE2141A684F641E7C822C053'),(10003,'c','false   ','9540F6F4BE2141A684F641E7C822C053'),(10004,'d','this  ','9540F6F4BE2141A684F641E7C822C053'),(10005,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','11B64CC57A4B4F958FC31DE2C6B49F24'),(10006,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','11B64CC57A4B4F958FC31DE2C6B49F24'),(10007,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','11B64CC57A4B4F958FC31DE2C6B49F24'),(10008,'d','new InputStreamReader(\"1.dat\") ; ','11B64CC57A4B4F958FC31DE2C6B49F24'),(10009,'a','sleep方法 ','315FD2E91BD8414095C4E3FF3CA9A440'),(10010,'b','IO等待 ','315FD2E91BD8414095C4E3FF3CA9A440'),(10011,'c','yield方法 ','315FD2E91BD8414095C4E3FF3CA9A440'),(10012,'d','wait方法 ','315FD2E91BD8414095C4E3FF3CA9A440'),(10013,'a','输出Exception ','98DB711D6D634A02823AB05B5335D7C8'),(10014,'b','输出A,B,Exception ','98DB711D6D634A02823AB05B5335D7C8'),(10015,'c','编译失败 ','98DB711D6D634A02823AB05B5335D7C8'),(10016,'d','在运行时抛出NullPointerException异常 ','98DB711D6D634A02823AB05B5335D7C8'),(10017,'a','long 1 = 4990  ','0ACDA1E3288247628E61BCAC197D1E1C'),(10018,'b','int i = 4L  ','0ACDA1E3288247628E61BCAC197D1E1C'),(10019,'c','float f =1.1  ','0ACDA1E3288247628E61BCAC197D1E1C'),(10020,'d','double d = 34.4','0ACDA1E3288247628E61BCAC197D1E1C'),(10021,'a','sleep方法 ','02B8BC857FA84D9090EFB477A8848417'),(10022,'b','IO等待 ','02B8BC857FA84D9090EFB477A8848417'),(10023,'c','yield方法 ','02B8BC857FA84D9090EFB477A8848417'),(10024,'d','wait方法 ','02B8BC857FA84D9090EFB477A8848417'),(10025,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','2321A0295E38405BBE668FA0A111AF55'),(10026,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','2321A0295E38405BBE668FA0A111AF55'),(10027,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','2321A0295E38405BBE668FA0A111AF55'),(10028,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','2321A0295E38405BBE668FA0A111AF55'),(10029,'a','编译错误 ','70E7D63B387E46C7AADF3EC978010B43'),(10030,'b','实现向文件record.dat追加写入字符a ','70E7D63B387E46C7AADF3EC978010B43'),(10031,'c','实现向文件record.dat覆盖写入字符a ','70E7D63B387E46C7AADF3EC978010B43'),(10032,'d','文件record.dat无任何内容 ','70E7D63B387E46C7AADF3EC978010B43'),(10033,'a','编译错误 ','6D3218BD8BA04B13A76F0104CA923A81'),(10034,'b','抛出运行时异常 ','6D3218BD8BA04B13A76F0104CA923A81'),(10035,'c','输出：bar ','6D3218BD8BA04B13A76F0104CA923A81'),(10036,'d','代码正常运行，但是无输出 ','6D3218BD8BA04B13A76F0104CA923A81'),(10037,'a','一旦一个线程被创建，它就立即开始运行。  ','D002B40C3EF240E1A6255D75A3B06858'),(10038,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','D002B40C3EF240E1A6255D75A3B06858'),(10039,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','D002B40C3EF240E1A6255D75A3B06858'),(10040,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','D002B40C3EF240E1A6255D75A3B06858'),(10041,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','527EEB7E835C46128859146EA60C57CD'),(10042,'b','垃圾收集将检查并释放不在使用的内存  ','527EEB7E835C46128859146EA60C57CD'),(10043,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','527EEB7E835C46128859146EA60C57CD'),(10044,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','527EEB7E835C46128859146EA60C57CD'),(10045,'a','编译错误 ','3C2C6CC580324177B4ECD21E41644026'),(10046,'b','实现向文件record.dat追加写入字符a ','3C2C6CC580324177B4ECD21E41644026'),(10047,'c','实现向文件record.dat覆盖写入字符a ','3C2C6CC580324177B4ECD21E41644026'),(10048,'d','文件record.dat无任何内容 ','3C2C6CC580324177B4ECD21E41644026'),(10049,'a','输出：test ','8FA99C085C3645FA82FCF6ACDDD478C6'),(10050,'b','输出：Exception ','8FA99C085C3645FA82FCF6ACDDD478C6'),(10051,'c','编译失败 ','8FA99C085C3645FA82FCF6ACDDD478C6'),(10052,'d','输出：NullPointerException ','8FA99C085C3645FA82FCF6ACDDD478C6'),(10053,'a','输出：test ','E11D9AB6F3C64E95A7BF5FF663F0912C'),(10054,'b','输出：Exception ','E11D9AB6F3C64E95A7BF5FF663F0912C'),(10055,'c','编译失败 ','E11D9AB6F3C64E95A7BF5FF663F0912C'),(10056,'d','输出：NullPointerException ','E11D9AB6F3C64E95A7BF5FF663F0912C'),(10057,'a','栈是非线性结构        ','C3ABE9208D7848F299090B4554F20785'),(10058,'b','栈是一种树状结构 ','C3ABE9208D7848F299090B4554F20785'),(10059,'c','栈具有先进先出的特征  ','C3ABE9208D7848F299090B4554F20785'),(10060,'d','栈具有后进先出的特征 ','C3ABE9208D7848F299090B4554F20785'),(10061,'a','public void method( int m){...}     ','3B4E8792088642EDA1DEBFA68A133D33'),(10062,'b','public int method(){...} ','3B4E8792088642EDA1DEBFA68A133D33'),(10063,'c','public void method2(){...}    ','3B4E8792088642EDA1DEBFA68A133D33'),(10064,'d','public int method(int m，float f ){...} ','3B4E8792088642EDA1DEBFA68A133D33'),(10065,'a','m.length()    ','29AE95E065684B01A516714F5DDE46CD'),(10066,'b','m.length   ','29AE95E065684B01A516714F5DDE46CD'),(10067,'c','m.length()+1   ','29AE95E065684B01A516714F5DDE46CD'),(10068,'d','m.length-1','29AE95E065684B01A516714F5DDE46CD'),(10069,'a','输出：4 ','95D6BC17D4D34D6B815FBE935F4D0BC4'),(10070,'b','在运行时抛出NullPointerException异常 ','95D6BC17D4D34D6B815FBE935F4D0BC4'),(10071,'c','在运行时抛出NumberFormatException异常 ','95D6BC17D4D34D6B815FBE935F4D0BC4'),(10072,'d','在运行时抛出IllegalStateException异常 ','95D6BC17D4D34D6B815FBE935F4D0BC4'),(10073,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','01CEAA4E91554641BA84F4BD61C49C11'),(10074,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','01CEAA4E91554641BA84F4BD61C49C11'),(10075,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','01CEAA4E91554641BA84F4BD61C49C11'),(10076,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','01CEAA4E91554641BA84F4BD61C49C11'),(10077,'a','第3行抛出异常 ','3795A47161A34FD4B23170FABF61D37F'),(10078,'b','第1行抛出异常 ','3795A47161A34FD4B23170FABF61D37F'),(10079,'c','第5行抛出异常 ','3795A47161A34FD4B23170FABF61D37F'),(10080,'d','第3行代码成功执行 ','3795A47161A34FD4B23170FABF61D37F'),(10081,'a','一旦一个线程被创建，它就立即开始运行。  ','8982AB42C8794CD1BC2654D5B6263EAE'),(10082,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','8982AB42C8794CD1BC2654D5B6263EAE'),(10083,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','8982AB42C8794CD1BC2654D5B6263EAE'),(10084,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','8982AB42C8794CD1BC2654D5B6263EAE'),(10085,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','58FC79388AC44E6DA8280CE64913E7BF'),(10086,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','58FC79388AC44E6DA8280CE64913E7BF'),(10087,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','58FC79388AC44E6DA8280CE64913E7BF'),(10088,'d','new InputStreamReader(\"1.dat\") ; ','58FC79388AC44E6DA8280CE64913E7BF'),(10089,'a','通过调用stop()方法而停止的线程。 ','82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(10090,'b','通过调用sleep()方法而停止的线程。 ','82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(10091,'c','通过调用wait()方法而停止的线程。 ','82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(10092,'d','通过调用suspend()方法而停止的线程。 ','82CBA9C2CCDA4C87A41BE5A1BAEBE40C'),(10093,'a','一旦一个线程被创建，它就立即开始运行。  ','B7858253780B4F10B35A2DF70121C369'),(10094,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','B7858253780B4F10B35A2DF70121C369'),(10095,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','B7858253780B4F10B35A2DF70121C369'),(10096,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','B7858253780B4F10B35A2DF70121C369'),(10097,'a','通过调用stop()方法而停止的线程。 ','9D58827A80EE4041A2D5B7FE9F70E965'),(10098,'b','通过调用sleep()方法而停止的线程。 ','9D58827A80EE4041A2D5B7FE9F70E965'),(10099,'c','通过调用wait()方法而停止的线程。 ','9D58827A80EE4041A2D5B7FE9F70E965'),(10100,'d','通过调用suspend()方法而停止的线程。 ','9D58827A80EE4041A2D5B7FE9F70E965'),(10101,'a','编译错误 ','41875999C5E44822853E3E5B267B96E6'),(10102,'b','抛出运行时异常 ','41875999C5E44822853E3E5B267B96E6'),(10103,'c','输出：bar ','41875999C5E44822853E3E5B267B96E6'),(10104,'d','代码正常运行，但是无输出 ','41875999C5E44822853E3E5B267B96E6'),(10105,'a','编译错误 ','EACBB9DADCF3466A82BD928EC2089CDD'),(10106,'b','抛出运行时异常 ','EACBB9DADCF3466A82BD928EC2089CDD'),(10107,'c','输出：bar ','EACBB9DADCF3466A82BD928EC2089CDD'),(10108,'d','代码正常运行，但是无输出 ','EACBB9DADCF3466A82BD928EC2089CDD'),(10109,'a','编译错误 ','38CFE97C37164229A3C9BBE9C1280D70'),(10110,'b','实现向文件record.dat追加写入字符a ','38CFE97C37164229A3C9BBE9C1280D70'),(10111,'c','实现向文件record.dat覆盖写入字符a ','38CFE97C37164229A3C9BBE9C1280D70'),(10112,'d','文件record.dat无任何内容 ','38CFE97C37164229A3C9BBE9C1280D70'),(10113,'a','编译错误 ','4AEEA146A2E74C32AE749F6E8A6B9316'),(10114,'b','抛出运行时异常 ','4AEEA146A2E74C32AE749F6E8A6B9316'),(10115,'c','输出：bar ','4AEEA146A2E74C32AE749F6E8A6B9316'),(10116,'d','代码正常运行，但是无输出 ','4AEEA146A2E74C32AE749F6E8A6B9316'),(10117,'a','s>>>=3   ','A242BA4E56C048FDA9320B5D740961D9'),(10118,'b','s[3]= “X”  ','A242BA4E56C048FDA9320B5D740961D9'),(10119,'c','int i = s.length()   ','A242BA4E56C048FDA9320B5D740961D9'),(10120,'d','s = s + 10 ','A242BA4E56C048FDA9320B5D740961D9'),(10121,'a','start()    ','477A1B9C4EC14ECC9B7290EB7FC1B409'),(10122,'b','init()    ','477A1B9C4EC14ECC9B7290EB7FC1B409'),(10123,'c','run()    ','477A1B9C4EC14ECC9B7290EB7FC1B409'),(10124,'d','main()  ','477A1B9C4EC14ECC9B7290EB7FC1B409'),(10125,'a','编译错误 ','1CFC6A1169DD4CFEB0CE86DA075E18CE'),(10126,'b','程序可以通过编译，运行后文件company.txt没有任何改变','1CFC6A1169DD4CFEB0CE86DA075E18CE'),(10127,'c','程序可以通过编译，运行后文件company.txt的长度变为0','1CFC6A1169DD4CFEB0CE86DA075E18CE'),(10128,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','1CFC6A1169DD4CFEB0CE86DA075E18CE'),(10129,'a','栈是非线性结构        ','BAF423A1133D48FE9749B9E60BAA0BE5'),(10130,'b','栈是一种树状结构 ','BAF423A1133D48FE9749B9E60BAA0BE5'),(10131,'c','栈具有先进先出的特征  ','BAF423A1133D48FE9749B9E60BAA0BE5'),(10132,'d','栈具有后进先出的特征 ','BAF423A1133D48FE9749B9E60BAA0BE5'),(10133,'a','long 1 = 4990  ','9B6EFE555A764348B9BE58531E38D912'),(10134,'b','int i = 4L  ','9B6EFE555A764348B9BE58531E38D912'),(10135,'c','float f =1.1  ','9B6EFE555A764348B9BE58531E38D912'),(10136,'d','double d = 34.4','9B6EFE555A764348B9BE58531E38D912'),(10137,'a','start()    ','63B45DA32B66475685F46FEE983F7547'),(10138,'b','init()    ','63B45DA32B66475685F46FEE983F7547'),(10139,'c','run()    ','63B45DA32B66475685F46FEE983F7547'),(10140,'d','main()  ','63B45DA32B66475685F46FEE983F7547'),(10141,'a','输出：4 ','14B207241F264703AEE06543DC63164B'),(10142,'b','在运行时抛出NullPointerException异常 ','14B207241F264703AEE06543DC63164B'),(10143,'c','在运行时抛出NumberFormatException异常 ','14B207241F264703AEE06543DC63164B'),(10144,'d','在运行时抛出IllegalStateException异常 ','14B207241F264703AEE06543DC63164B'),(10145,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','867A48EEA69C422F9355B9F7D562FAA2'),(10146,'b','垃圾收集将检查并释放不在使用的内存  ','867A48EEA69C422F9355B9F7D562FAA2'),(10147,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','867A48EEA69C422F9355B9F7D562FAA2'),(10148,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','867A48EEA69C422F9355B9F7D562FAA2'),(10149,'a','sleep方法 ','4ED826E4A855460F9E8126D83757CB82'),(10150,'b','IO等待 ','4ED826E4A855460F9E8126D83757CB82'),(10151,'c','yield方法 ','4ED826E4A855460F9E8126D83757CB82'),(10152,'d','wait方法 ','4ED826E4A855460F9E8126D83757CB82'),(10153,'a','输出：test ','4B60751411034489B7E1158DBCE6DB86'),(10154,'b','输出：Exception ','4B60751411034489B7E1158DBCE6DB86'),(10155,'c','编译失败 ','4B60751411034489B7E1158DBCE6DB86'),(10156,'d','输出：NullPointerException ','4B60751411034489B7E1158DBCE6DB86'),(10157,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','59B04F9C55C3496FA86542CB070905F4'),(10158,'b','垃圾收集将检查并释放不在使用的内存  ','59B04F9C55C3496FA86542CB070905F4'),(10159,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','59B04F9C55C3496FA86542CB070905F4'),(10160,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','59B04F9C55C3496FA86542CB070905F4'),(10161,'a','InputStreamReader','64685341D82C45B3B8F3B1A3134CF03A'),(10162,'b','BufferedReader','64685341D82C45B3B8F3B1A3134CF03A'),(10163,'c','FileInputStream','64685341D82C45B3B8F3B1A3134CF03A'),(10164,'d','InputStream','64685341D82C45B3B8F3B1A3134CF03A'),(10165,'a','sleep方法 ','663C829E8EED41DCB7F7C1E7A55FB822'),(10166,'b','IO等待 ','663C829E8EED41DCB7F7C1E7A55FB822'),(10167,'c','yield方法 ','663C829E8EED41DCB7F7C1E7A55FB822'),(10168,'d','wait方法 ','663C829E8EED41DCB7F7C1E7A55FB822'),(10169,'a','第3行抛出异常 ','F0C5CEFF9AD34E6ABDE812D79A1EC930'),(10170,'b','第1行抛出异常 ','F0C5CEFF9AD34E6ABDE812D79A1EC930'),(10171,'c','第5行抛出异常 ','F0C5CEFF9AD34E6ABDE812D79A1EC930'),(10172,'d','第3行代码成功执行 ','F0C5CEFF9AD34E6ABDE812D79A1EC930'),(10173,'a','编译错误 ','AE8CAA19996D439D8B4F5B11C10FFC21'),(10174,'b','实现向文件record.dat追加写入字符a ','AE8CAA19996D439D8B4F5B11C10FFC21'),(10175,'c','实现向文件record.dat覆盖写入字符a ','AE8CAA19996D439D8B4F5B11C10FFC21'),(10176,'d','文件record.dat无任何内容 ','AE8CAA19996D439D8B4F5B11C10FFC21'),(10177,'a','public void method( int m){...}     ','2B3329F1ED054BE198371A2B58AA25B7'),(10178,'b','public int method(){...} ','2B3329F1ED054BE198371A2B58AA25B7'),(10179,'c','public void method2(){...}    ','2B3329F1ED054BE198371A2B58AA25B7'),(10180,'d','public int method(int m，float f ){...} ','2B3329F1ED054BE198371A2B58AA25B7'),(10181,'a','long 1 = 4990  ','B32C9CFA62C9468588A801B2CE331CFC'),(10182,'b','int i = 4L  ','B32C9CFA62C9468588A801B2CE331CFC'),(10183,'c','float f =1.1  ','B32C9CFA62C9468588A801B2CE331CFC'),(10184,'d','double d = 34.4','B32C9CFA62C9468588A801B2CE331CFC'),(10185,'a','private synchronized Object o; ','8E292141F8314ACAB1BE203CEC7C65E7'),(10186,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','8E292141F8314ACAB1BE203CEC7C65E7'),(10187,'c','public synchronized void go() { /* code here */ } ','8E292141F8314ACAB1BE203CEC7C65E7'),(10188,'d','private synchronized(this) void go() { /* code here */ } ','8E292141F8314ACAB1BE203CEC7C65E7'),(10189,'a','Output is null.             ','F3D9F4A576FB434AB3B2B83D729D5ADB'),(10190,'b','Output is 0 ','F3D9F4A576FB434AB3B2B83D729D5ADB'),(10191,'c','编译时报错 ','F3D9F4A576FB434AB3B2B83D729D5ADB'),(10192,'d','运行时报错','F3D9F4A576FB434AB3B2B83D729D5ADB'),(10193,'a','编译错误 ','AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(10194,'b','实现向文件record.dat追加写入字符a ','AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(10195,'c','实现向文件record.dat覆盖写入字符a ','AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(10196,'d','文件record.dat无任何内容 ','AE28EDB7D5DF48DDA3BA4C6E4E23E100'),(10197,'a','m.length()    ','EF446F71B42F4CC19044F26B36678528'),(10198,'b','m.length   ','EF446F71B42F4CC19044F26B36678528'),(10199,'c','m.length()+1   ','EF446F71B42F4CC19044F26B36678528'),(10200,'d','m.length-1','EF446F71B42F4CC19044F26B36678528'),(10201,'a','输出Exception ','03EE36FD8C994F1B98C1E2C2B91A200E'),(10202,'b','输出A,B,Exception ','03EE36FD8C994F1B98C1E2C2B91A200E'),(10203,'c','编译失败 ','03EE36FD8C994F1B98C1E2C2B91A200E'),(10204,'d','在运行时抛出NullPointerException异常 ','03EE36FD8C994F1B98C1E2C2B91A200E'),(10205,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','098AE1032F9B41C8B36F87899682C1F8'),(10206,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','098AE1032F9B41C8B36F87899682C1F8'),(10207,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','098AE1032F9B41C8B36F87899682C1F8'),(10208,'d','new InputStreamReader(\"dat\") ; ','098AE1032F9B41C8B36F87899682C1F8'),(10209,'a','long 1 = 4990  ','38A6717475E547C8BBF523ADC792BF42'),(10210,'b','int i = 4L  ','38A6717475E547C8BBF523ADC792BF42'),(10211,'c','float f =1.1  ','38A6717475E547C8BBF523ADC792BF42'),(10212,'d','double d = 34.4','38A6717475E547C8BBF523ADC792BF42'),(10213,'a','名为dtThread的线程为守护线程 ','C760BFBD98A84463B16312773B7EBB25'),(10214,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','C760BFBD98A84463B16312773B7EBB25'),(10215,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','C760BFBD98A84463B16312773B7EBB25'),(10216,'d','main线程是守护线程 ','C760BFBD98A84463B16312773B7EBB25'),(10217,'a','编译错误 ','B2EE9F57C339413CA7BB0F366C7E8FCC'),(10218,'b','程序可以通过编译，运行后文件company.txt没有任何改变','B2EE9F57C339413CA7BB0F366C7E8FCC'),(10219,'c','程序可以通过编译，运行后文件company.txt的长度变为0','B2EE9F57C339413CA7BB0F366C7E8FCC'),(10220,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','B2EE9F57C339413CA7BB0F366C7E8FCC'),(10221,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','CF288B06B67349BBB52F112728DD2D6F'),(10222,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','CF288B06B67349BBB52F112728DD2D6F'),(10223,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','CF288B06B67349BBB52F112728DD2D6F'),(10224,'d','new InputStreamReader(\"1.dat\") ; ','CF288B06B67349BBB52F112728DD2D6F'),(10225,'a','编译错误 ','CCAE2E16A17E40ECBF7E95B61D65428C'),(10226,'b','抛出运行时异常 ','CCAE2E16A17E40ECBF7E95B61D65428C'),(10227,'c','输出：sleep ','CCAE2E16A17E40ECBF7E95B61D65428C'),(10228,'d','代码正常运行，但是无输出 ','CCAE2E16A17E40ECBF7E95B61D65428C'),(10229,'a','编译错误 ','0A44E4E052BE44469CE9467D42FC90E7'),(10230,'b','实现向文件record.dat追加写入字符a ','0A44E4E052BE44469CE9467D42FC90E7'),(10231,'c','实现向文件record.dat覆盖写入字符a ','0A44E4E052BE44469CE9467D42FC90E7'),(10232,'d','文件record.dat无任何内容 ','0A44E4E052BE44469CE9467D42FC90E7'),(10233,'a','InputStreamReader','B53041E99960452BB1F950A1BB5BC902'),(10234,'b','BufferedReader','B53041E99960452BB1F950A1BB5BC902'),(10235,'c','FileInputStream','B53041E99960452BB1F950A1BB5BC902'),(10236,'d','InputStream','B53041E99960452BB1F950A1BB5BC902'),(10237,'a','const   ','7A5A8C6864ED4A3DB465E2C3510A7BCF'),(10238,'b','NULL  ','7A5A8C6864ED4A3DB465E2C3510A7BCF'),(10239,'c','false   ','7A5A8C6864ED4A3DB465E2C3510A7BCF'),(10240,'d','this  ','7A5A8C6864ED4A3DB465E2C3510A7BCF'),(10241,'a','private synchronized Object o; ','0AC1F7196363456C8EBD6F081D629ADC'),(10242,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','0AC1F7196363456C8EBD6F081D629ADC'),(10243,'c','public synchronized void go() { /* code here */ } ','0AC1F7196363456C8EBD6F081D629ADC'),(10244,'d','private synchronized(this) void go() { /* code here */ } ','0AC1F7196363456C8EBD6F081D629ADC'),(10245,'a','s>>>=3   ','58944F9F7B22498883DA4ECB977B8FE5'),(10246,'b','s[3]= “X”  ','58944F9F7B22498883DA4ECB977B8FE5'),(10247,'c','int i = s.length()   ','58944F9F7B22498883DA4ECB977B8FE5'),(10248,'d','s = s + 10 ','58944F9F7B22498883DA4ECB977B8FE5'),(10249,'a','第3行抛出异常 ','7FADE388B8A248AB9B27C039B27E5369'),(10250,'b','第1行抛出异常 ','7FADE388B8A248AB9B27C039B27E5369'),(10251,'c','第5行抛出异常 ','7FADE388B8A248AB9B27C039B27E5369'),(10252,'d','第3行代码成功执行 ','7FADE388B8A248AB9B27C039B27E5369'),(10253,'a','输出Exception ','87BE6014D24C434AB344B6353C0A72D8'),(10254,'b','输出A,B,Exception ','87BE6014D24C434AB344B6353C0A72D8'),(10255,'c','编译失败 ','87BE6014D24C434AB344B6353C0A72D8'),(10256,'d','在运行时抛出NullPointerException异常 ','87BE6014D24C434AB344B6353C0A72D8'),(10257,'a','编译错误 ','4569A2E28CB042F6921F390684D02DDF'),(10258,'b','抛出运行时异常 ','4569A2E28CB042F6921F390684D02DDF'),(10259,'c','输出：sleep ','4569A2E28CB042F6921F390684D02DDF'),(10260,'d','代码正常运行，但是无输出 ','4569A2E28CB042F6921F390684D02DDF'),(10261,'a','一旦一个线程被创建，它就立即开始运行。  ','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(10262,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(10263,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(10264,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','3EDFEA7E99DF4E4AB11D3528AFE645F8'),(10265,'a','名为dtThread的线程为守护线程 ','9158166EF28D45EE9B79F277AA12AA5D'),(10266,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','9158166EF28D45EE9B79F277AA12AA5D'),(10267,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','9158166EF28D45EE9B79F277AA12AA5D'),(10268,'d','main线程是守护线程 ','9158166EF28D45EE9B79F277AA12AA5D'),(10269,'a','输出Exception ','929298B69B8B4F0C8EDFA385A059F797'),(10270,'b','输出A,B,Exception ','929298B69B8B4F0C8EDFA385A059F797'),(10271,'c','编译失败 ','929298B69B8B4F0C8EDFA385A059F797'),(10272,'d','在运行时抛出NullPointerException异常 ','929298B69B8B4F0C8EDFA385A059F797'),(10273,'a','private synchronized Object o; ','26CD2246CF504647AE7FDCB47B09D86F'),(10274,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','26CD2246CF504647AE7FDCB47B09D86F'),(10275,'c','public synchronized void go() { /* code here */ } ','26CD2246CF504647AE7FDCB47B09D86F'),(10276,'d','private synchronized(this) void go() { /* code here */ } ','26CD2246CF504647AE7FDCB47B09D86F'),(10277,'a','InputStreamReader','B5172B84F6E94789976E31234531B0DE'),(10278,'b','BufferedReader','B5172B84F6E94789976E31234531B0DE'),(10279,'c','FileInputStream','B5172B84F6E94789976E31234531B0DE'),(10280,'d','InputStream','B5172B84F6E94789976E31234531B0DE'),(10281,'a','名为dtThread的线程为守护线程 ','00B20E41CAAE46209AC000C66BEA42A1'),(10282,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','00B20E41CAAE46209AC000C66BEA42A1'),(10283,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','00B20E41CAAE46209AC000C66BEA42A1'),(10284,'d','main线程是守护线程 ','00B20E41CAAE46209AC000C66BEA42A1'),(10285,'a','5.0','A62D2A3B26744455AFA270A7B6427806'),(10286,'b','4.0','A62D2A3B26744455AFA270A7B6427806'),(10287,'c','6.0','A62D2A3B26744455AFA270A7B6427806'),(10288,'d','finished','A62D2A3B26744455AFA270A7B6427806'),(10289,'a','通过调用stop()方法而停止的线程。 ','93FE885389694756BD7570A6F6A5E9BF'),(10290,'b','通过调用sleep()方法而停止的线程。 ','93FE885389694756BD7570A6F6A5E9BF'),(10291,'c','通过调用wait()方法而停止的线程。 ','93FE885389694756BD7570A6F6A5E9BF'),(10292,'d','通过调用suspend()方法而停止的线程。 ','93FE885389694756BD7570A6F6A5E9BF'),(10293,'a','将private int m改为 protected int m  ','97C2272DF4C34A3C9A50532BF8E16605'),(10294,'b','将private int m改为 public int m    ','97C2272DF4C34A3C9A50532BF8E16605'),(10295,'c','将private int m改为 static int m     ','97C2272DF4C34A3C9A50532BF8E16605'),(10296,'d','将private int m改为int m ','97C2272DF4C34A3C9A50532BF8E16605'),(10297,'a','输出：test ','BC5C71FF35D24B859E8CEA53F879F535'),(10298,'b','输出：Exception ','BC5C71FF35D24B859E8CEA53F879F535'),(10299,'c','编译失败 ','BC5C71FF35D24B859E8CEA53F879F535'),(10300,'d','输出：NullPointerException ','BC5C71FF35D24B859E8CEA53F879F535'),(10301,'a','5.0','AAF33ECA153A45E3B551E2CFFF2930AE'),(10302,'b','4.0','AAF33ECA153A45E3B551E2CFFF2930AE'),(10303,'c','6.0','AAF33ECA153A45E3B551E2CFFF2930AE'),(10304,'d','finished','AAF33ECA153A45E3B551E2CFFF2930AE'),(10305,'a','栈是非线性结构        ','36C8655255744CB193374CA64806B296'),(10306,'b','栈是一种树状结构 ','36C8655255744CB193374CA64806B296'),(10307,'c','栈具有先进先出的特征  ','36C8655255744CB193374CA64806B296'),(10308,'d','栈具有后进先出的特征 ','36C8655255744CB193374CA64806B296'),(10309,'a','输出：4 ','44D45872D8E94A33B4B95A9AA44B1D41'),(10310,'b','在运行时抛出NullPointerException异常 ','44D45872D8E94A33B4B95A9AA44B1D41'),(10311,'c','在运行时抛出NumberFormatException异常 ','44D45872D8E94A33B4B95A9AA44B1D41'),(10312,'d','在运行时抛出IllegalStateException异常 ','44D45872D8E94A33B4B95A9AA44B1D41'),(10313,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','08CBCC0569A04EC0959683954D431927'),(10314,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','08CBCC0569A04EC0959683954D431927'),(10315,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','08CBCC0569A04EC0959683954D431927'),(10316,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','08CBCC0569A04EC0959683954D431927'),(10317,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','5FD277B28E8B49909275103539A1A0AB'),(10318,'b','垃圾收集将检查并释放不在使用的内存  ','5FD277B28E8B49909275103539A1A0AB'),(10319,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','5FD277B28E8B49909275103539A1A0AB'),(10320,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','5FD277B28E8B49909275103539A1A0AB'),(10321,'a','栈是非线性结构        ','F84B496BD94844F48AC3708A2926E453'),(10322,'b','栈是一种树状结构 ','F84B496BD94844F48AC3708A2926E453'),(10323,'c','栈具有先进先出的特征  ','F84B496BD94844F48AC3708A2926E453'),(10324,'d','栈具有后进先出的特征 ','F84B496BD94844F48AC3708A2926E453'),(10325,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(10326,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(10327,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(10328,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','9E7BC8FBC4A04C5BA8D2F5DC704C16F7'),(10329,'a','编译错误 ','B57F7314D44C4F8AA9FF93EE210D5C46'),(10330,'b','程序可以通过编译，运行后文件company.txt没有任何改变','B57F7314D44C4F8AA9FF93EE210D5C46'),(10331,'c','程序可以通过编译，运行后文件company.txt的长度变为0','B57F7314D44C4F8AA9FF93EE210D5C46'),(10332,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','B57F7314D44C4F8AA9FF93EE210D5C46'),(10333,'a','编译错误 ','7513B1E11DD44F9F8B525E8AA77AE79C'),(10334,'b','实现向文件record.dat追加写入字符a ','7513B1E11DD44F9F8B525E8AA77AE79C'),(10335,'c','实现向文件record.dat覆盖写入字符a ','7513B1E11DD44F9F8B525E8AA77AE79C'),(10336,'d','文件record.dat无任何内容 ','7513B1E11DD44F9F8B525E8AA77AE79C'),(10337,'a','const   ','46632158F0B34724A8859A8B8DC296A3'),(10338,'b','NULL  ','46632158F0B34724A8859A8B8DC296A3'),(10339,'c','false   ','46632158F0B34724A8859A8B8DC296A3'),(10340,'d','this  ','46632158F0B34724A8859A8B8DC296A3'),(10341,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','408DBCE66C364E149EDF791CFEDC6EBA'),(10342,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','408DBCE66C364E149EDF791CFEDC6EBA'),(10343,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','408DBCE66C364E149EDF791CFEDC6EBA'),(10344,'d','new InputStreamReader(\"dat\") ; ','408DBCE66C364E149EDF791CFEDC6EBA'),(10345,'a','const   ','52D7EE46041C46D19C59B62B73DB7980'),(10346,'b','NULL  ','52D7EE46041C46D19C59B62B73DB7980'),(10347,'c','false   ','52D7EE46041C46D19C59B62B73DB7980'),(10348,'d','this  ','52D7EE46041C46D19C59B62B73DB7980'),(10349,'a','第3行抛出异常 ','CB23AB9201134BC08EC9307FED325F71'),(10350,'b','第1行抛出异常 ','CB23AB9201134BC08EC9307FED325F71'),(10351,'c','第5行抛出异常 ','CB23AB9201134BC08EC9307FED325F71'),(10352,'d','第3行代码成功执行 ','CB23AB9201134BC08EC9307FED325F71'),(10353,'a','将private int m改为 protected int m  ','636BFD8C449E4E9E8F27747F99AA4DAD'),(10354,'b','将private int m改为 public int m    ','636BFD8C449E4E9E8F27747F99AA4DAD'),(10355,'c','将private int m改为 static int m     ','636BFD8C449E4E9E8F27747F99AA4DAD'),(10356,'d','将private int m改为int m ','636BFD8C449E4E9E8F27747F99AA4DAD'),(10357,'a','m.length()    ','73B37FC1868A4568B90D1EB5925B35CD'),(10358,'b','m.length   ','73B37FC1868A4568B90D1EB5925B35CD'),(10359,'c','m.length()+1   ','73B37FC1868A4568B90D1EB5925B35CD'),(10360,'d','m.length-1','73B37FC1868A4568B90D1EB5925B35CD'),(10361,'a','输出：4 ','F833D534658142C385B5B2B1A864F786'),(10362,'b','在运行时抛出NullPointerException异常 ','F833D534658142C385B5B2B1A864F786'),(10363,'c','在运行时抛出NumberFormatException异常 ','F833D534658142C385B5B2B1A864F786'),(10364,'d','在运行时抛出IllegalStateException异常 ','F833D534658142C385B5B2B1A864F786'),(10365,'a','Output is null.             ','290BECED2ED345B3AE8EC3181A70F21F'),(10366,'b','Output is 0 ','290BECED2ED345B3AE8EC3181A70F21F'),(10367,'c','编译时报错 ','290BECED2ED345B3AE8EC3181A70F21F'),(10368,'d','运行时报错','290BECED2ED345B3AE8EC3181A70F21F'),(10369,'a','sleep方法 ','4275214FA1354D5DA98B73EB37C83842'),(10370,'b','IO等待 ','4275214FA1354D5DA98B73EB37C83842'),(10371,'c','yield方法 ','4275214FA1354D5DA98B73EB37C83842'),(10372,'d','wait方法 ','4275214FA1354D5DA98B73EB37C83842'),(10373,'a','Output is null.             ','32D7F3306B7B467F8868F18CCCA4A54B'),(10374,'b','Output is 0 ','32D7F3306B7B467F8868F18CCCA4A54B'),(10375,'c','编译时报错 ','32D7F3306B7B467F8868F18CCCA4A54B'),(10376,'d','运行时报错','32D7F3306B7B467F8868F18CCCA4A54B'),(10377,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(10378,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(10379,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(10380,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','BADFC2C98CC84B6DA373D9BA7B7C29A5'),(10381,'a','s>>>=3   ','537E32E7CC184D73AF8F5B86D07A55F3'),(10382,'b','s[3]= “X”  ','537E32E7CC184D73AF8F5B86D07A55F3'),(10383,'c','int i = s.length()   ','537E32E7CC184D73AF8F5B86D07A55F3'),(10384,'d','s = s + 10 ','537E32E7CC184D73AF8F5B86D07A55F3'),(10385,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','1150C09E5E1844B0A65739C47FC17A2D'),(10386,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','1150C09E5E1844B0A65739C47FC17A2D'),(10387,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','1150C09E5E1844B0A65739C47FC17A2D'),(10388,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','1150C09E5E1844B0A65739C47FC17A2D'),(10389,'a','start()    ','C7D1067D038B4285A24418301CAECC40'),(10390,'b','init()    ','C7D1067D038B4285A24418301CAECC40'),(10391,'c','run()    ','C7D1067D038B4285A24418301CAECC40'),(10392,'d','main()  ','C7D1067D038B4285A24418301CAECC40'),(10393,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0F81984D117B43FBB0725F97D31EE4D2'),(10394,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0F81984D117B43FBB0725F97D31EE4D2'),(10395,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0F81984D117B43FBB0725F97D31EE4D2'),(10396,'d','new InputStreamReader(\"1.dat\") ; ','0F81984D117B43FBB0725F97D31EE4D2'),(10397,'a','5.0','667DC2D840BF4AA694944A4BA25DBC11'),(10398,'b','4.0','667DC2D840BF4AA694944A4BA25DBC11'),(10399,'c','6.0','667DC2D840BF4AA694944A4BA25DBC11'),(10400,'d','finished','667DC2D840BF4AA694944A4BA25DBC11'),(10401,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','0617883BDD94434A96D05C9C1F0ED825'),(10402,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','0617883BDD94434A96D05C9C1F0ED825'),(10403,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','0617883BDD94434A96D05C9C1F0ED825'),(10404,'d','new InputStreamReader(\"dat\") ; ','0617883BDD94434A96D05C9C1F0ED825'),(10405,'a','编译错误 ','3FFDBE2D2B134E6D8B048BA7089CD7AE'),(10406,'b','实现向文件record.dat追加写入字符a ','3FFDBE2D2B134E6D8B048BA7089CD7AE'),(10407,'c','实现向文件record.dat覆盖写入字符a ','3FFDBE2D2B134E6D8B048BA7089CD7AE'),(10408,'d','文件record.dat无任何内容 ','3FFDBE2D2B134E6D8B048BA7089CD7AE'),(10409,'a','public void method( int m){...}     ','F344A682515D442FA44171A17A64A8E7'),(10410,'b','public int method(){...} ','F344A682515D442FA44171A17A64A8E7'),(10411,'c','public void method2(){...}    ','F344A682515D442FA44171A17A64A8E7'),(10412,'d','public int method(int m，float f ){...} ','F344A682515D442FA44171A17A64A8E7'),(10413,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','DEE31C203CD54ADE803E64F26A48B643'),(10414,'b','垃圾收集将检查并释放不在使用的内存  ','DEE31C203CD54ADE803E64F26A48B643'),(10415,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','DEE31C203CD54ADE803E64F26A48B643'),(10416,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','DEE31C203CD54ADE803E64F26A48B643'),(10417,'a','一旦一个线程被创建，它就立即开始运行。  ','E393872B749649AC86FF340964D13EF7'),(10418,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','E393872B749649AC86FF340964D13EF7'),(10419,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','E393872B749649AC86FF340964D13EF7'),(10420,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','E393872B749649AC86FF340964D13EF7'),(10421,'a','编译错误 ','8DE51CFFE294435CB2D7F7B09047D3FC'),(10422,'b','抛出运行时异常 ','8DE51CFFE294435CB2D7F7B09047D3FC'),(10423,'c','输出：sleep ','8DE51CFFE294435CB2D7F7B09047D3FC'),(10424,'d','代码正常运行，但是无输出 ','8DE51CFFE294435CB2D7F7B09047D3FC'),(10425,'a','m.length()    ','87B73FCF72D9402697D6C1CEC19756F5'),(10426,'b','m.length   ','87B73FCF72D9402697D6C1CEC19756F5'),(10427,'c','m.length()+1   ','87B73FCF72D9402697D6C1CEC19756F5'),(10428,'d','m.length-1','87B73FCF72D9402697D6C1CEC19756F5'),(10429,'a','Output is null.             ','7E06F8116A2641B59136F71EFDDE30B3'),(10430,'b','Output is 0 ','7E06F8116A2641B59136F71EFDDE30B3'),(10431,'c','编译时报错 ','7E06F8116A2641B59136F71EFDDE30B3'),(10432,'d','运行时报错','7E06F8116A2641B59136F71EFDDE30B3'),(10433,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','7938256702C74B5AA4D996FB909E0AF5'),(10434,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','7938256702C74B5AA4D996FB909E0AF5'),(10435,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','7938256702C74B5AA4D996FB909E0AF5'),(10436,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','7938256702C74B5AA4D996FB909E0AF5'),(10437,'a','输出：4 ','4F9CB47A267A41A8BE8AC90A7AA920A4'),(10438,'b','在运行时抛出NullPointerException异常 ','4F9CB47A267A41A8BE8AC90A7AA920A4'),(10439,'c','在运行时抛出NumberFormatException异常 ','4F9CB47A267A41A8BE8AC90A7AA920A4'),(10440,'d','在运行时抛出IllegalStateException异常 ','4F9CB47A267A41A8BE8AC90A7AA920A4'),(10441,'a','InputStreamReader','A9370CB8E0C64CE6B1F95C7879089C19'),(10442,'b','BufferedReader','A9370CB8E0C64CE6B1F95C7879089C19'),(10443,'c','FileInputStream','A9370CB8E0C64CE6B1F95C7879089C19'),(10444,'d','InputStream','A9370CB8E0C64CE6B1F95C7879089C19'),(10445,'a','名为dtThread的线程为守护线程 ','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(10446,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(10447,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(10448,'d','main线程是守护线程 ','86C9EEC3DCBA4A15A7982F0B6629FEB8'),(10449,'a','Output is null.             ','7EE7AC0A832D4417A2AFE9F7A5BBF146'),(10450,'b','Output is 0 ','7EE7AC0A832D4417A2AFE9F7A5BBF146'),(10451,'c','编译时报错 ','7EE7AC0A832D4417A2AFE9F7A5BBF146'),(10452,'d','运行时报错','7EE7AC0A832D4417A2AFE9F7A5BBF146'),(10453,'a','private synchronized Object o; ','7374CDB393694B91956EF062D4679DD8'),(10454,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','7374CDB393694B91956EF062D4679DD8'),(10455,'c','public synchronized void go() { /* code here */ } ','7374CDB393694B91956EF062D4679DD8'),(10456,'d','private synchronized(this) void go() { /* code here */ } ','7374CDB393694B91956EF062D4679DD8'),(10457,'a','编译错误 ','58D2AED4CD0D4655B1D8D0E3FC42E58F'),(10458,'b','实现向文件record.dat追加写入字符a ','58D2AED4CD0D4655B1D8D0E3FC42E58F'),(10459,'c','实现向文件record.dat覆盖写入字符a ','58D2AED4CD0D4655B1D8D0E3FC42E58F'),(10460,'d','文件record.dat无任何内容 ','58D2AED4CD0D4655B1D8D0E3FC42E58F'),(10461,'a','编译错误 ','C8493696481F4FE59F25F61F2C54E35E'),(10462,'b','实现向文件record.dat追加写入字符a ','C8493696481F4FE59F25F61F2C54E35E'),(10463,'c','实现向文件record.dat覆盖写入字符a ','C8493696481F4FE59F25F61F2C54E35E'),(10464,'d','文件record.dat无任何内容 ','C8493696481F4FE59F25F61F2C54E35E'),(10465,'a','一旦一个线程被创建，它就立即开始运行。  ','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(10466,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(10467,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(10468,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','D5E7DB679ED2470A81F4EFD7C8D4BA1B'),(10469,'a','第3行抛出异常 ','3DDC6332E2584337ABDF2D4F8C24FDCC'),(10470,'b','第1行抛出异常 ','3DDC6332E2584337ABDF2D4F8C24FDCC'),(10471,'c','第5行抛出异常 ','3DDC6332E2584337ABDF2D4F8C24FDCC'),(10472,'d','第3行代码成功执行 ','3DDC6332E2584337ABDF2D4F8C24FDCC'),(10473,'a','输出Exception ','351D03AAD9D842B0963D8C64C331D5B8'),(10474,'b','输出A,B,Exception ','351D03AAD9D842B0963D8C64C331D5B8'),(10475,'c','编译失败 ','351D03AAD9D842B0963D8C64C331D5B8'),(10476,'d','在运行时抛出NullPointerException异常 ','351D03AAD9D842B0963D8C64C331D5B8'),(10477,'a','输出：test ','0781FF85816C4FD2A3D8A553D859CF1A'),(10478,'b','输出：Exception ','0781FF85816C4FD2A3D8A553D859CF1A'),(10479,'c','编译失败 ','0781FF85816C4FD2A3D8A553D859CF1A'),(10480,'d','输出：NullPointerException ','0781FF85816C4FD2A3D8A553D859CF1A'),(10481,'a','第3行抛出异常 ','4A58642B088D4226A6BEC80B701A1EE4'),(10482,'b','第1行抛出异常 ','4A58642B088D4226A6BEC80B701A1EE4'),(10483,'c','第5行抛出异常 ','4A58642B088D4226A6BEC80B701A1EE4'),(10484,'d','第3行代码成功执行 ','4A58642B088D4226A6BEC80B701A1EE4'),(10485,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','0CF374D4739048E08899A5979E775F65'),(10486,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','0CF374D4739048E08899A5979E775F65'),(10487,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','0CF374D4739048E08899A5979E775F65'),(10488,'d','new InputStreamReader(\"1.dat\") ; ','0CF374D4739048E08899A5979E775F65'),(10489,'a','将private int m改为 protected int m  ','A00CB5BB32EF48769CFEAA5E0187A4E8'),(10490,'b','将private int m改为 public int m    ','A00CB5BB32EF48769CFEAA5E0187A4E8'),(10491,'c','将private int m改为 static int m     ','A00CB5BB32EF48769CFEAA5E0187A4E8'),(10492,'d','将private int m改为int m ','A00CB5BB32EF48769CFEAA5E0187A4E8'),(10493,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','C2567BDBA2D64DED8114094A4DAD1F75'),(10494,'b','垃圾收集将检查并释放不在使用的内存  ','C2567BDBA2D64DED8114094A4DAD1F75'),(10495,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','C2567BDBA2D64DED8114094A4DAD1F75'),(10496,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','C2567BDBA2D64DED8114094A4DAD1F75'),(10497,'a','栈是非线性结构        ','2965CFC608EC42E982DE6E5A63957E2C'),(10498,'b','栈是一种树状结构 ','2965CFC608EC42E982DE6E5A63957E2C'),(10499,'c','栈具有先进先出的特征  ','2965CFC608EC42E982DE6E5A63957E2C'),(10500,'d','栈具有后进先出的特征 ','2965CFC608EC42E982DE6E5A63957E2C'),(10501,'a','将private int m改为 protected int m  ','025796F30C8C4B279E45DD6EE100CE17'),(10502,'b','将private int m改为 public int m    ','025796F30C8C4B279E45DD6EE100CE17'),(10503,'c','将private int m改为 static int m     ','025796F30C8C4B279E45DD6EE100CE17'),(10504,'d','将private int m改为int m ','025796F30C8C4B279E45DD6EE100CE17'),(10505,'a','编译错误 ','A69EF867A61B492BAC5158D988B4AED7'),(10506,'b','实现向文件record.dat追加写入字符a ','A69EF867A61B492BAC5158D988B4AED7'),(10507,'c','实现向文件record.dat覆盖写入字符a ','A69EF867A61B492BAC5158D988B4AED7'),(10508,'d','文件record.dat无任何内容 ','A69EF867A61B492BAC5158D988B4AED7'),(10509,'a','编译错误 ','67C92A429E944C8DBFF46F6F3CD510D3'),(10510,'b','实现向文件record.dat追加写入字符a ','67C92A429E944C8DBFF46F6F3CD510D3'),(10511,'c','实现向文件record.dat覆盖写入字符a ','67C92A429E944C8DBFF46F6F3CD510D3'),(10512,'d','文件record.dat无任何内容 ','67C92A429E944C8DBFF46F6F3CD510D3'),(10513,'a','const   ','859C0B1FE3CD4C58B808649587824A2E'),(10514,'b','NULL  ','859C0B1FE3CD4C58B808649587824A2E'),(10515,'c','false   ','859C0B1FE3CD4C58B808649587824A2E'),(10516,'d','this  ','859C0B1FE3CD4C58B808649587824A2E'),(10517,'a','m.length()    ','5DF28B993CA342AA901157CD56205730'),(10518,'b','m.length   ','5DF28B993CA342AA901157CD56205730'),(10519,'c','m.length()+1   ','5DF28B993CA342AA901157CD56205730'),(10520,'d','m.length-1','5DF28B993CA342AA901157CD56205730'),(10521,'a','public void method( int m){...}     ','C526F3920B464E8FB0E8E9C54E4FD96B'),(10522,'b','public int method(){...} ','C526F3920B464E8FB0E8E9C54E4FD96B'),(10523,'c','public void method2(){...}    ','C526F3920B464E8FB0E8E9C54E4FD96B'),(10524,'d','public int method(int m，float f ){...} ','C526F3920B464E8FB0E8E9C54E4FD96B'),(10525,'a','private synchronized Object o; ','0EFB5936274C4628A2A95D30E44BDB5E'),(10526,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','0EFB5936274C4628A2A95D30E44BDB5E'),(10527,'c','public synchronized void go() { /* code here */ } ','0EFB5936274C4628A2A95D30E44BDB5E'),(10528,'d','private synchronized(this) void go() { /* code here */ } ','0EFB5936274C4628A2A95D30E44BDB5E'),(10529,'a','s>>>=3   ','7B21CE3795E94910BB106279D4A955E7'),(10530,'b','s[3]= “X”  ','7B21CE3795E94910BB106279D4A955E7'),(10531,'c','int i = s.length()   ','7B21CE3795E94910BB106279D4A955E7'),(10532,'d','s = s + 10 ','7B21CE3795E94910BB106279D4A955E7'),(10533,'a','通过调用stop()方法而停止的线程。 ','5022616CA877457D8A141B4158D8F5E4'),(10534,'b','通过调用sleep()方法而停止的线程。 ','5022616CA877457D8A141B4158D8F5E4'),(10535,'c','通过调用wait()方法而停止的线程。 ','5022616CA877457D8A141B4158D8F5E4'),(10536,'d','通过调用suspend()方法而停止的线程。 ','5022616CA877457D8A141B4158D8F5E4'),(10537,'a','通过调用stop()方法而停止的线程。 ','9D05EED1248B46B3823F23435539D348'),(10538,'b','通过调用sleep()方法而停止的线程。 ','9D05EED1248B46B3823F23435539D348'),(10539,'c','通过调用wait()方法而停止的线程。 ','9D05EED1248B46B3823F23435539D348'),(10540,'d','通过调用suspend()方法而停止的线程。 ','9D05EED1248B46B3823F23435539D348'),(10541,'a','InputStreamReader','F77A0C85A4844CF195AA85FE53575F34'),(10542,'b','BufferedReader','F77A0C85A4844CF195AA85FE53575F34'),(10543,'c','FileInputStream','F77A0C85A4844CF195AA85FE53575F34'),(10544,'d','InputStream','F77A0C85A4844CF195AA85FE53575F34'),(10545,'a','public void method( int m){...}     ','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(10546,'b','public int method(){...} ','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(10547,'c','public void method2(){...}    ','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(10548,'d','public int method(int m，float f ){...} ','F6B0DA0CA5F94AFBA1AFDC483F4AF0E6'),(10549,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','897C87D84E924EA2A5F49FD1E5185925'),(10550,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','897C87D84E924EA2A5F49FD1E5185925'),(10551,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','897C87D84E924EA2A5F49FD1E5185925'),(10552,'d','new InputStreamReader(\"dat\") ; ','897C87D84E924EA2A5F49FD1E5185925'),(10553,'a','long 1 = 4990  ','4BEEADB7CECA47A6AE0E6711F8189D0B'),(10554,'b','int i = 4L  ','4BEEADB7CECA47A6AE0E6711F8189D0B'),(10555,'c','float f =1.1  ','4BEEADB7CECA47A6AE0E6711F8189D0B'),(10556,'d','double d = 34.4','4BEEADB7CECA47A6AE0E6711F8189D0B'),(10557,'a','编译错误 ','D12D66B3B6144FC08E81320BF865EE4F'),(10558,'b','实现向文件record.dat追加写入字符a ','D12D66B3B6144FC08E81320BF865EE4F'),(10559,'c','实现向文件record.dat覆盖写入字符a ','D12D66B3B6144FC08E81320BF865EE4F'),(10560,'d','文件record.dat无任何内容 ','D12D66B3B6144FC08E81320BF865EE4F'),(10561,'a','一旦一个线程被创建，它就立即开始运行。  ','A3E0B6F49E144746994FFCDDC06E9839'),(10562,'b','使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。  ','A3E0B6F49E144746994FFCDDC06E9839'),(10563,'c','当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。 ','A3E0B6F49E144746994FFCDDC06E9839'),(10564,'d','一个线程可能因为不同的原因停止并进入可运行状态。 ','A3E0B6F49E144746994FFCDDC06E9839'),(10565,'a','输出Exception ','F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(10566,'b','输出A,B,Exception ','F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(10567,'c','编译失败 ','F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(10568,'d','在运行时抛出NullPointerException异常 ','F6CCA70DEE64441AB3ECFE2D5A8E9DE4'),(10569,'a','编译错误 ','0E7146AEC5AC4B45BE242168E7450D4F'),(10570,'b','抛出运行时异常 ','0E7146AEC5AC4B45BE242168E7450D4F'),(10571,'c','输出：sleep ','0E7146AEC5AC4B45BE242168E7450D4F'),(10572,'d','代码正常运行，但是无输出 ','0E7146AEC5AC4B45BE242168E7450D4F'),(10573,'a','5.0','DD414FCB79974749AF717E98D3D4C7AA'),(10574,'b','4.0','DD414FCB79974749AF717E98D3D4C7AA'),(10575,'c','6.0','DD414FCB79974749AF717E98D3D4C7AA'),(10576,'d','finished','DD414FCB79974749AF717E98D3D4C7AA'),(10577,'a','编译错误 ','D3D17756BF3A47818C9836C3010F75C1'),(10578,'b','程序可以通过编译，运行后文件company.txt没有任何改变','D3D17756BF3A47818C9836C3010F75C1'),(10579,'c','程序可以通过编译，运行后文件company.txt的长度变为0','D3D17756BF3A47818C9836C3010F75C1'),(10580,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','D3D17756BF3A47818C9836C3010F75C1'),(10581,'a','sleep方法 ','0EBD06CAB2D746EBAFB51CBFDEDF5074'),(10582,'b','IO等待 ','0EBD06CAB2D746EBAFB51CBFDEDF5074'),(10583,'c','yield方法 ','0EBD06CAB2D746EBAFB51CBFDEDF5074'),(10584,'d','wait方法 ','0EBD06CAB2D746EBAFB51CBFDEDF5074'),(10585,'a','第3行抛出异常 ','1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(10586,'b','第1行抛出异常 ','1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(10587,'c','第5行抛出异常 ','1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(10588,'d','第3行代码成功执行 ','1DF1C82178D24FEAB3C4EE8DA9BAFB9F'),(10589,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(10590,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(10591,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(10592,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','082FB4F1CE8E4E3091A1BDDDFA7CA5C6'),(10593,'a','输出：test ','59E7C5A418B04944BB933F2B05CF6E74'),(10594,'b','输出：Exception ','59E7C5A418B04944BB933F2B05CF6E74'),(10595,'c','编译失败 ','59E7C5A418B04944BB933F2B05CF6E74'),(10596,'d','输出：NullPointerException ','59E7C5A418B04944BB933F2B05CF6E74'),(10597,'a','编译错误 ','49D406AA1C964A63A7DC9015EC0FD510'),(10598,'b','程序可以通过编译，运行后文件company.txt没有任何改变','49D406AA1C964A63A7DC9015EC0FD510'),(10599,'c','程序可以通过编译，运行后文件company.txt的长度变为0','49D406AA1C964A63A7DC9015EC0FD510'),(10600,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','49D406AA1C964A63A7DC9015EC0FD510'),(10601,'a','名为dtThread的线程为守护线程 ','D7903ED0A7834FC9828EAB5E6C6B4D53'),(10602,'b','运行上述代码，main  线程一退出，则虚拟机退出 ','D7903ED0A7834FC9828EAB5E6C6B4D53'),(10603,'c','运行上述代码，程序会一直跑下去，因为main线程结束了，但dt线程是一个无限循环，还没有结束，虚拟机不能退出 ','D7903ED0A7834FC9828EAB5E6C6B4D53'),(10604,'d','main线程是守护线程 ','D7903ED0A7834FC9828EAB5E6C6B4D53'),(10605,'a','sleep方法 ','32FFCA29A8D544D8B7448B6D06C36F8B'),(10606,'b','IO等待 ','32FFCA29A8D544D8B7448B6D06C36F8B'),(10607,'c','yield方法 ','32FFCA29A8D544D8B7448B6D06C36F8B'),(10608,'d','wait方法 ','32FFCA29A8D544D8B7448B6D06C36F8B'),(10609,'a','start()    ','D70E631603694F6CA84BC4D9B54AE60B'),(10610,'b','init()    ','D70E631603694F6CA84BC4D9B54AE60B'),(10611,'c','run()    ','D70E631603694F6CA84BC4D9B54AE60B'),(10612,'d','main()  ','D70E631603694F6CA84BC4D9B54AE60B'),(10613,'a','start()    ','64E9CA75707D4F579CF3199AF14DAFE0'),(10614,'b','init()    ','64E9CA75707D4F579CF3199AF14DAFE0'),(10615,'c','run()    ','64E9CA75707D4F579CF3199AF14DAFE0'),(10616,'d','main()  ','64E9CA75707D4F579CF3199AF14DAFE0'),(10617,'a','new Thread() {\npublic void start() { doStuff(); }\n} .run(); \n','CCF667BBB1FC4235BF83376980992B67'),(10618,'b','new Thread() {\npublic void run() { doStuff(); }\n} .start(); \n','CCF667BBB1FC4235BF83376980992B67'),(10619,'c','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n} ).run(); \n','CCF667BBB1FC4235BF83376980992B67'),(10620,'d','new Thread(new Runnable() {\npublic void run() { doStuff(); }\n}).start(); \n','CCF667BBB1FC4235BF83376980992B67'),(10621,'a','m.length()    ','A88341A5789A4D6EA2061F939BC41A0A'),(10622,'b','m.length   ','A88341A5789A4D6EA2061F939BC41A0A'),(10623,'c','m.length()+1   ','A88341A5789A4D6EA2061F939BC41A0A'),(10624,'d','m.length-1','A88341A5789A4D6EA2061F939BC41A0A'),(10625,'a','编译错误 ','C4DAACEFDA044888A90F74EA0CDEB0A4'),(10626,'b','程序可以通过编译，运行后文件company.txt没有任何改变','C4DAACEFDA044888A90F74EA0CDEB0A4'),(10627,'c','程序可以通过编译，运行后文件company.txt的长度变为0','C4DAACEFDA044888A90F74EA0CDEB0A4'),(10628,'d','程序可以通过编译，运行后company.txt文件末尾增加了字符串“tarena”','C4DAACEFDA044888A90F74EA0CDEB0A4'),(10629,'a','Output is null.             ','D7484358783848728F4D6F4F7BE71229'),(10630,'b','Output is 0 ','D7484358783848728F4D6F4F7BE71229'),(10631,'c','编译时报错 ','D7484358783848728F4D6F4F7BE71229'),(10632,'d','运行时报错','D7484358783848728F4D6F4F7BE71229'),(10633,'a','输出Exception ','DC214D6A28774B4CA7937F45B0F14DD9'),(10634,'b','输出A,B,Exception ','DC214D6A28774B4CA7937F45B0F14DD9'),(10635,'c','编译失败 ','DC214D6A28774B4CA7937F45B0F14DD9'),(10636,'d','在运行时抛出NullPointerException异常 ','DC214D6A28774B4CA7937F45B0F14DD9'),(10637,'a','输出：4 ','C87A28C672E54DAA8563BE61465B7A10'),(10638,'b','在运行时抛出NullPointerException异常 ','C87A28C672E54DAA8563BE61465B7A10'),(10639,'c','在运行时抛出NumberFormatException异常 ','C87A28C672E54DAA8563BE61465B7A10'),(10640,'d','在运行时抛出IllegalStateException异常 ','C87A28C672E54DAA8563BE61465B7A10'),(10641,'a','栈是非线性结构        ','F1DC1F9FFF994C11822F462CDA652971'),(10642,'b','栈是一种树状结构 ','F1DC1F9FFF994C11822F462CDA652971'),(10643,'c','栈具有先进先出的特征  ','F1DC1F9FFF994C11822F462CDA652971'),(10644,'d','栈具有后进先出的特征 ','F1DC1F9FFF994C11822F462CDA652971'),(10645,'a','编译错误 ','AFB6EE1D837A4449824B71102CDA2567'),(10646,'b','抛出运行时异常 ','AFB6EE1D837A4449824B71102CDA2567'),(10647,'c','输出：bar ','AFB6EE1D837A4449824B71102CDA2567'),(10648,'d','代码正常运行，但是无输出 ','AFB6EE1D837A4449824B71102CDA2567'),(10649,'a','编译错误 ','E979082DB56D4ADDA9B913424DEF7645'),(10650,'b','抛出运行时异常 ','E979082DB56D4ADDA9B913424DEF7645'),(10651,'c','输出：sleep ','E979082DB56D4ADDA9B913424DEF7645'),(10652,'d','代码正常运行，但是无输出 ','E979082DB56D4ADDA9B913424DEF7645'),(10653,'a','将private int m改为 protected int m  ','70E10A105A884D80ACD0BB0CC791B0F5'),(10654,'b','将private int m改为 public int m    ','70E10A105A884D80ACD0BB0CC791B0F5'),(10655,'c','将private int m改为 static int m     ','70E10A105A884D80ACD0BB0CC791B0F5'),(10656,'d','将private int m改为int m ','70E10A105A884D80ACD0BB0CC791B0F5'),(10657,'a','long 1 = 4990  ','DC8491743C70479797D720E87CA9D53B'),(10658,'b','int i = 4L  ','DC8491743C70479797D720E87CA9D53B'),(10659,'c','float f =1.1  ','DC8491743C70479797D720E87CA9D53B'),(10660,'d','double d = 34.4','DC8491743C70479797D720E87CA9D53B'),(10661,'a','long 1 = 4990  ','E99E0619078241348D2CF86A18EDF1E8'),(10662,'b','int i = 4L  ','E99E0619078241348D2CF86A18EDF1E8'),(10663,'c','float f =1.1  ','E99E0619078241348D2CF86A18EDF1E8'),(10664,'d','double d = 34.4','E99E0619078241348D2CF86A18EDF1E8'),(10665,'a','new InputStreamReader(new FileInputStream(\"1.dat\")) ; ','89E92C92C9CC4D0AA3BD1B560B326729'),(10666,'b','new InputStreamReader(new FileReader(\"1.dat\")) ; ','89E92C92C9CC4D0AA3BD1B560B326729'),(10667,'c','new InputStreamReader(new BufferedReader(\"1.dat\")) ;','89E92C92C9CC4D0AA3BD1B560B326729'),(10668,'d','new InputStreamReader(\"1.dat\") ; ','89E92C92C9CC4D0AA3BD1B560B326729'),(10669,'a','private synchronized Object o; ','DF32D57DCDE548729DAA68628CD2AE2F'),(10670,'b','void go() {\nsynchronized() { /* code here */ }\n} \n','DF32D57DCDE548729DAA68628CD2AE2F'),(10671,'c','public synchronized void go() { /* code here */ } ','DF32D57DCDE548729DAA68628CD2AE2F'),(10672,'d','private synchronized(this) void go() { /* code here */ } ','DF32D57DCDE548729DAA68628CD2AE2F'),(10673,'a','const   ','FE8614017D9F4D3FA72B7B458504ED67'),(10674,'b','NULL  ','FE8614017D9F4D3FA72B7B458504ED67'),(10675,'c','false   ','FE8614017D9F4D3FA72B7B458504ED67'),(10676,'d','this  ','FE8614017D9F4D3FA72B7B458504ED67'),(10677,'a','sleep方法 ','DEEECCA653C8461996B16D55A1B4A055'),(10678,'b','IO等待 ','DEEECCA653C8461996B16D55A1B4A055'),(10679,'c','yield方法 ','DEEECCA653C8461996B16D55A1B4A055'),(10680,'d','wait方法 ','DEEECCA653C8461996B16D55A1B4A055'),(10681,'a','s>>>=3   ','A684A92DEA0E4203A233F605ABB213AB'),(10682,'b','s[3]= “X”  ','A684A92DEA0E4203A233F605ABB213AB'),(10683,'c','int i = s.length()   ','A684A92DEA0E4203A233F605ABB213AB'),(10684,'d','s = s + 10 ','A684A92DEA0E4203A233F605ABB213AB'),(10685,'a','编译错误 ','731058054035494DAB0E4A44D5C0CEA2'),(10686,'b','实现向文件record.dat追加写入字符a ','731058054035494DAB0E4A44D5C0CEA2'),(10687,'c','实现向文件record.dat覆盖写入字符a ','731058054035494DAB0E4A44D5C0CEA2'),(10688,'d','文件record.dat无任何内容 ','731058054035494DAB0E4A44D5C0CEA2'),(10689,'a','输出：4 ','0380EF54C2B346518CC4F8BE18BFF628'),(10690,'b','在运行时抛出NullPointerException异常 ','0380EF54C2B346518CC4F8BE18BFF628'),(10691,'c','在运行时抛出NumberFormatException异常 ','0380EF54C2B346518CC4F8BE18BFF628'),(10692,'d','在运行时抛出IllegalStateException异常 ','0380EF54C2B346518CC4F8BE18BFF628'),(10693,'a','编译错误 ','91D49DF2C5BA43A98EAD3F8202697370'),(10694,'b','抛出运行时异常 ','91D49DF2C5BA43A98EAD3F8202697370'),(10695,'c','输出：bar ','91D49DF2C5BA43A98EAD3F8202697370'),(10696,'d','代码正常运行，但是无输出 ','91D49DF2C5BA43A98EAD3F8202697370'),(10697,'a','输出：test ','AE1EEAEA6A204F87B16DE80B0144C717'),(10698,'b','输出：Exception ','AE1EEAEA6A204F87B16DE80B0144C717'),(10699,'c','编译失败 ','AE1EEAEA6A204F87B16DE80B0144C717'),(10700,'d','输出：NullPointerException ','AE1EEAEA6A204F87B16DE80B0144C717'),(10701,'a','s>>>=3   ','E0CA769473A1448A86A006924DC34251'),(10702,'b','s[3]= “X”  ','E0CA769473A1448A86A006924DC34251'),(10703,'c','int i = s.length()   ','E0CA769473A1448A86A006924DC34251'),(10704,'d','s = s + 10 ','E0CA769473A1448A86A006924DC34251'),(10705,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','12BEC049BFA24377BCE5112391D98488'),(10706,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','12BEC049BFA24377BCE5112391D98488'),(10707,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','12BEC049BFA24377BCE5112391D98488'),(10708,'d','new InputStreamReader(\"dat\") ; ','12BEC049BFA24377BCE5112391D98488'),(10709,'a','编译错误 ','987B70BE81F04BA3AE766AF0135BC0DA'),(10710,'b','抛出运行时异常 ','987B70BE81F04BA3AE766AF0135BC0DA'),(10711,'c','输出：bar ','987B70BE81F04BA3AE766AF0135BC0DA'),(10712,'d','代码正常运行，但是无输出 ','987B70BE81F04BA3AE766AF0135BC0DA'),(10713,'a','5.0','1F8EE8AA42FF48E8A0BAA496AC54D513'),(10714,'b','4.0','1F8EE8AA42FF48E8A0BAA496AC54D513'),(10715,'c','6.0','1F8EE8AA42FF48E8A0BAA496AC54D513'),(10716,'d','finished','1F8EE8AA42FF48E8A0BAA496AC54D513'),(10717,'a','通过调用stop()方法而停止的线程。 ','5184B400846F48CD9B8E1AC993E7922F'),(10718,'b','通过调用sleep()方法而停止的线程。 ','5184B400846F48CD9B8E1AC993E7922F'),(10719,'c','通过调用wait()方法而停止的线程。 ','5184B400846F48CD9B8E1AC993E7922F'),(10720,'d','通过调用suspend()方法而停止的线程。 ','5184B400846F48CD9B8E1AC993E7922F'),(10721,'a','InputStreamReader','26936E991BFF41FCBADE80B60B9EEFE8'),(10722,'b','BufferedReader','26936E991BFF41FCBADE80B60B9EEFE8'),(10723,'c','FileInputStream','26936E991BFF41FCBADE80B60B9EEFE8'),(10724,'d','InputStream','26936E991BFF41FCBADE80B60B9EEFE8'),(10725,'a','栈是非线性结构        ','E2CE2B56ABAA491EBE1B03A88B81A060'),(10726,'b','栈是一种树状结构 ','E2CE2B56ABAA491EBE1B03A88B81A060'),(10727,'c','栈具有先进先出的特征  ','E2CE2B56ABAA491EBE1B03A88B81A060'),(10728,'d','栈具有后进先出的特征 ','E2CE2B56ABAA491EBE1B03A88B81A060'),(10729,'a','new InputStreamReader(new FileInputStream(\"dat\")) ; ','71DFF9365E7A4D77A40649D199BC80EF'),(10730,'b','new InputStreamReader(new FileReader(\"dat\")) ; ','71DFF9365E7A4D77A40649D199BC80EF'),(10731,'c','new InputStreamReader(new BufferedReader(\"dat\")) ; ','71DFF9365E7A4D77A40649D199BC80EF'),(10732,'d','new InputStreamReader(\"dat\") ; ','71DFF9365E7A4D77A40649D199BC80EF'),(10733,'a','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\n','739F3C040815411E8E4E0B3F001839BA'),(10734,'b','Thread t1=new Thread();\nThread t2=new Thread();\n','739F3C040815411E8E4E0B3F001839BA'),(10735,'c','ThreadDemo r1=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r1);\n','739F3C040815411E8E4E0B3F001839BA'),(10736,'d','ThreadDemo r1=new ThreadDemo();\nThreadDemo r2=new ThreadDemo();\nThread t1=new Thread(r1);\nThread t2=new Thread(r2);\n','739F3C040815411E8E4E0B3F001839BA'),(10737,'a','程序开发者必须自己创建一个线程进行内存释放的工作 ','33CB39951E3D43D6999C89E4FE18A38A'),(10738,'b','垃圾收集将检查并释放不在使用的内存  ','33CB39951E3D43D6999C89E4FE18A38A'),(10739,'c','垃圾收集允许程序开发者明确指定并立即释放该内存 ','33CB39951E3D43D6999C89E4FE18A38A'),(10740,'d','垃圾收集能够在期望的时间释放被java对象使用的内存 ','33CB39951E3D43D6999C89E4FE18A38A');

/*Table structure for table `examination_job` */

DROP TABLE IF EXISTS `examination_job`;

CREATE TABLE `examination_job` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `code` varchar(100) NOT NULL,
  `class_type` int(10) NOT NULL,
  `class_level` int(10) NOT NULL,
  `examination_type` int(10) NOT NULL,
  `start_time` datetime NOT NULL,
  `end_time` datetime NOT NULL,
  `is_delete` int(1) NOT NULL DEFAULT '0',
  `examination_file` varchar(100) DEFAULT NULL,
  `examination_result_file` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `examination_job` */

insert  into `examination_job`(`id`,`code`,`class_type`,`class_level`,`examination_type`,`start_time`,`end_time`,`is_delete`,`examination_file`,`examination_result_file`) values (7,'2018020808400611',1,1,1,'2018-02-01 00:00:00','2018-02-28 00:00:00',0,'StudentExaminationMessage(1)1518050406143.xls',NULL),(8,'2018021410222811',1,1,1,'2018-02-14 00:00:00','2018-02-28 00:00:00',0,'StudentExaminationMessage(1)1518574948439.xls',NULL),(9,'2018022408515511',1,1,1,'2018-02-24 00:00:00','2018-02-28 00:00:00',0,'StudentExaminationMessage(1)1519433515108.xls',NULL),(10,'2018022410560811',1,1,1,'2018-02-01 00:00:00','2018-02-02 00:00:00',0,'StudentExaminationMessage(1)1519440968866.xls',NULL);

/*Table structure for table `examination_message` */

DROP TABLE IF EXISTS `examination_message`;

CREATE TABLE `examination_message` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `examination_code` varchar(100) NOT NULL COMMENT '考试编号',
  `student_name` varchar(100) NOT NULL COMMENT '考生姓名',
  `student_card` varchar(100) NOT NULL COMMENT '考生身份证',
  `examination_card` varchar(50) NOT NULL COMMENT '考试证号',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT='考试信息表';

/*Data for the table `examination_message` */

insert  into `examination_message`(`id`,`examination_code`,`student_name`,`student_card`,`examination_card`) values (16,'2018020808400611','张三','320902198507151012','JD20180208084000006001'),(17,'2018020808400611','李四','320902198507151013','JD20180208084000006002'),(18,'2018020808400611','王五','32090219850715101X','JD20180208084000006003'),(19,'2018021410222811','张三','320902198507151012','JD20180214102200029001'),(20,'2018021410222811','李四','320902198507151013','JD20180214102200029002'),(21,'2018021410222811','王五','32090219850715101X','JD20180214102200029003'),(22,'2018022408515511','张三','320902198507151012','JD20180224085100055001'),(23,'2018022408515511','李四','320902198507151013','JD20180224085100055002'),(24,'2018022408515511','王五','32090219850715101X','JD20180224085100055003'),(25,'2018022410560811','张三','320902198507151012','JD20180224105600009001'),(26,'2018022410560811','李四','320902198507151013','JD20180224105600009002'),(27,'2018022410560811','王五','32090219850715101X','JD20180224105600009003');

/*Table structure for table `examination_result` */

DROP TABLE IF EXISTS `examination_result`;

CREATE TABLE `examination_result` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `em_id` int(10) NOT NULL,
  `real_start_time` datetime DEFAULT NULL,
  `real_end_time` datetime DEFAULT NULL,
  `score` int(10) DEFAULT NULL,
  `is_pass` int(1) DEFAULT NULL,
  `index` int(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

/*Data for the table `examination_result` */

insert  into `examination_result`(`id`,`em_id`,`real_start_time`,`real_end_time`,`score`,`is_pass`,`index`) values (7,20,'2018-02-14 17:00:57','2018-02-14 17:04:40',3,0,1),(8,20,'2018-02-14 17:12:28','2018-02-14 18:11:32',1,0,2),(9,19,'2018-02-21 14:16:52','2018-02-21 14:22:24',1,0,1),(10,19,'2018-02-21 14:23:17','2018-02-21 14:42:51',3,0,2),(11,21,'2018-02-21 15:24:12',NULL,NULL,NULL,1),(12,22,'2018-02-24 08:53:01','2018-02-24 08:56:31',2,0,1),(13,22,'2018-02-24 08:57:08','2018-02-24 08:57:43',1,0,2);

/*Table structure for table `job` */

DROP TABLE IF EXISTS `job`;

CREATE TABLE `job` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `code` varchar(100) NOT NULL,
  `stuts` int(1) NOT NULL DEFAULT '0',
  `weight` int(2) DEFAULT '10' COMMENT '权重：1 5 10',
  `user_id` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

/*Data for the table `job` */

insert  into `job`(`id`,`code`,`stuts`,`weight`,`user_id`) values (4,'3CEB7AC91ED0432598AA40331CCEDF84',1,10,5),(5,'7471E2FF2CAE4ED396B3575ECFD0F4DE',1,10,5),(6,'2DE4080944C949358D8350C74BD649EC',1,10,5),(7,'476FF8B3AA744EBB81D00CB20C9BFB7F',1,10,5),(8,'EEA615C9FEC44E8889DFCD5EF46C9B81',1,10,5),(9,'A8BA6712B5BD460D97710F75E8C1B1CB',1,10,5),(10,'C7F4AFB996D745738C0889FF050300E9',1,10,5),(11,'2DFD0E38AB1D409B8528FB59A0CD9413',1,10,5),(12,'5261482263FE4D119A22F7DB2A812D73',2,10,5),(13,'A4E200DB1C794AD8920C0F342B4CA0C8',1,10,5),(14,'2419134F66A141EEB4264B52BD0F4A2C',2,10,5),(15,'ADFE01E6A1764C5880A8C55764CFEA12',2,10,5),(16,'D93F7AB8A31940FC94F66CC8A7445973',1,10,5),(17,'B833BD241ABB4A3AA9C4708C2FD84B97',1,10,5);

/*Table structure for table `upload_file_list` */

DROP TABLE IF EXISTS `upload_file_list`;

CREATE TABLE `upload_file_list` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `file_name` varchar(100) NOT NULL,
  `file_path` varchar(100) NOT NULL,
  `job_code` varchar(100) NOT NULL,
  `class_type` int(10) NOT NULL,
  `class_level` int(10) NOT NULL,
  `user_id` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;

/*Data for the table `upload_file_list` */

insert  into `upload_file_list`(`id`,`file_name`,`file_path`,`job_code`,`class_type`,`class_level`,`user_id`) values (2,'Questions1516683975811.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','b9fc475c50a140508d1619a88f5ac6f0',1,1,7),(3,'Questions1517203541073.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','6ffc0a7b15a64beea101f48a28efe908',1,1,7),(4,'Questions1517204022821.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','4791ea4bc0824f7393d85d7a2e9b01ae',1,1,7),(5,'Questions1517204232095.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','79b090288cb940acb53305f4b3f00f10',1,1,7),(6,'Questions1517204308877.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','091f3e1add9441238fd793c55210bc27',1,1,7),(7,'Questions1517377831301.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','A80B4DF5EB754585816F49E354E7D7B2',1,1,5),(8,'Questions1517377839931.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','A80B4DF5EB754585816F49E354E7D7B2',1,1,5),(9,'Questions1517377855879.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','A80B4DF5EB754585816F49E354E7D7B2',1,1,5),(10,'Questions1517378028482.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','0627F83FE9DF41EE87F7055BEC742594',1,1,5),(11,'Questions1517378272869.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','08882604B60F473EB7718AE25CD83AE8',1,1,5),(12,'Questions1517378280473.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','08882604B60F473EB7718AE25CD83AE8',1,1,5),(13,'Questions1517378516159.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','3CEB7AC91ED0432598AA40331CCEDF84',1,1,5),(14,'Questions1517378525104.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','3CEB7AC91ED0432598AA40331CCEDF84',1,1,5),(15,'Questions1517378533087.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','3CEB7AC91ED0432598AA40331CCEDF84',1,1,5),(16,'Questions1517378540058.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','3CEB7AC91ED0432598AA40331CCEDF84',1,1,5),(17,'Questions1517378723164.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','7471E2FF2CAE4ED396B3575ECFD0F4DE',1,1,5),(18,'Questions1517378733594.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','7471E2FF2CAE4ED396B3575ECFD0F4DE',1,1,5),(19,'Questions1517378843633.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','2DE4080944C949358D8350C74BD649EC',1,1,5),(20,'Questions1517379054872.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','476FF8B3AA744EBB81D00CB20C9BFB7F',1,1,5),(21,'Questions1517379175693.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','EEA615C9FEC44E8889DFCD5EF46C9B81',1,1,5),(22,'Questions1517379290755.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','A8BA6712B5BD460D97710F75E8C1B1CB',1,1,5),(23,'Questions1517379344886.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','C7F4AFB996D745738C0889FF050300E9',1,1,5),(24,'Questions1517379353803.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','C7F4AFB996D745738C0889FF050300E9',1,1,5),(25,'Questions1517379361718.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','2DFD0E38AB1D409B8528FB59A0CD9413',1,3,5),(26,'Questions1517454284410.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','5261482263FE4D119A22F7DB2A812D73',1,3,5),(27,'Questions1517454294123.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','5261482263FE4D119A22F7DB2A812D73',1,3,5),(28,'Questions1517454300836.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','5261482263FE4D119A22F7DB2A812D73',1,3,5),(29,'Questions1517454631257.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','A4E200DB1C794AD8920C0F342B4CA0C8',1,3,5),(30,'Questions1517454747989.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','2419134F66A141EEB4264B52BD0F4A2C',1,3,5),(31,'Questions1517454821302.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','ADFE01E6A1764C5880A8C55764CFEA12',1,3,5),(32,'Questions1517455078504.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','D93F7AB8A31940FC94F66CC8A7445973',1,3,5),(33,'Questions1517455091363.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','D93F7AB8A31940FC94F66CC8A7445973',1,3,5),(34,'Questions1517455102936.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','D93F7AB8A31940FC94F66CC8A7445973',1,3,5),(35,'Questions1519433300945.xls','E:\\workspace2\\.metadata\\.me_tcat\\webapps\\examination\\upload','B833BD241ABB4A3AA9C4708C2FD84B97',1,3,5);

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(50) NOT NULL COMMENT '用户名',
  `pass_word` varchar(100) NOT NULL COMMENT '密码',
  `sex` int(1) DEFAULT NULL COMMENT '性别',
  `age` int(3) DEFAULT NULL COMMENT '年龄',
  `phone` varchar(20) DEFAULT NULL COMMENT '电话',
  `id_card` varchar(20) DEFAULT NULL COMMENT '身份证',
  `user_type` int(1) NOT NULL COMMENT '用户类型',
  `create_time` datetime NOT NULL COMMENT '新建时间',
  `update_time` datetime NOT NULL COMMENT '修改时间',
  `is_delete` int(1) NOT NULL DEFAULT '0' COMMENT '是否删除',
  `stuts` int(1) NOT NULL DEFAULT '0',
  `real_name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`id`,`user_name`,`pass_word`,`sex`,`age`,`phone`,`id_card`,`user_type`,`create_time`,`update_time`,`is_delete`,`stuts`,`real_name`) values (4,'munsina','17f4f0ee99f17b0d1c262f633b12fee9',1,18,'18914641632','320902198507151012',1,'2018-01-08 11:48:11','2018-01-08 11:48:11',0,1,NULL),(5,'lzl123','cbc953d1937ff5d24efab5947db30193',0,NULL,'','',2,'2018-01-09 08:57:47','2018-01-09 08:57:47',0,1,NULL),(6,'ybb123','aeae3c6c70eb920a6affdf34ef9a9a12',1,NULL,'','',4,'2018-01-09 09:47:07','2018-01-09 09:47:07',0,1,'杨斌斌'),(7,'zy123','c6cbdc1a767e4bf23270175f2cbf1d32',0,31,'','',3,'2018-01-09 10:39:58','2018-01-09 10:39:58',0,1,'张玉');

/*Table structure for table `user_type` */

DROP TABLE IF EXISTS `user_type`;

CREATE TABLE `user_type` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '用户类型id',
  `name` varchar(20) NOT NULL COMMENT '用户类型名称',
  `with_out` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='用户类型表';

/*Data for the table `user_type` */

insert  into `user_type`(`id`,`name`,`with_out`) values (1,'管理员',1),(2,'老师',0),(3,'教务',0),(4,'校长',0),(5,'学员',1);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
